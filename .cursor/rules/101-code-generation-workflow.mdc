---
description: USE WHEN generating new code or implementing features to ensure consistent approach and best practices
globs: 
  - "pepperpy/**/*.py"
  - "plugins/**/*.py"
  - "scripts/**/*.py"
alwaysApply: true
---

# Code Generation Workflow

## Overview

This rule defines the standardized workflow for generating new code in the PepperPy framework. It provides a structured approach to ensure that generated code is consistent, follows architectural patterns, and integrates properly with the existing codebase.

## Code Generation Pre-Checks

Before generating ANY code, always perform these mandatory checks:

1. **Context Analysis**
   - Identify the module/domain the code will belong to
   - Understand the existing architecture patterns
   - Review similar implementations
   - Identify relevant base classes and interfaces

2. **File Location Check**
   - Determine the correct location for new files
   - Verify directory structure follows framework patterns
   - Check for existing files with similar functionality

3. **Import Analysis**
   - Identify required imports from the framework
   - Verify imports refer to public APIs
   - Avoid circular dependencies

## Generation Workflow Stages

### 1. Framework Analysis

```bash
# Check module structure
ls -la pepperpy/target_module/

# Find similar implementations
grep -r "class SimilarImplementation" pepperpy/

# Verify base interfaces
cat pepperpy/target_module/base.py
```

### 2. Skeleton Structure Generation

First, generate only the basic structure:

```python
"""Module description."""

from typing import Dict, Any, Optional
from pepperpy.domain import BaseInterface

class NewImplementation(BaseInterface):
    """Implementation description."""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
    
    # Method declarations with docstrings
    def method(self) -> None:
        """Method description."""
        pass
```

### 3. Interface Implementation

Implement required interface methods:

```python
def required_method(self, param: str) -> bool:
    """Required method from interface.
    
    Args:
        param: Parameter description
        
    Returns:
        Result description
    """
    # Implementation
    return True
```

### 4. Integration Code

Add code for integration with other components:

```python
from pepperpy.core.utils import shared_utility

def process(self, data: Dict[str, Any]) -> str:
    """Process data.
    
    Args:
        data: Input data
        
    Returns:
        Processed result
    """
    # Pre-processing
    normalized = shared_utility(data)
    
    # Core processing
    result = self._internal_process(normalized)
    
    # Post-processing
    return self._format_result(result)
```

### 5. Testing Code

Generate tests for the implementation:

```python
import pytest
from pepperpy.domain import create_implementation

def test_implementation():
    """Test implementation functionality."""
    # Given
    impl = create_implementation(config={"param": "value"})
    
    # When
    result = impl.process({"key": "value"})
    
    # Then
    assert result == expected_value
```

## Pattern-Based Generation

Always use these established patterns:

### 1. Factory Function Pattern

```python
def create_processor(processor_type: str = None, **config) -> Processor:
    """Create a processor.
    
    Args:
        processor_type: Type of processor
        **config: Configuration
        
    Returns:
        Configured processor
    """
    # Default from environment
    processor_type = processor_type or os.environ.get(
        "PEPPERPY_PROCESSOR_TYPE", "default")
    
    # Import lazily
    if processor_type == "specific":
        from .processors.specific import SpecificProcessor
        return SpecificProcessor(**config)
    else:
        from .processors.default import DefaultProcessor
        return DefaultProcessor(**config)
```

### 2. Resource Management Pattern

```python
class ResourceManager:
    """Manages resources with lifecycle."""
    
    async def __aenter__(self) -> "ResourceManager":
        """Initialize resources."""
        await self.initialize()
        return self
        
    async def __aexit__(self, *_: Any) -> None:
        """Clean up resources."""
        await self.cleanup()
        
    async def initialize(self) -> None:
        """Initialize resources."""
        if self.initialized:
            return
            
        # Initialize resources
        
    async def cleanup(self) -> None:
        """Clean up resources."""
        # Release resources
```

### 3. Error Handling Pattern

```python
from pepperpy.core.errors import DomainError

def process(self, data: Dict[str, Any]) -> str:
    """Process data safely.
    
    Args:
        data: Input data
        
    Returns:
        Processed result
        
    Raises:
        DomainError: If processing fails
    """
    try:
        # Validation
        if not data:
            raise ValueError("Empty data")
            
        # Processing
        result = self._process_data(data)
        return result
        
    except ValueError as e:
        # Convert to domain error
        raise DomainError(f"Validation error: {e}") from e
    except ExternalError as e:
        # Convert external errors
        raise DomainError(f"External processing error: {e}") from e
```

### 4. Configuration Pattern

```python
class ConfigurableComponent:
    """Component with configuration."""
    
    # Type annotations for config
    api_key: str
    timeout: int = 30
    retry_count: int = 3
    
    def __init__(self, **kwargs):
        """Initialize with configuration.
        
        Config is automatically bound to attributes.
        """
        super().__init__(**kwargs)
        
    def process(self) -> None:
        """Process using configuration."""
        # Access config directly as attributes
        client = Client(api_key=self.api_key, timeout=self.timeout)
```

### 5. Extension Pattern

```python
class BaseProcessor:
    """Base processor with extension points."""
    
    def process(self, data: Dict[str, Any]) -> str:
        """Process data with extension points.
        
        Args:
            data: Input data
            
        Returns:
            Processed result
        """
        # Pre-processing hook
        processed = self._pre_process(data)
        
        # Core processing
        result = self._process(processed)
        
        # Post-processing hook
        return self._post_process(result)
        
    def _pre_process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Pre-processing hook."""
        return data
        
    def _process(self, data: Dict[str, Any]) -> str:
        """Core processing."""
        raise NotImplementedError("Subclasses must implement")
        
    def _post_process(self, result: str) -> str:
        """Post-processing hook."""
        return result
```

## Domain-Specific Patterns

### LLM Provider Pattern

```python
from pepperpy.llm import LLMProvider
from pepperpy.plugin import ProviderPlugin

class SpecificLLMProvider(LLMProvider, ProviderPlugin):
    """Specific LLM provider implementation."""
    
    # Type-annotated config
    api_key: str
    model: str
    temperature: float = 0.7
    
    async def initialize(self) -> None:
        """Initialize provider."""
        if self.initialized:
            return
            
        self.client = Client(api_key=self.api_key)
        
    async def call(self, prompt: str) -> str:
        """Call LLM.
        
        Args:
            prompt: The prompt to send
            
        Returns:
            LLM response
        """
        try:
            response = await self.client.complete(
                prompt, 
                model=self.model,
                temperature=self.temperature
            )
            return response.text
        except ClientError as e:
            raise LLMError(f"Error calling LLM: {e}") from e
            
    async def cleanup(self) -> None:
        """Clean up resources."""
        if hasattr(self, 'client') and self.client:
            await self.client.close()
```

### Content Processor Pattern

```python
from pepperpy.content import ContentProcessor
from pepperpy.plugin import ProviderPlugin

class SpecificContentProcessor(ContentProcessor, ProviderPlugin):
    """Specific content processor implementation."""
    
    # Type-annotated config
    language: str = "en"
    options: Dict[str, Any] = {}
    
    async def initialize(self) -> None:
        """Initialize processor."""
        if self.initialized:
            return
            
        self.processor = self._create_processor(self.language)
        
    async def process(self, content: str) -> str:
        """Process content.
        
        Args:
            content: Content to process
            
        Returns:
            Processed content
        """
        return self.processor.process(
            content, 
            **self.options
        )
```

## Implementation Verification

After generating code, verify:

1. **Base Class Compliance**
   - All required methods are implemented
   - Method signatures match base class
   - Proper super() calls where needed

2. **Typing Correctness**
   - All parameters have type annotations
   - Return types are specified
   - Type annotations match usage

3. **Documentation Completeness**
   - All classes have docstrings
   - All public methods have docstrings
   - Arguments and returns are documented

4. **Error Handling**
   - All errors are properly caught
   - Domain-specific errors are used
   - Resources are released on error

5. **Resource Management**
   - All resources are properly initialized
   - All resources are properly cleaned up
   - Cleanup handles partial initialization

## Anti-Patterns to Avoid

### 1. Import Anti-Patterns

❌ **NEVER import from internal modules**
```python
# WRONG: Importing from implementation
from pepperpy.content.processors.text_normalization import BasicTextNormalizer
```

✅ **ALWAYS import from public API**
```python
# Correct: Importing from public API
from pepperpy.content import create_text_normalizer
```

### 2. State Management Anti-Patterns

❌ **NEVER use module-level state**
```python
# WRONG: Module-level state
_shared_client = None  # Global state

def get_client():
    global _shared_client
    if not _shared_client:
        _shared_client = create_client()
    return _shared_client
```

✅ **ALWAYS encapsulate state**
```python
# Correct: Encapsulated state
class ClientManager:
    def __init__(self):
        self.client = None
        
    def get_client(self):
        if not self.client:
            self.client = create_client()
        return self.client
```

### 3. Error Handling Anti-Patterns

❌ **NEVER catch and silence errors**
```python
# WRONG: Silencing errors
try:
    result = api.call()
except Exception:  # Catch-all
    result = None  # Silently continue
```

✅ **ALWAYS propagate errors properly**
```python
# Correct: Proper error handling
try:
    result = api.call()
except APIError as e:
    raise DomainError(f"API call failed: {e}") from e
```

### 4. Resource Management Anti-Patterns

❌ **NEVER leave resources uncleaned**
```python
# WRONG: Resources not cleaned
def process(self):
    self.file = open("data.txt", "w")
    # No cleanup!
```

✅ **ALWAYS ensure cleanup**
```python
# Correct: Proper cleanup
async def process(self):
    try:
        self.file = open("data.txt", "w")
        # Processing
    finally:
        if hasattr(self, 'file'):
            self.file.close()
```

## Code Generation Examples

### Example 1: New Provider Implementation

```python
"""OpenAI LLM provider implementation."""

from typing import Dict, Any, Optional
from openai import AsyncOpenAI
from openai.types import Completion

from pepperpy.llm import LLMProvider, LLMError
from pepperpy.plugin import ProviderPlugin

class OpenAIProvider(LLMProvider, ProviderPlugin):
    """OpenAI LLM provider implementation."""
    
    # Type-annotated config attributes
    api_key: str
    model: str
    temperature: float = 0.7
    max_tokens: int = 1000
    
    def __init__(self, **kwargs):
        """Initialize provider."""
        super().__init__(**kwargs)
        self.client = None
    
    async def initialize(self) -> None:
        """Initialize the OpenAI client."""
        if self.initialized:
            return
            
        self.client = AsyncOpenAI(api_key=self.api_key)
        self.logger.debug(f"Initialized with model={self.model}")
    
    async def call(self, prompt: str) -> str:
        """Call OpenAI API.
        
        Args:
            prompt: The prompt to send
            
        Returns:
            Generated text response
            
        Raises:
            LLMError: If API call fails
        """
        try:
            response = await self.client.completions.create(
                model=self.model,
                prompt=prompt,
                temperature=self.temperature,
                max_tokens=self.max_tokens
            )
            
            return response.choices[0].text.strip()
            
        except Exception as e:
            raise LLMError(f"OpenAI API error: {e}") from e
    
    async def cleanup(self) -> None:
        """Clean up resources."""
        if self.client:
            await self.client.close()
            self.client = None
```

### Example 2: Utility Function

```python
"""Utility functions for text processing."""

from typing import List, Optional, Dict, Any
import re

def normalize_text(
    text: str,
    lowercase: bool = True,
    remove_punctuation: bool = False,
    remove_whitespace: bool = False
) -> str:
    """Normalize text with configurable options.
    
    Args:
        text: Input text to normalize
        lowercase: Whether to convert to lowercase
        remove_punctuation: Whether to remove punctuation
        remove_whitespace: Whether to remove extra whitespace
        
    Returns:
        Normalized text
    """
    if not text:
        return ""
        
    result = text
    
    if lowercase:
        result = result.lower()
        
    if remove_punctuation:
        result = re.sub(r'[^\w\s]', '', result)
        
    if remove_whitespace:
        result = re.sub(r'\s+', ' ', result).strip()
        
    return result
```

### Example 3: Factory Function

```python
"""Factory functions for content processors."""

from typing import Dict, Any, Optional
import os
import importlib

def create_processor(
    processor_type: Optional[str] = None,
    **config: Dict[str, Any]
) -> "ContentProcessor":
    """Create a content processor.
    
    Args:
        processor_type: Type of processor to create
        **config: Processor configuration
        
    Returns:
        Instantiated processor
        
    Raises:
        ValueError: If processor type is unknown
    """
    # Get processor type from env if not specified
    processor_type = processor_type or os.environ.get(
        "PEPPERPY_CONTENT_PROCESSOR", "basic")
    
    try:
        # Handle built-in processors
        if processor_type == "basic":
            from .processors.basic import BasicProcessor
            return BasicProcessor(**config)
        elif processor_type == "advanced":
            from .processors.advanced import AdvancedProcessor
            return AdvancedProcessor(**config)
        else:
            # Try dynamic import for custom processors
            module_path = f"pepperpy.content.processors.{processor_type}"
            module = importlib.import_module(module_path)
            class_name = f"{processor_type.capitalize()}Processor"
            processor_class = getattr(module, class_name)
            return processor_class(**config)
    except (ImportError, AttributeError) as e:
        raise ValueError(f"Unknown processor type '{processor_type}': {e}")
```

## Conclusion

This structured code generation workflow ensures:

1. **Consistent code** across the framework
2. **Proper architecture** alignment
3. **Pattern compliance**
4. **Error handling** consistency
5. **Resource management** correctness

Always follow this workflow when generating or implementing new code in the PepperPy framework.
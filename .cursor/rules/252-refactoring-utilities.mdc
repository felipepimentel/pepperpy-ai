---
description: USE WHEN implementing or using utility functions in the refactoring tools
globs: scripts/refactoring_tools/**/*.py
alwaysApply: false
---

# Refactoring Utilities Guidelines

## Code Analysis Tools

1. **Dependency Analyzer**:
```python
class DependencyAnalyzer:
    """Analyze module dependencies and imports."""
    
    def __init__(self, context: RefactoringContext):
        self.context = context
        self._import_cache = {}
        
    def find_module_dependencies(self, module_path: str) -> Dict[str, Set[str]]:
        """Find all dependencies for a module."""
        try:
            with open(module_path, "r") as f:
                content = f.read()
            tree = ast.parse(content)
            return self._extract_imports(tree)
        except Exception as e:
            self.context.logger.error(f"Failed to analyze {module_path}: {e}")
            return {}
```

2. **Code Complexity Analyzer**:
```python
class ComplexityAnalyzer:
    """Analyze code complexity metrics."""
    
    def analyze_complexity(self, node: ast.AST) -> Dict[str, int]:
        """Calculate complexity metrics for AST node."""
        return {
            "cyclomatic": self._calc_cyclomatic_complexity(node),
            "cognitive": self._calc_cognitive_complexity(node),
            "maintainability": self._calc_maintainability_index(node)
        }
```

3. **Type Checker**:
```python
class TypeChecker:
    """Verify type hints and annotations."""
    
    def check_types(self, module_path: str) -> List[TypeIssue]:
        """Find type issues in a module."""
        import mypy.api
        result = mypy.api.run([module_path])
        return self._parse_mypy_output(result[0])
```

## Code Transformation Tools

1. **Import Organizer**:
```python
class ImportOrganizer:
    """Organize and clean up imports."""
    
    def organize_imports(self, content: str) -> str:
        """Sort and deduplicate imports."""
        tree = ast.parse(content)
        imports = self._collect_imports(tree)
        organized = self._sort_imports(imports)
        return self._generate_import_block(organized)
```

2. **Code Formatter**:
```python
class CodeFormatter:
    """Format code according to project standards."""
    
    def format_code(self, content: str) -> str:
        """Format code using black and isort."""
        import black
        import isort
        content = isort.code(content)
        return black.format_str(content, mode=black.FileMode())
```

3. **Dead Code Eliminator**:
```python
class DeadCodeEliminator:
    """Find and remove unused code."""
    
    def find_dead_code(self, tree: ast.AST) -> List[CodeRegion]:
        """Identify unused functions, classes, and imports."""
        return [
            self._find_unused_imports(tree),
            self._find_unused_functions(tree),
            self._find_unused_classes(tree)
        ]
```

## Code Quality Tools

1. **Style Checker**:
```python
class StyleChecker:
    """Check code style against project standards."""
    
    def check_style(self, content: str) -> List[StyleIssue]:
        """Run style checks using flake8."""
        import flake8.api.legacy as flake8
        style_guide = flake8.get_style_guide()
        return style_guide.check_code(content)
```

2. **Documentation Analyzer**:
```python
class DocAnalyzer:
    """Analyze documentation completeness."""
    
    def check_documentation(self, tree: ast.AST) -> List[DocIssue]:
        """Check docstring coverage and quality."""
        return {
            "missing_docstrings": self._find_missing_docs(tree),
            "incomplete_docs": self._find_incomplete_docs(tree),
            "example_coverage": self._check_example_coverage(tree)
        }
```

3. **Security Checker**:
```python
class SecurityChecker:
    """Check for security issues."""
    
    def check_security(self, content: str) -> List[SecurityIssue]:
        """Run security checks using bandit."""
        import bandit
        return bandit.run_check(content)
```

## Performance Tools

1. **Profile Collector**:
```python
class ProfileCollector:
    """Collect performance metrics."""
    
    def profile_operation(self, func: Callable) -> Dict[str, float]:
        """Profile a function execution."""
        import cProfile
        import pstats
        
        profiler = cProfile.Profile()
        profiler.enable()
        result = func()
        profiler.disable()
        
        stats = pstats.Stats(profiler)
        return {
            "total_time": stats.total_tt,
            "calls": stats.total_calls,
            "primitive_calls": stats.prim_calls
        }
```

2. **Memory Tracker**:
```python
class MemoryTracker:
    """Track memory usage."""
    
    def track_memory(self, func: Callable) -> Dict[str, int]:
        """Track memory usage of a function."""
        import tracemalloc
        
        tracemalloc.start()
        result = func()
        snapshot = tracemalloc.take_snapshot()
        tracemalloc.stop()
        
        return {
            "peak": snapshot.statistics("lineno")[0].size,
            "allocated": snapshot.traces[0].size
        }
```

## Testing Tools

1. **Test Generator**:
```python
class TestGenerator:
    """Generate test cases."""
    
    def generate_tests(self, module_path: str) -> str:
        """Generate test cases for a module."""
        tree = ast.parse(Path(module_path).read_text())
        test_cases = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                test_cases.extend(self._generate_function_tests(node))
            elif isinstance(node, ast.ClassDef):
                test_cases.extend(self._generate_class_tests(node))
                
        return self._format_test_file(test_cases)
```

2. **Coverage Reporter**:
```python
class CoverageReporter:
    """Generate coverage reports."""
    
    def generate_coverage(self, test_dir: str) -> Dict[str, float]:
        """Generate coverage report for tests."""
        import coverage
        
        cov = coverage.Coverage()
        cov.start()
        # Run tests
        cov.stop()
        
        return {
            "line": cov.report(),
            "branch": cov.report(show_branch=True),
            "missing": self._get_missing_coverage(cov)
        }
```

## Best Practices

1. **Tool Integration**:
   - Each tool should be independent
   - Use composition over inheritance
   - Cache results when appropriate
   - Support dry-run mode

2. **Error Handling**:
   - Log all errors through context
   - Provide meaningful error messages
   - Include suggestions for fixes
   - Support recovery options

3. **Performance**:
   - Use generators for large datasets
   - Cache expensive operations
   - Support incremental updates
   - Allow parallel processing

4. **Testing**:
   - Unit test each tool
   - Test with large codebases
   - Verify error handling
   - Check edge cases

## Usage Examples

1. **Analyzing Code Quality**:
```python
def analyze_code_quality(file_path: str, context: RefactoringContext) -> Dict:
    """Run comprehensive code analysis."""
    analyzers = [
        ComplexityAnalyzer(context),
        TypeChecker(context),
        StyleChecker(context),
        DocAnalyzer(context),
        SecurityChecker(context)
    ]
    
    results = {}
    for analyzer in analyzers:
        try:
            results[analyzer.__class__.__name__] = analyzer.analyze(file_path)
        except Exception as e:
            context.logger.error(f"Analysis failed: {e}")
            
    return results
```

2. **Optimizing Code**:
```python
def optimize_code(content: str, context: RefactoringContext) -> str:
    """Run code optimizations."""
    optimizers = [
        ImportOrganizer(context),
        DeadCodeEliminator(context),
        CodeFormatter(context)
    ]
    
    for optimizer in optimizers:
        try:
            content = optimizer.optimize(content)
        except Exception as e:
            context.logger.error(f"Optimization failed: {e}")
            
    return content
``` 
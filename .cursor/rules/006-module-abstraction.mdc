---
title: Module Abstraction and Interface Organization
description: "Aplicar esta regra quando implementar novos módulos ou modificar os existentes para garantir que o desenvolvedor final precise apenas configurar as variáveis de ambiente e usar a interface pública, sem conhecimento das implementações específicas"
globs:
  - "pepperpy/**/*.py"
priority: 600
---

# Abstração de Módulos e Organização de Interfaces

## Visão Geral

Esta regra define os padrões para organização de módulos e interfaces no framework PepperPy, garantindo uma abstração clara entre a API pública e as implementações internas.

## Estrutura de Módulos

### Organização de Arquivos

Cada módulo deve seguir esta estrutura:

```
module/
├── __init__.py         # API pública do módulo
├── base.py            # Interfaces e classes base
├── providers/         # Implementações específicas
│   ├── __init__.py
│   └── specific.py
└── utils/             # Utilitários do módulo (opcional)
    └── __init__.py
```

### Responsabilidades dos Arquivos

1. **base.py**:
   - Interfaces principais (Protocols/ABC)
   - Classes base abstratas
   - Tipos e modelos de dados
   - Configurações base

2. **__init__.py**:
   - API pública do módulo
   - Re-exportação de tipos e interfaces
   - Funções de alto nível

3. **providers/**:
   - Implementações concretas
   - Integrações com serviços externos

## Padrões de Interface

### 1. Interfaces em base.py

✅ **Correto**:
```python
# base.py
from typing import Protocol

class Provider(Protocol):
    """Interface principal do provider."""
    async def initialize(self) -> None: ...
    async def process(self, data: dict) -> dict: ...

class Config:
    """Configuração base."""
    def __init__(self, api_key: str): ...
```

❌ **Incorreto**:
```python
# provider.py  # Não criar arquivo separado para interfaces
class Provider:
    """Interface do provider."""
    pass

# base.py
from .provider import Provider  # Não importar de arquivo separado
```

### 2. Implementações em providers/

✅ **Correto**:
```python
# providers/openai.py
from ..base import Provider

class OpenAIProvider(Provider):
    """Implementação OpenAI do provider."""
    async def initialize(self) -> None:
        # Implementação
        pass
```

❌ **Incorreto**:
```python
# base.py
class OpenAIProvider(Provider):  # Não implementar em base.py
    pass
```

### 3. API Pública em __init__.py

✅ **Correto**:
```python
# __init__.py
from .base import Provider, Config
from .providers.openai import OpenAIProvider

__all__ = ["Provider", "Config", "OpenAIProvider"]

def create_provider(config: Config) -> Provider:
    """Criar instância do provider."""
    return OpenAIProvider(config)
```

❌ **Incorreto**:
```python
# __init__.py
from .provider import Provider  # Não importar de arquivo separado
from .base import Config  # Manter todas as interfaces em base.py
```

## Exemplos de Implementação

### Exemplo: Módulo de Agentes

```python
# base.py
from typing import Protocol, Dict, Any

class Message:
    """Mensagem de um agente."""
    role: str
    content: str

class AgentProvider(Protocol):
    """Interface do provider de agentes."""
    async def initialize(self) -> None: ...
    async def execute(self, task: str) -> List[Message]: ...

# providers/autogen.py
from ..base import AgentProvider, Message

class AutoGenProvider(AgentProvider):
    """Implementação usando AutoGen."""
    async def initialize(self) -> None:
        # Implementação
        pass

# __init__.py
from .base import AgentProvider, Message
from .providers.autogen import AutoGenProvider

async def create_agent(config: Dict[str, Any]) -> AgentProvider:
    """Criar um agente com a configuração fornecida."""
    provider = AutoGenProvider(config)
    await provider.initialize()
    return provider
```

## Validação

Use estas verificações para validar a estrutura do módulo:

1. **Interfaces**:
   - Devem estar em `base.py`
   - Usar `Protocol` ou `ABC`
   - Documentar com docstrings

2. **Implementações**:
   - Devem estar em `providers/`
   - Implementar interfaces de `base.py`
   - Não expor detalhes internos

3. **API Pública**:
   - Expor apenas o necessário em `__init__.py`
   - Documentar a API pública
   - Manter retrocompatibilidade

## Conclusão

Seguindo estes padrões de organização de módulos e interfaces, garantimos:

1. **Clareza**: Estrutura consistente e previsível
2. **Manutenibilidade**: Separação clara de responsabilidades
3. **Extensibilidade**: Fácil adição de novas implementações
4. **Usabilidade**: API pública clara e bem documentada 
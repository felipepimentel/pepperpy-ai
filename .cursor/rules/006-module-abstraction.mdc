---
title: Module Abstraction and Interface Organization
description: Apply this rule when implementing new modules or modifying existing ones to ensure that the end developer only needs to configure environment variables and use the public interface, without knowledge of specific implementations
globs:
  - "pepperpy/**/*.py"
priority: 600
---

# Module Abstraction and Interface Organization

## Overview

This rule defines standards for organizing modules and interfaces in the PepperPy framework, ensuring a clear abstraction between the public API and internal implementations.

## Module Structure

### File Organization

Each module should follow this structure:

```
module/
├── __init__.py         # Public API of the module
├── base.py            # Interfaces and base classes
├── providers/         # Specific implementations
│   ├── __init__.py
│   └── specific.py
└── utils/             # Module utilities (optional)
    └── __init__.py
```

### File Responsibilities

1. **base.py**:
   - Main interfaces (Protocols/ABC)
   - Abstract base classes
   - Data types and models
   - Base configurations

2. **__init__.py**:
   - Public API of the module
   - Re-export of types and interfaces
   - High-level functions

3. **providers/**:
   - Concrete implementations
   - Integrations with external services

## Interface Patterns

### 1. Interfaces in base.py

✅ **Correct**:
```python
# base.py
from typing import Protocol

class Provider(Protocol):
    """Main provider interface."""
    async def initialize(self) -> None: ...
    async def process(self, data: dict) -> dict: ...

class Config:
    """Base configuration."""
    def __init__(self, api_key: str): ...
```

❌ **Incorrect**:
```python
# provider.py  # Don't create separate file for interfaces
class Provider:
    """Provider interface."""
    pass

# base.py
from .provider import Provider  # Don't import from separate file
```

### 2. Implementations in providers/

✅ **Correct**:
```python
# providers/openai.py
from ..base import Provider

class OpenAIProvider(Provider):
    """OpenAI implementation of the provider."""
    async def initialize(self) -> None:
        # Implementation
        pass
```

❌ **Incorrect**:
```python
# base.py
class OpenAIProvider(Provider):  # Don't implement in base.py
    pass
```

### 3. Public API in __init__.py

✅ **Correct**:
```python
# __init__.py
from .base import Provider, Config
from .providers.openai import OpenAIProvider

__all__ = ["Provider", "Config", "OpenAIProvider"]

def create_provider(config: Config) -> Provider:
    """Create provider instance."""
    return OpenAIProvider(config)
```

❌ **Incorrect**:
```python
# __init__.py
from .provider import Provider  # Don't import from separate file
from .base import Config  # Keep all interfaces in base.py
```

## Implementation Examples

### Example: Agents Module

```python
# base.py
from typing import Protocol, Dict, Any

class Message:
    """Message from an agent."""
    role: str
    content: str

class AgentProvider(Protocol):
    """Agent provider interface."""
    async def initialize(self) -> None: ...
    async def execute(self, task: str) -> List[Message]: ...

# providers/autogen.py
from ..base import AgentProvider, Message

class AutoGenProvider(AgentProvider):
    """Implementation using AutoGen."""
    async def initialize(self) -> None:
        # Implementation
        pass

# __init__.py
from .base import AgentProvider, Message
from .providers.autogen import AutoGenProvider

async def create_agent(config: Dict[str, Any]) -> AgentProvider:
    """Create an agent with the provided configuration."""
    provider = AutoGenProvider(config)
    await provider.initialize()
    return provider
```

## Validation

Use these checks to validate module structure:

1. **Interfaces**:
   - Should be in `base.py`
   - Use `Protocol` or `ABC`
   - Document with docstrings

2. **Implementations**:
   - Should be in `providers/`
   - Implement interfaces from `base.py`
   - Don't expose internal details

3. **Public API**:
   - Expose only what's necessary in `__init__.py`
   - Document the public API
   - Maintain backward compatibility

## Conclusion

Following these module and interface organization patterns ensures:

1. **Clarity**: Consistent and predictable structure
2. **Maintainability**: Clear separation of responsibilities
3. **Extensibility**: Easy addition of new implementations
4. **Usability**: Clear and well-documented public API 
---
title: Module Abstraction
description: Guidelines for implementing and using modules in the PepperPy framework
globs:
  - "pepperpy/**/*.py"
priority: 600
---

# Module Abstraction and Interface Organization

## Overview

This rule defines standards for organizing modules and interfaces in the PepperPy framework, ensuring a clear abstraction between the public API and internal implementations.

## Module Structure

### File Organization

Each module follows this structure:

```
module/
├── __init__.py         # Public API exports
├── base.py            # Core interfaces, types, and implementations
└── providers/         # Provider implementations
    ├── __init__.py    # Provider exports
    └── specific.py    # Specific provider
```

### File Responsibilities

1. **base.py**:
   - Interfaces (Protocols/ABC)
   - Base implementations
   - Data types and models
   - Error definitions
   - Core functionality

2. **__init__.py**:
   - Public API exports
   - Re-export of types and interfaces
   - Re-export of providers

3. **providers/**:
   - Concrete implementations
   - Provider-specific code

## Interface Patterns

### 1. Base Module Organization

✅ **Correct**:
```python
# base.py
from typing import Protocol

class LLMError(PepperpyError):
    """Domain-specific errors."""

class Message:
    """Domain data types."""
    role: str
    content: str

class LLMProvider(Protocol):
    """Core provider interface."""
    async def initialize(self) -> None: ...
    async def generate(self, prompt: str) -> str: ...
```

❌ **Incorrect**:
```python
# Scattered across multiple files
# provider.py
class LLMProvider: ...

# types.py
class Message: ...

# errors.py
class LLMError: ...
```

### 2. Public API Organization

✅ **Correct**:
```python
# __init__.py
from .base import LLMProvider, Message, LLMError
from .providers import OpenRouterProvider

__all__ = [
    "LLMProvider",
    "Message",
    "LLMError",
    "OpenRouterProvider"
]
```

❌ **Incorrect**:
```python
# __init__.py
# Don't expose internal details
from .providers.openrouter import OpenRouterProvider
from .base import _internal_function
```

### 3. Provider Implementation

✅ **Correct**:
```python
# providers/openrouter.py
from ..base import LLMProvider, Message, LLMError

class OpenRouterProvider(LLMProvider):
    """OpenRouter implementation."""
    async def generate(self, prompt: str) -> str:
        # Implementation
        ...
```

❌ **Incorrect**:
```python
# Don't implement in base.py
class OpenRouterProvider(LLMProvider):
    pass

# Don't create new interfaces in providers
class CustomProvider(Protocol):
    pass
```

## Module Usage

### 1. Importing Modules

✅ **Correct**:
```python
# Import from module root
from pepperpy.llm import LLMProvider
from pepperpy.rag import RAGContext

# Use interfaces, not implementations
provider: LLMProvider = ...
```

❌ **Incorrect**:
```python
# Don't import implementations directly
from pepperpy.llm.providers.openrouter import OpenRouterProvider

# Don't import from base
from pepperpy.llm.base import LLMProvider
```

### 2. Configuration

✅ **Correct**:
```python
from pepperpy.core import Config

# Use environment variables
config = Config(env_prefix="PEPPERPY_LLM_")
provider = LLMProvider(config)
```

❌ **Incorrect**:
```python
# Don't hardcode configuration
provider = OpenRouterProvider(
    api_key="sk-...",
    model="gpt-4"
)
```

### 3. Error Handling

✅ **Correct**:
```python
try:
    result = await provider.generate(prompt)
except LLMError as e:
    # Handle domain-specific error
    logger.error(f"LLM error: {e}")
finally:
    await provider.cleanup()
```

❌ **Incorrect**:
```python
# Don't catch generic exceptions
try:
    result = await provider.generate(prompt)
except Exception as e:
    pass
```

## Implementation Examples

### Example: RAG Module

```python
# base.py
from typing import Protocol

class RAGError(PepperpyError): ...

class Document:
    """Document for retrieval."""
    content: str
    metadata: dict

class RAGProvider(Protocol):
    """RAG provider interface."""
    async def add_documents(self, docs: list[Document]) -> None: ...
    async def query(self, text: str) -> list[Document]: ...

# __init__.py
from .base import RAGProvider, Document, RAGError
from .providers import ChromaProvider

__all__ = ["RAGProvider", "Document", "RAGError", "ChromaProvider"]

# providers/chroma.py
from ..base import RAGProvider, Document

class ChromaProvider(RAGProvider):
    """Chroma implementation."""
    async def add_documents(self, docs: list[Document]) -> None:
        # Implementation
        ...
```

## Best Practices

1. **Module Organization**:
   - Keep all core functionality in `base.py`
   - Export public API through `__init__.py`
   - Implement providers in `providers/`

2. **Interface Design**:
   - Use Protocol for interfaces
   - Include domain-specific errors
   - Define clear data types

3. **Provider Implementation**:
   - Follow interface contracts
   - Handle errors appropriately
   - Clean up resources

4. **Module Usage**:
   - Import from module root
   - Use interfaces in type hints
   - Configure through environment

## Conclusion

Following these module abstraction patterns ensures:
1. Clean and consistent APIs
2. Clear separation of concerns
3. Easy provider swapping
4. Proper error handling
5. Resource cleanup
6. Configuration flexibility 
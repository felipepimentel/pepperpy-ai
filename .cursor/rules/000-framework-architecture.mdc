---
description: 
globs: 
alwaysApply: false
---
<!--
@title: PepperPy Framework Architecture
@description: Core architecture principles, module organization, and design patterns for the PepperPy framework
@glob: **/*.py
@priority: 1000
-->

# PepperPy Framework Architecture

## Overview

PepperPy is a modular Python framework for building AI-powered applications, with a focus on clean architecture and domain-driven design principles. This rule provides the core understanding of the framework's architecture, module organization, and design patterns.

## Project Structure

The framework is organized into vertical domains, each responsible for a specific business capability:

```
pepperpy/
├── llm/                  # Language Model Domain
│   ├── __init__.py      
│   ├── provider.py      # Core LLM interfaces
│   └── providers/       # LLM implementations
│
├── rag/                  # RAG Domain
│   ├── __init__.py
│   ├── provider.py      # Core RAG interfaces
│   └── providers/       # RAG implementations
│
├── storage/             # Storage Domain
│   ├── __init__.py
│   ├── provider.py      # Core storage interfaces
│   └── providers/       # Storage implementations
│
├── core/               # Core Framework
│   ├── __init__.py
│   ├── capabilities/   # Capability management
│   ├── errors/        # Error definitions
│   └── base/          # Base classes
│
├── cli/                # Command Line Interface
│   ├── __init__.py
│   └── commands/       # CLI commands
│
├── workflow/           # Workflow Engine
│   ├── __init__.py
│   └── providers/      # Workflow implementations
│
├── hub/                # PepperHub Integration
│   ├── __init__.py
│   └── providers/      # Hub implementations
│
├── agents/             # Agent Framework
│   ├── __init__.py
│   └── providers/      # Agent implementations
│
├── cache/              # Caching System
│   ├── __init__.py
│   └── providers/      # Cache implementations
│
└── utils/              # Shared Utilities
    ├── __init__.py
    ├── logging/
    ├── config/
    └── helpers/
```

## Domain Organization

Each domain follows these principles:

1. **Vertical Slicing**: Each module represents a cohesive business domain
2. **Module Independence**: Loose coupling between modules
3. **Clean Interfaces**: Public interfaces exposed via `__init__.py`
4. **Implementation Privacy**: Internal details kept private
5. **Pragmatic Structure**: Structure grows based on actual needs

## Core Design Principles

### 1. Domain-Driven Design

- Clear domain boundaries with self-contained modules
- Domain-specific language and interfaces
- Domain entities, value objects, and services
- Aggregates with clear boundaries

### 2. Clean Architecture

- Separation of concerns with distinct layers
- Dependency inversion (dependencies point inward)
- Interface segregation for clean APIs
- Explicit and controlled dependencies

### 3. Provider Pattern

All major framework capabilities follow the provider pattern:

```python
# Core provider interface
class BaseProvider(Protocol):
    """Base provider interface for framework capabilities."""
    
    def capabilities(self) -> Set[str]:
        """Return the set of capabilities supported by this provider."""
        ...

# Domain-specific provider (e.g., LLM)
class LLMProvider(BaseProvider):
    """Provider interface for language models."""
    
    async def generate(self, prompt: str, **kwargs) -> str:
        """Generate text from a prompt."""
        ...
        
    async def generate_stream(self, prompt: str, **kwargs) -> AsyncIterator[str]:
        """Stream generated text from a prompt."""
        ...

# Implementation example
class OpenAIProvider(LLMProvider):
    """OpenAI implementation of LLMProvider."""
    
    def __init__(self, model_name: str, **kwargs):
        self.model_name = model_name
        self.client = OpenAI(**kwargs)
        
    async def generate(self, prompt: str, **kwargs) -> str:
        # Implementation details
        ...
```

### 4. Capability System

The framework uses a capability system to define and discover provider features:

```python
# Define capabilities
class LLMCapabilities(str, Enum):
    GENERATE = "generate"
    STREAM = "stream"
    EMBEDDING = "embedding"
    FUNCTION_CALLING = "function_calling"

# Check for capabilities
if LLMCapabilities.STREAM in provider.capabilities():
    # Use streaming capability
    async for chunk in provider.generate_stream(prompt):
        # Process streaming chunks
        ...
```

## Module Interaction Patterns

### Dependencies and Imports

1. **Follow clear dependency hierarchy**:
   - Core modules (`core`, `utils`) should not depend on domain modules
   - Domain modules can depend on core and utils
   - No circular dependencies between domains

2. **Import style**:
   - Use absolute imports for external dependencies
   - Use relative imports for internal module components

```python
# Good
from pepperpy.core.base import BaseProvider  # Absolute for framework imports
from .providers import OpenAIProvider        # Relative for internal imports

# Avoid
import pepperpy.core.base  # Too verbose
from pepperpy.llm.providers.openai import OpenAIProvider  # Too brittle
```

### API Design

1. **Public APIs**:
   - Expose only what's needed through `__init__.py`
   - Use strong typing for all public interfaces
   - Provide clear docstrings with examples

2. **Internal APIs**:
   - Prefix private components with underscore
   - Keep implementation details hidden
   - Document internal components for maintainers

## Documentation Standards

Each module should provide:

1. Clear module-level docstring explaining purpose and usage
2. Class and function docstrings following Google style
3. Type annotations for all public APIs
4. Usage examples in docstrings

## Error Handling

Use domain-specific exception hierarchies:

```python
# Core exceptions
class PepperPyError(Exception):
    """Base exception for all framework errors."""
    pass

# Domain-specific exceptions
class LLMError(PepperPyError):
    """Base exception for LLM-related errors."""
    pass

class ProviderNotFoundError(PepperPyError):
    """Raised when a requested provider is not found."""
    pass
```

## Testing Strategy

1. **Unit tests** for individual components
2. **Integration tests** for provider implementations
3. **End-to-end tests** for complete workflows
4. Test utilities in each domain's `testing` module

## Extension and Plugin System

The framework provides extension points through:

1. **Provider Registry**: Register custom providers
2. **Capability Discovery**: Query for capabilities
3. **Plugin System**: Load and register plugins

## Future Evolution

The framework is evolving toward:

1. More flexible composition patterns
2. Enhanced workflow capabilities
3. Improved RAG and agent frameworks
4. Better integration with external systems

## Final Principles

When working with the PepperPy framework:

1. **Respect domain boundaries**
2. **Follow the provider pattern**
3. **Use clean interfaces**
4. **Maintain backward compatibility**
5. **Write comprehensive tests**
6. **Document public APIs** 
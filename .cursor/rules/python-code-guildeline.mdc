---
title: Python Code Guildeline
description: Describes the code guildeline for the Pepperpy project
globs: **/*.py
---

# Python Code Guideline

## Overview
This guideline aims to produce and maintain Python code that follows best practices, ensuring readability, maintainability, and overall code quality. It integrates linting, formatting, type-checking, and adherence to Pythonic principles. All configurations (for tools like `ruff`, `black`, `isort`, `mypy`) should be centralized in `pyproject.toml`.

## Pythonic Philosophy
- **Readability Matters**: Prefer clear and concise code over overly clever solutions.
- **Consistent Naming**: Use `snake_case` for functions and variables, `CamelCase` for classes, and uppercase for constants.
- **Docstrings and Annotations**: Provide clear docstrings (Google-style or reStructuredText) and type hints to improve code clarity and tool assistance.
- **Single Responsibility**: Keep functions and classes focused. A single function/method should do one thing well.
- **Easier to Ask for Forgiveness (EAFP)**: Embrace Pythonâ€™s idiomatic style of handling exceptions rather than excessive pre-checking.

## Priority Levels

1. **Auto-Fix (Level 1)**
   - Missing or basic type hints
   - Import sorting (via isort)
   - Code formatting (via Black)
   - Unused imports (e.g., autoflake)
   - Variable naming inconsistencies (simple snake_case corrections)
   - Missing or minimal docstrings (generate a short default if completely absent)

2. **Propose Fix (Level 2)**
   - More complex type hints (generics, advanced PEP features)
   - Missing or incomplete class attributes
   - Missing configuration fields in Pydantic or dataclass-based modules
   - Function signatures (additional parameters, keyword-only arguments)
   - Return types that require more context or domain-specific details

3. **Manual Review (Level 3)**
   - Security issues (hardcoded secrets, SQL injection risks, insufficient cryptography)
   - Performance considerations (profiling, algorithmic complexity changes)
   - Architectural constraints (circular dependencies, layering violations)
   - Complex refactoring (major changes to class hierarchies or module organization)

---

## Decision Matrix

| Issue Type                   | Action             | Example                                                            |
|------------------------------|--------------------|--------------------------------------------------------------------|
| Missing Type Hint (Basic)    | Auto-Fix (L1)      | Insert `-> str` or `-> int` if obvious from context                |
| Missing Docstring            | Auto-Fix (L1)      | Insert a minimal docstring template                                |
| Incorrect Import Path        | Auto-Fix (L1)      | Fix import statement automatically (e.g., `from ... import ...`)   |
| Missing Class Attribute      | Propose Fix (L2)   | Suggest adding a field with appropriate type                       |
| Advanced Generic Types       | Propose Fix (L2)   | Require dev review for complex generics (e.g., `Dict[str, List[int]]`) |
| Security Breach (Hardcoded)  | Manual Review (L3) | Prompt review for secrets in code or suspicious patterns           |
| Architectural Violation      | Manual Review (L3) | Major reorganization of modules or class hierarchies               |

---

## Auto-Fix Examples

### 1. Adding Basic Type Hints
```python
# Before
def load_data(path):
    with open(path, "r") as f:
        return f.read()

# After (Auto-Fix)
def load_data(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()
```

### 2. Generating Minimal Docstrings
```python
# Before
class UserRepository:
    def add_user(self, user):
        pass

# After (Auto-Fix, Google-style docstring)
class UserRepository:
    """
    UserRepository manages user-related data operations.
    """

    def add_user(self, user: "User") -> None:
        """
        Add a user to the repository.

        Args:
            user (User): The user instance to be added.
        """
        pass
```

### 3. Correcting Imports
```python
# Before
def handle_path(p):
    return Path(p)

# After (Auto-Fix)
from pathlib import Path

def handle_path(p: str) -> Path:
    return Path(p)
```

---

## Implementation Guidelines

1. **Centralized Tool Configuration**

   In your `pyproject.toml`

2. **Docstring Style**

   - Use **Google-style** or **reStructuredText** consistently.
   - Always include a brief class-level docstring explaining the class purpose.
   - Function-level docstrings should clarify arguments, return values, and exceptions raised.

3. **Import Sorting**

   - Separate imports into blocks: standard library, third-party packages, local modules.
   - Maintain alphabetical order within each block.

4. **Handling Type Hints**

   - Provide type hints for all function parameters and return types (where feasible).
   - Use standard collection types from the `typing` module (`List`, `Dict`, `Optional`, etc.).
   - For Python 3.9+ projects, consider new annotations (`list[str]`, `dict[str, int]`) if permitted.

5. **Error Handling**

   - Favor Pythonic exception handling rather than explicit checks for every possible error condition.
   - Raise custom exceptions or built-in ones where appropriate (e.g., `ValueError`, `TypeError`).

---

## Automation Rules

1. **Always Auto-Fix (Level 1)**
   - Code formatting with Black
   - Import sorting with isort
   - Removing unused imports (autoflake or ruff)
   - Adding or correcting obvious type hints (`-> None`, simple parameter types)
   - Inserting minimal docstrings if completely missing
   - Simple variable naming adjustments (PEP 8 compliance)

2. **Propose and Apply if Approved (Level 2)**
   - Class attributes (especially if incomplete or partially untyped)
   - More complex type annotations (generics, unions, protocols)
   - Additional function parameters that require domain knowledge
   - Missing configuration fields in Pydantic or dataclass-based models

3. **Manual Review (Level 3)**
   - Security or cryptographic concerns (hardcoded tokens, insecure usage of libraries)
   - Performance optimizations (profiling required, possible algorithmic changes)
   - Architectural improvements (module reorganization, major refactoring)
   - Dependencies with potential licensing or version conflicts

---

## Fix Verification

1. **Pre-Fix Checks**
   - Run existing tests (unit, integration) to confirm the current behavior.
   - Check for type consistency with Mypy or Pyright.
   - Validate code style with `ruff`, `black`, and `isort` to identify the needed fixes.

2. **Post-Fix Validation**
   - Re-run tests to confirm no regressions were introduced.
   - Verify that new or updated type hints pass Mypy checks.
   - Ensure no new linter or style issues have emerged.
   - If changes are significant (Level 3), perform code reviews or manual QA.

---

## Example Workflow
```python
from pathlib import Path
from pepperpy.tools.linting import LintManager

async def handle_lint_issues(file: Path) -> None:
    """
    Handle linting issues on the given file by applying or proposing fixes
    according to our priority levels.
    """
    manager = LintManager(file)
    
    # Step 1: Identify issues
    issues = await manager.check()
    
    # Step 2: Address issues based on severity level
    for issue in issues:
        if issue.level == 1:
            # Auto-fix straightforward issues
            await manager.auto_fix(issue)
        elif issue.level == 2:
            # Generate fix proposals and apply if safe
            fix = await manager.generate_fix(issue)
            if fix.is_safe():
                await manager.apply_fix(fix)
        else:
            # Level 3: Log for manual review (security, performance, architecture)
            await manager.log_for_review(issue)

    # Step 3: Validate changes
    await manager.validate_final_state()
```

---
title: Module Abstraction and Dependency Inversion
description: USE WHEN implementing or using modules in the PepperPy framework to ensure proper abstraction and dependency management
globs: pepperpy/**/*.py
priority: 900
---

# Module Abstraction and Dependency Inversion

## Overview

This rule defines the module abstraction patterns and dependency inversion principles for the PepperPy framework, ensuring proper dependency management and clean API surfaces.

## Module Encapsulation

### Public Module Interface

Each module should expose a clean, well-defined interface through its `__init__.py` file:

```python
# pepperpy/module_name/__init__.py
"""Module documentation."""

# Import public interfaces from internal modules
from .base import BaseInterface, create_module

# Re-export provider implementations as needed
from .providers import MainProvider, SecondaryProvider

# Define exactly what is publicly available
__all__ = [
    "BaseInterface",
    "create_module",
    "MainProvider",
    "SecondaryProvider",
]
```

### External Code MUST Import Only From Public API

External code should NEVER import directly from internal module structure:

```python
# CORRECT
from pepperpy.llm import LLMProvider, create_provider

# WRONG - Violates module encapsulation
from pepperpy.llm.base import LLMProvider  # VIOLATION!
from pepperpy.llm.providers.openai import OpenAIProvider  # VIOLATION!
```

### Internal Implementation Details

Internal module files should use relative imports:

```python
# Within providers/some_provider.py
from ..base import BaseProvider  # Correct relative import
```

## Provider Abstraction

### Base Provider Interface

```python
# In base.py
class BaseProvider(Protocol):
    """Provider interface."""
    
    async def initialize(self) -> None:
        """Initialize the provider."""
        pass
        
    async def process(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """Process input data."""
        pass
```

### Factory Function

Each module must include a factory function that creates providers:

```python
# In base.py, but exposed through __init__.py
def create_provider(provider_type: str, **config: Any) -> BaseProvider:
    """Create a provider based on type."""
    if provider_type == "main":
        from .providers.main import MainProvider
        return MainProvider(**config)
    elif provider_type == "secondary":
        from .providers.secondary import SecondaryProvider
        return SecondaryProvider(**config)
    else:
        raise ValueError(f"Unknown provider type: {provider_type}")
```

## Dependency Inversion

### High-Level Modules Depend on Abstractions

```python
# CORRECT
from pepperpy.storage import StorageProvider

class DocumentProcessor:
    def __init__(self, storage: StorageProvider):
        self.storage = storage
        
# WRONG
from pepperpy.storage.providers.file import FileStorage

class DocumentProcessor:  # VIOLATION! Depends on concrete implementation
    def __init__(self, storage: FileStorage):
        self.storage = storage
```

### Provider Registration

Providers should be registered using the lazy provider decorator:

```python
from pepperpy.core.utils import lazy_provider_class

@lazy_provider_class("module_name", "provider_type")
class MyProvider(BaseProvider):
    """My provider implementation."""
    pass
```

## Abstraction Layers

Each module should maintain these distinct layers:

1. **Public Interface** (`__init__.py`): What users import
2. **Abstract Base** (`base.py`): Interfaces and factory functions
3. **Provider Implementations** (`providers/*.py`): Concrete implementations

## Auto-configuração e Gerenciamento de Recursos

Os módulos do PepperPy devem gerenciar suas próprias configurações e recursos de maneira inteligente, minimizando a necessidade de configuração explícita pelo usuário.

### Auto-configuração via Variáveis de Ambiente

Os providers devem se auto-configurar com base em variáveis de ambiente:

```python
# CORRETO - Auto-configuração via variáveis de ambiente
def __init__(self, api_key: Optional[str] = None, **kwargs):
    # Buscar da variável de ambiente se não fornecida
    self.api_key = api_key or os.getenv("PEPPERPY_LLM__OPENAI__API_KEY")
    if not self.api_key:
        raise ConfigError("API key não fornecida via parâmetro ou variável de ambiente")
```

### Gerenciamento Automático de I/O

Os providers devem gerenciar seus próprios recursos de I/O:

```python
# CORRETO - Gerenciamento automático de diretórios
def __init__(self, persist_directory: Optional[str] = None, **kwargs):
    # Usar diretório padrão se não especificado
    self.persist_directory = persist_directory or os.getenv(
        "PEPPERPY_RAG__CHROMA__PERSIST_DIRECTORY", 
        os.path.join(os.path.expanduser("~"), ".pepperpy/chroma")
    )
    # Criar diretório se não existir
    os.makedirs(self.persist_directory, exist_ok=True)
```

### Gerenciamento de Logging Interno

Os módulos devem gerenciar seu próprio logging:

```python
# CORRETO - Gerenciamento interno de logging
import logging

# Configurar logger no módulo, não expondo ao usuário
logger = logging.getLogger("pepperpy.llm.openai")

class OpenAIProvider:
    def generate(self, messages):
        try:
            # Operação
            logger.debug("Enviando requisição para OpenAI")
            # ...
        except Exception as e:
            logger.error(f"Erro na geração: {e}")
            raise
```

### Anti-padrões a Evitar

❌ **Exigir Configuração Explícita**:
```python
# ERRADO - Exigir configuração explícita
def __init__(self, api_key: str):
    # Exige que o usuário forneça a chave explicitamente
    self.api_key = api_key
```

❌ **Forçar Gestão de I/O Externa**:
```python
# ERRADO - Forçar o usuário a gerenciar diretórios
def __init__(self, persist_directory: str):
    # Se o diretório não existir, falha
    if not os.path.exists(persist_directory):
        raise ValueError(f"O diretório {persist_directory} não existe")
    self.persist_directory = persist_directory
```

### Lista de Implementação

- [ ] Providers tentam obter configuração de variáveis de ambiente
- [ ] Variáveis de ambiente seguem o padrão PEPPERPY_MODULE__PROVIDER__CONFIG
- [ ] Providers gerenciam criação de diretórios automaticamente
- [ ] Logging é gerenciado internamente
- [ ] Classes de erro específicas para falhas de configuração

## Practical Examples

### Module Usage (External to the Module)

```python
# CORRECT usage pattern
from pepperpy.llm import LLMProvider, create_provider

# Create a provider instance
provider = create_provider("openai", api_key="sk-...")

# Use the provider through its abstract interface
result = await provider.generate("Hello, world")
```

### Module Implementation (Internal)

```python
# Inside pepperpy/llm/providers/specific.py
from ..base import LLMProvider

class SpecificProvider(LLMProvider):
    """Provider-specific implementation."""
    
    async def initialize(self) -> None:
        # Implementation
        
    async def generate(self, prompt: str) -> str:
        # Implementation
```

## Anti-patterns to Avoid

### ❌ Direct Import of Internal Module Structure

```python
# WRONG - Importing directly from internal structure
from pepperpy.llm.base import LLMProvider
from pepperpy.llm.providers.openai import OpenAIProvider
```

### ❌ Bypassing the Factory Function

```python
# WRONG - Creating provider directly
from pepperpy.llm.providers.openai import OpenAIProvider
provider = OpenAIProvider(api_key="sk-...")
```

### ❌ Leaking Implementation Details

```python
# WRONG - __init__.py exposes implementation details
from .internal_module import _InternalClass
from .providers.implementation import _helper_function

# These should not be exposed
__all__ = [..., "_InternalClass", "_helper_function"]
```

### ❌ Exigindo Configuração Manual de Recursos

```python
# ERRADO - Provider requer que o usuário gerencie diretórios
class BadChromaProvider(RAGProvider):
    def __init__(self, persist_directory: str, **kwargs):
        # Exige que o usuário crie o diretório de antemão
        if not os.path.exists(persist_directory):
            raise ValueError("Directory must exist before initialization")
        self._directory = persist_directory
```

### ❌ Configuração Manual de Credenciais

```python
# ERRADO - Exigir chave de API diretamente sem fallback
class BadProvider(BaseProvider):
    def __init__(self, api_key: str, **kwargs):
        # Não tenta obter credenciais do ambiente
        self._api_key = api_key
        # Se api_key não for fornecido, falhará
```

## Implementation Checklist

When implementing a new module:

- [ ] Define clear interfaces in `base.py`
- [ ] Export public interfaces in `__init__.py`
- [ ] Create a `create_provider` factory function
- [ ] Implement provider classes in the `providers/` directory
- [ ] Use dependency injection with abstract interfaces
- [ ] Register providers with `lazy_provider_class` decorator
- [ ] Auto-configurar via variáveis de ambiente
- [ ] Auto-gerenciar recursos de IO/diretórios
- [ ] Configurar logging interno adequado

## Critical Update: Provider Registration Pattern

Each module's `__init__.py` MUST follow this pattern for lazy loading:

```python
"""Module provider implementations."""

PROVIDER_MODULES = {
    "provider1": "pepperpy.module.providers.provider1.Provider1",
    "provider2": "pepperpy.module.providers.provider2.Provider2",
}

__all__ = list(PROVIDER_MODULES.keys())
```

❌ NEVER import providers directly in `__init__.py`:
```python
# WRONG - Eager loading causes dependency issues
from .provider1 import Provider1  # VIOLATION!
from .provider2 import Provider2  # VIOLATION!
```

✅ ALWAYS use lazy loading in factory functions:
```python
def create_provider(provider_type: str, **config: Any) -> BaseProvider:
    """Create a provider based on type."""
    try:
        from .providers import PROVIDER_MODULES
        
        if provider_type not in PROVIDER_MODULES:
            raise ValidationError(f"Unknown provider: {provider_type}")
            
        module_path = PROVIDER_MODULES[provider_type]
        module_name, class_name = module_path.rsplit(".", 1)
        
        try:
            import importlib
            module = importlib.import_module(module_name)
            provider_class = getattr(module, class_name)
        except ImportError as e:
            raise ValidationError(
                f"Failed to import provider '{provider_type}'. "
                f"Make sure you have installed the required dependencies: {e}"
            )
            
        return provider_class(**config)
    except Exception as e:
        raise ValidationError(f"Failed to create provider: {e}")
```

## Provider Implementation Requirements

Each provider MUST:

1. Use the `@lazy_provider_class` decorator:
```python
@lazy_provider_class("module_name", "provider_type")
class MyProvider(BaseProvider):
    pass
```

2. Handle missing dependencies gracefully:
```python
def __init__(self, **kwargs):
    try:
        import some_package
    except ImportError:
        raise ValidationError(
            "This provider requires some_package. "
            "Install with: pip install some_package"
        )
    super().__init__(**kwargs)
```

3. Use environment variables for configuration:
```python
def _get_api_key(self) -> str:
    import os
    
    api_key = os.environ.get("PEPPERPY_MODULE__PROVIDER__API_KEY")
    if not api_key:
        raise ConfigError(
            "API key not found. Set PEPPERPY_MODULE__PROVIDER__API_KEY "
            "or pass api_key to constructor."
        )
    return api_key
```

## Provider Checklist

For each provider, verify:

- [ ] No imports in module's `__init__.py`
- [ ] Uses `PROVIDER_MODULES` for registration
- [ ] Decorated with `@lazy_provider_class`
- [ ] Handles missing dependencies with clear messages
- [ ] Uses environment variables for config
- [ ] Follows naming conventions
- [ ] Properly implements cleanup

## Centralized Error Handling and Logging

## Overview

PepperPy adota um padrão de centralização do tratamento de erros e logs, removendo essa responsabilidade dos plugins individuais. Este documento define como isso funciona e como implementar novos providers seguindo esse padrão.

## Princípios

1. **Separação de Responsabilidades**: Plugins devem se concentrar apenas na lógica de negócio
2. **Centralização de Logs**: O framework gerencia todos os logs
3. **Tratamento de Erros Uniforme**: Erros são tratados e mapeados pela biblioteca principal
4. **Ciclo de Vida Gerenciado**: Inicialização e limpeza são manejados automaticamente

## Implementação

### 1. Decorador de Método

A biblioteca principal implementa um decorador que gerencia o ciclo de vida e tratamento de erros:

```python
def _handle_provider_method(method_name: str) -> Callable:
    """Decorator to handle provider method lifecycle and errors."""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def wrapper(self, *args, **kwargs):
            try:
                # Auto-initializes if needed
                if not self.initialized:
                    logger.debug(f"Auto-initializing provider...")
                    await self.initialize()
                
                # Runs the actual method
                result = await func(self, *args, **kwargs)
                return result
                
            except Exception as e:
                # Logs and maps errors
                logger.error(f"Provider method failed: {e}")
                if not isinstance(e, ProviderError):
                    raise ProviderError(f"Operation failed: {e}") from e
                raise
                
        return wrapper
    return decorator
```

### 2. Plugin Simplificado

Os plugins não precisam mais gerenciar:
- Logs de erro
- Tratamento de exceções 
- Conversão de erros
- Inicialização em cada método

## Padrão de Implementação

### ✅ Plugin Sem Gestão de Erros

```python
# CORRETO - Plugin sem gerenciamento de erros
class MyProvider(DomainProvider, ProviderPlugin):
    async def initialize(self) -> None:
        """Inicializa o provedor."""
        if self.initialized:
            return
            
        api_key = self._config.get("api_key")
        if not api_key:
            raise ConfigError("API key não fornecida")
        
        # Inicializa o client
        self.client = SomeClient(api_key=api_key)
        self.initialized = True
        
    async def generate(self, input_text: str, **kwargs: Any) -> str:
        """Gera texto usando o provider."""
        # Decorador já garante a inicialização e tratamento de erros
        if not self.client:
            raise ConfigError("Cliente não inicializado")
            
        # Parâmetros opcionais
        temperature = kwargs.get(
            "temperature", 
            self._config.get("temperature", 0.7)
        )
        
        # Chamada à API - exceções serão tratadas pelo decorador
        response = await self.client.generate(
            input_text, 
            temperature=temperature
        )
        
        return response.text
```

### ❌ ANTI-PADRÃO: Gestão Manual de Erros

```python
# ERRADO - Gerenciamento manual de erros
class MyProvider(DomainProvider, ProviderPlugin):
    async def generate(self, input_text: str, **kwargs: Any) -> str:
        """Gera texto usando o provider."""
        try:
            await self.initialize()  # VIOLAÇÃO! Decorador já faz isso
            
            if not self.client:
                self.logger.error("Cliente não inicializado")  # VIOLAÇÃO! Logging centralizado
                raise ProviderError("Cliente não inicializado")
                
            # Chamada à API
            response = await self.client.generate(input_text)
            return response.text
            
        except Exception as e:
            self.logger.error(f"Falha na geração: {e}")  # VIOLAÇÃO! Logging centralizado
            raise ProviderError(f"Falha na geração: {e}") from e  # VIOLAÇÃO! Conversão já feita pelo decorador
```

## Tratamento de Configuração

### ✅ Validação Simples 

```python
# CORRETO - Validação simples
async def initialize(self) -> None:
    if self.initialized:
        return
        
    # Verifica apenas o necessário e usa ConfigError
    api_key = self._config.get("api_key")
    if not api_key:
        raise ConfigError("API key não fornecida")
        
    # Inicializa resources
    self.client = SomeClient(api_key=api_key)
    self.initialized = True
```

### ✅ Parâmetros Com Precedência

```python
# CORRETO - Parâmetros com precedência
async def generate(self, input_text: str, **kwargs: Any) -> str:
    # Ordem de precedência:
    # 1. Parâmetro do método
    # 2. Configuração
    # 3. Valor padrão
    temperature = kwargs.get(
        "temperature", 
        self._config.get("temperature", 0.7)
    )
    
    # Uso do parâmetro
    response = await self.client.generate(
        input_text, 
        temperature=temperature
    )
    
    return response.text
```

## Conclusão

Seguindo este padrão, os plugins ficam mais:
- **Simples**: Sem lógica de tratamento de erros
- **Focados**: Apenas lógica de negócio  
- **Leves**: Sem duplicação de código de gerenciamento
- **Consistentes**: Tratamento de erros uniforme

Este padrão permite que a biblioteca principal:
- Forneça logs consistentes
- Garanta tratamento adequado de erros
- Gerencie corretamente o ciclo de vida
- Automatize a inicialização e limpeza 

## Tipagem e Validação de Configuração

Os módulos do PepperPy incluem métodos helpers para obter e validar configurações com tipagem adequada:

### ✅ Métodos de Configuração Tipados

O `BaseProvider` fornece métodos auxiliares para obter valores tipados da configuração:

```python
# Obter string com valor padrão
api_key = self.get_str("api_key", "default-key")

# Obter float com validação automática
temperature = self.get_float("temperature", 0.7)  # Lança ConfigError se não for conversível

# Obter int com validação automática  
max_tokens = self.get_int("max_tokens", 1024)  # Lança ConfigError se não for conversível

# Obter boolean com conversão inteligente
streaming = self.get_bool("streaming", False)  # Aceita "true", "yes", "1", etc.
```

### ✅ Configuração com Metadados

A configuração pode ser definida no arquivo de metadados `plugin.yaml`:

```yaml
# Default configuration values
default_config:
  model: "gpt-3.5-turbo"
  temperature: 0.7
  max_tokens: 1024
```

E acessada com o método que incorpora valor padrão do metadata:

```python
# Ordem de precedência:
# 1. self._config (maior prioridade)
# 2. metadata.default_config
# 3. default parameter (menor prioridade)
model = self.get_config_with_defaults("model", "fallback-model")
```

Este padrão:
- Reduz código boilerplate
- Garante validação consistente
- Fornece valores padrão sensatos 

## Validação Automática da Configuração

O PepperPy agora usa validação automática de configuração baseada no schema definido no `plugin.yaml`:

### ✅ Schema de Configuração no YAML

```yaml
# Configuração de campos obrigatórios
required_config_keys:
  - "api_key"

# Definição de valores padrão
default_config:
  model: "gpt-3.5-turbo"
  temperature: 0.7
  max_tokens: 1024

# Schema completo com validação
config_schema:
  api_key:
    description: "OpenAI API key"
    required: true
    env_var: "OPENAI_API_KEY"
    type: "string"
  temperature:
    description: "Sampling temperature"
    required: false
    default: 0.7
    type: "float"
    min: 0.0
    max: 2.0
  max_tokens:
    type: "integer"
    min: 1
```

### ✅ Validação Automática

```python
# Antes - O plugin precisava fazer isso:
def initialize(self) -> None:
    # Validar parâmetros obrigatórios
    api_key = self._config.get("api_key")
    if not api_key:
        raise ConfigError("API key não fornecida")
    
    # Validar tipos
    temp_str = self._config.get("temperature")
    try:
        self.temperature = float(temp_str) if temp_str else 0.7
    except ValueError:
        raise ConfigError("temperature deve ser um número")
    
    # Validar intervalos
    if self.temperature < 0 or self.temperature > 2:
        raise ConfigError("temperature deve estar entre 0 e 2")
    
    # Inicializar
    self.client = SomeClient(api_key=api_key)
    self.initialized = True
```

```python
# Agora - O plugin é puro negócio:
def initialize(self) -> None:
    # A validação de configuração é automática
    # O decorador _handle_provider_method faz isso antes de chamar initialize()
    api_key = self.get_config_with_defaults("api_key")
    self.client = SomeClient(api_key=api_key)
    self.initialized = True
```

### ✅ Gerenciamento Automático do Estado

```python
# Antes - O plugin precisava gerenciar isso:
async def generate(self, input: str) -> str:
    if not self.initialized:
        await self.initialize()
    if not self.client:
        raise ConfigError("Client não inicializado")
    
    # Lógica de negócio
    return await self.client.generate(input)
```

```python
# Agora - O plugin só precisa da lógica de negócio:
async def generate(self, input: str) -> str:
    # Decorador _handle_provider_method garante que:
    # 1. Validação de schema foi executada
    # 2. Método initialize() foi chamado se necessário
    # 3. Estado de inicialização está consistente
    return await self.client.generate(input)
```

Esta abordagem:
- **Reduz drasticamente** o código de cada plugin
- **Centraliza** validação e mensagens de erro
- **Padroniza** comportamento entre providers
- **Separa** metadados (YAML) da implementação (Python) 

## Auto-Binding de Atributos nos Plugins

PepperPy agora suporta auto-binding de atributos baseado no schema de configuração do `plugin.yaml`:

### Auto-Binding in plugin.yaml

Define all configuration in the `plugin.yaml` file:

```yaml
# Configuration schema with validation
config_schema:
  model:
    description: "Model to use"
    type: "string"
    default: "gpt-3.5-turbo"
  temperature:
    description: "Sampling temperature"
    type: "float"
    default: 0.7
    min: 0.0
    max: 2.0
  max_tokens:
    description: "Max tokens to generate"
    type: "integer"
    default: 1024
    min: 1
```

### Accessing Auto-Bound Attributes

The attributes defined in the schema are automatically bound to the provider instance:

```python
# CORRECT - Using auto-bound attributes
async def generate(self, messages, **kwargs):
    # Attributes are automatically bound from plugin.yaml and config
    # No need to manually retrieve from self._config
    
    # Override with kwargs if provided
    temperature = kwargs.get("temperature", self.temperature)
    model = kwargs.get("model", self.model)
    
    # Use the attributes directly
    response = await self.client.generate(
        messages, 
        temperature=temperature,
        model=model,
    )
    
    return response
```

### Updating Configuration

When you update the configuration, the attributes are automatically rebound:

```python
# Configuration update automatically rebinds attributes
provider.update_config(temperature=0.9)
# Now provider.temperature == 0.9
```

### ❌ Anti-patterns

```python
# WRONG - Manual attribute mapping
def __init__(self, **kwargs):
    super().__init__(**kwargs)
    
    # DON'T DO THIS - Will be overwritten by auto-binding
    self.temperature = self._config.get("temperature", 0.7)
    self.model = self._config.get("model", "gpt-3.5-turbo")
```

```python
# WRONG - Accessing config directly for attributes that should be auto-bound
async def generate(self, messages, **kwargs):
    # DON'T DO THIS - Use auto-bound attributes instead
    temperature = kwargs.get("temperature", self._config.get("temperature", 0.7))
    model = kwargs.get("model", self._config.get("model", "gpt-3.5-turbo"))
```

### Implementation

The auto-binding system:

1. Reads the `config_schema` from the plugin.yaml file
2. Creates instance attributes for each configuration key
3. Handles type conversion based on the schema
4. Rebinds attributes when `update_config()` is called
5. Maintains a set of auto-bound attributes to avoid conflicts

This approach ensures:
- Single source of truth for configuration (plugin.yaml)
- Consistent access patterns
- Type safety for configuration values
- Elimination of boilerplate code

## Provider Lifecycle Management

The PepperPy framework now centrally manages the provider lifecycle:

```python
# Library is responsible for managing the lifecycle flag
async def cleanup(self) -> None:
    """Clean up provider resources."""
    self.client = None
    # DON'T DO THIS - Library manages initialization state
    # self.initialized = False
```

The framework will:
1. Set `initialized = True` when initialization is complete
2. Set `initialized = False` after cleanup
3. Automatically re-initialize when needed

## Automatic Configuration Binding

To prevent duplication of code and make the configuration handling more consistent, PepperPy now supports automatic binding of configuration values to provider instance attributes.

### Auto-Binding in plugin.yaml

Define all configuration in the `plugin.yaml` file:

```yaml
# Configuration schema with validation
config_schema:
  model:
    description: "Model to use"
    type: "string"
    default: "gpt-3.5-turbo"
  temperature:
    description: "Sampling temperature"
    type: "float"
    default: 0.7
    min: 0.0
    max: 2.0
  max_tokens:
    description: "Max tokens to generate"
    type: "integer"
    default: 1024
    min: 1
```

### Accessing Auto-Bound Attributes

The attributes defined in the schema are automatically bound to the provider instance:

```python
# CORRECT - Using auto-bound attributes
async def generate(self, messages, **kwargs):
    # Attributes are automatically bound from plugin.yaml and config
    # No need to manually retrieve from self._config
    
    # Override with kwargs if provided
    temperature = kwargs.get("temperature", self.temperature)
    model = kwargs.get("model", self.model)
    
    # Use the attributes directly
    response = await self.client.generate(
        messages, 
        temperature=temperature,
        model=model,
    )
    
    return response
```

### Updating Configuration

When you update the configuration, the attributes are automatically rebound:

```python
# Configuration update automatically rebinds attributes
provider.update_config(temperature=0.9)
# Now provider.temperature == 0.9
```

### ❌ Anti-patterns

```python
# WRONG - Manual attribute mapping
def __init__(self, **kwargs):
    super().__init__(**kwargs)
    
    # DON'T DO THIS - Will be overwritten by auto-binding
    self.temperature = self._config.get("temperature", 0.7)
    self.model = self._config.get("model", "gpt-3.5-turbo")
```

```python
# WRONG - Accessing config directly for attributes that should be auto-bound
async def generate(self, messages, **kwargs):
    # DON'T DO THIS - Use auto-bound attributes instead
    temperature = kwargs.get("temperature", self._config.get("temperature", 0.7))
    model = kwargs.get("model", self._config.get("model", "gpt-3.5-turbo"))
```

### Implementation

The auto-binding system:

1. Reads the `config_schema` from the plugin.yaml file
2. Creates instance attributes for each configuration key
3. Handles type conversion based on the schema
4. Rebinds attributes when `update_config()` is called
5. Maintains a set of auto-bound attributes to avoid conflicts

This approach ensures:
- Single source of truth for configuration (plugin.yaml)
- Consistent access patterns
- Type safety for configuration values
- Elimination of boilerplate code

## Provider Lifecycle Management

The PepperPy framework now centrally manages the provider lifecycle:

```python
# Library is responsible for managing the lifecycle flag
async def cleanup(self) -> None:
    """Clean up provider resources."""
    self.client = None
    # DON'T DO THIS - Library manages initialization state
    # self.initialized = False
```

The framework will:
1. Set `initialized = True` when initialization is complete
2. Set `initialized = False` after cleanup
3. Automatically re-initialize when needed

## Auto-Binding de Atributos nos Plugins

PepperPy agora suporta auto-binding de atributos baseado no schema de configuração do `plugin.yaml`:

### Auto-Binding in plugin.yaml

Define all configuration in the `plugin.yaml` file:

```yaml
# O plugin define todos os atributos e defaults no YAML
config_schema:
  model:
    description: "Model to use"
    type: "string"
    default: "gpt-3.5-turbo"
  temperature:
    description: "Sampling temperature"
    type: "float"
    default: 0.7
    min: 0.0
    max: 2.0
  max_tokens:
    description: "Max tokens to generate"
    type: "integer"
    default: 1024
    min: 1
```

### Atributos Auto-Gerados

```python
# ANTES - Plugin tinha que definir e inicializar manualmente os atributos
def __init__(self, **kwargs):
    super().__init__(**kwargs)
    
    # Inicialização manual de cada atributo
    self.model = self._config.get("model", "gpt-3.5-turbo")
    
    # Conversão manual de tipos
    temp_str = self._config.get("temperature")
    self.temperature = float(temp_str) if temp_str else 0.7
    
    max_tokens_str = self._config.get("max_tokens")
    self.max_tokens = int(max_tokens_str) if max_tokens_str else 1024
```

```python
# AGORA - Atributos são criados automaticamente baseados no plugin.yaml
def __init__(self, **kwargs):
    super().__init__(**kwargs)
    # Plugin não precisa fazer nada - auto_bind_config_attributes é chamado
    # automaticamente e cria os atributos self.model, self.temperature, self.max_tokens
    # com os valores definidos no config e convertidos para os tipos corretos
```

### Vantagens do Auto-Binding

1. **Sem Duplicação de Código**:
   - Valores padrão só precisam ser definidos em um lugar (plugin.yaml)
   - Sem código repetitivo para inicialização de atributos

2. **Tipagem Automática**:
   - Conversão de tipos feita automaticamente
   - Validação de intervalos conforme definido no schema

3. **Configuração Centralizada**:
   - Plugin.yaml serve como única fonte da verdade
   - Documentação e code auto-gerado em sincronia

4. **Atualizações Dinâmicas**:
   - Quando `update_config()` é chamado, os atributos são atualizados automaticamente
   - Valores atualizados e tipos validados 
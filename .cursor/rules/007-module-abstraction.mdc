---
title: Module Abstraction and Dependency Inversion
description: USE WHEN implementing or using modules in the PepperPy framework to ensure proper abstraction and dependency management
globs: pepperpy/**/*.py
priority: 900
---

# Module Abstraction and Dependency Inversion

## Overview

This rule defines the module abstraction patterns and dependency inversion principles for the PepperPy framework, ensuring proper dependency management and clean API surfaces.

## Module Encapsulation

### Public Module Interface

Each module should expose a clean, well-defined interface through its `__init__.py` file:

```python
# pepperpy/module_name/__init__.py
"""Module documentation."""

# Import public interfaces from internal modules
from .base import BaseInterface, create_module

# Re-export provider implementations as needed
from .providers import MainProvider, SecondaryProvider

# Define exactly what is publicly available
__all__ = [
    "BaseInterface",
    "create_module",
    "MainProvider",
    "SecondaryProvider",
]
```

### External Code MUST Import Only From Public API

External code should NEVER import directly from internal module structure:

```python
# CORRECT
from pepperpy.llm import LLMProvider, create_provider

# WRONG - Violates module encapsulation
from pepperpy.llm.base import LLMProvider  # VIOLATION!
from pepperpy.llm.providers.openai import OpenAIProvider  # VIOLATION!
```

### Internal Implementation Details

Internal module files should use relative imports:

```python
# Within providers/some_provider.py
from ..base import BaseProvider  # Correct relative import
```

## Provider Abstraction

### Base Provider Interface

```python
# In base.py
class BaseProvider(Protocol):
    """Provider interface."""
    
    async def initialize(self) -> None:
        """Initialize the provider."""
        pass
        
    async def process(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """Process input data."""
        pass
```

### Factory Function

Each module must include a factory function that creates providers:

```python
# In base.py, but exposed through __init__.py
def create_provider(provider_type: str, **config: Any) -> BaseProvider:
    """Create a provider based on type."""
    if provider_type == "main":
        from .providers.main import MainProvider
        return MainProvider(**config)
    elif provider_type == "secondary":
        from .providers.secondary import SecondaryProvider
        return SecondaryProvider(**config)
    else:
        raise ValueError(f"Unknown provider type: {provider_type}")
```

## Dependency Inversion

### High-Level Modules Depend on Abstractions

```python
# CORRECT
from pepperpy.storage import StorageProvider

class DocumentProcessor:
    def __init__(self, storage: StorageProvider):
        self.storage = storage
        
# WRONG
from pepperpy.storage.providers.file import FileStorage

class DocumentProcessor:  # VIOLATION! Depends on concrete implementation
    def __init__(self, storage: FileStorage):
        self.storage = storage
```

### Provider Registration

Providers should be registered using the lazy provider decorator:

```python
from pepperpy.core.utils import lazy_provider_class

@lazy_provider_class("module_name", "provider_type")
class MyProvider(BaseProvider):
    """My provider implementation."""
    pass
```

## Abstraction Layers

Each module should maintain these distinct layers:

1. **Public Interface** (`__init__.py`): What users import
2. **Abstract Base** (`base.py`): Interfaces and factory functions
3. **Provider Implementations** (`providers/*.py`): Concrete implementations

## Auto-configuração e Gerenciamento de Recursos

### Auto-configuração via Ambiente

Os providers e componentes DEVEM se auto-configurar com base em variáveis de ambiente:

```python
# CORRETO - Provider se auto-configura
class OpenAIProvider(LLMProvider):
    def __init__(self, api_key: Optional[str] = None, **kwargs):
        self._api_key = api_key or self._get_from_env()

    def _get_from_env(self) -> str:
        key = os.getenv("PEPPERPY_LLM__OPENAI__API_KEY")
        if not key:
            raise ValueError("API key not found in environment")
        return key
```

### Gerenciamento Automático de IO

Módulos DEVEM gerenciar seus próprios recursos de IO:

```python
# CORRETO - Provider gerencia seus próprios diretórios
class ChromaProvider(RAGProvider):
    def __init__(self, persist_directory: Optional[str] = None, **kwargs):
        # Criar diretório padrão se não for especificado
        self._directory = persist_directory or self._default_directory()
        
        # Garantir que o diretório exista
        os.makedirs(self._directory, exist_ok=True)
        
    def _default_directory(self) -> str:
        # Usar local padrão da aplicação para dados
        app_dir = os.path.join(os.path.expanduser("~"), ".pepperpy")
        return os.path.join(app_dir, "chroma")
```

### Logging Interno

Módulos DEVEM gerenciar seu próprio logging:

```python
# CORRETO - Providers configuram seu próprio logging
class SomeProvider(BaseProvider):
    def __init__(self):
        self._logger = logging.getLogger(__name__)
        
    async def process(self, data):
        self._logger.debug("Processing data: %s", data)
        # processamento
        self._logger.info("Data processed successfully")
```

## Practical Examples

### Module Usage (External to the Module)

```python
# CORRECT usage pattern
from pepperpy.llm import LLMProvider, create_provider

# Create a provider instance
provider = create_provider("openai", api_key="sk-...")

# Use the provider through its abstract interface
result = await provider.generate("Hello, world")
```

### Module Implementation (Internal)

```python
# Inside pepperpy/llm/providers/specific.py
from ..base import LLMProvider

class SpecificProvider(LLMProvider):
    """Provider-specific implementation."""
    
    async def initialize(self) -> None:
        # Implementation
        
    async def generate(self, prompt: str) -> str:
        # Implementation
```

## Anti-patterns to Avoid

### ❌ Direct Import of Internal Module Structure

```python
# WRONG - Importing directly from internal structure
from pepperpy.llm.base import LLMProvider
from pepperpy.llm.providers.openai import OpenAIProvider
```

### ❌ Bypassing the Factory Function

```python
# WRONG - Creating provider directly
from pepperpy.llm.providers.openai import OpenAIProvider
provider = OpenAIProvider(api_key="sk-...")
```

### ❌ Leaking Implementation Details

```python
# WRONG - __init__.py exposes implementation details
from .internal_module import _InternalClass
from .providers.implementation import _helper_function

# These should not be exposed
__all__ = [..., "_InternalClass", "_helper_function"]
```

### ❌ Exigindo Configuração Manual de Recursos

```python
# ERRADO - Provider requer que o usuário gerencie diretórios
class BadChromaProvider(RAGProvider):
    def __init__(self, persist_directory: str, **kwargs):
        # Exige que o usuário crie o diretório de antemão
        if not os.path.exists(persist_directory):
            raise ValueError("Directory must exist before initialization")
        self._directory = persist_directory
```

### ❌ Configuração Manual de Credenciais

```python
# ERRADO - Exigir chave de API diretamente sem fallback
class BadProvider(BaseProvider):
    def __init__(self, api_key: str, **kwargs):
        # Não tenta obter credenciais do ambiente
        self._api_key = api_key
        # Se api_key não for fornecido, falhará
```

## Implementation Checklist

When implementing a new module:

- [ ] Define clear interfaces in `base.py`
- [ ] Export public interfaces in `__init__.py`
- [ ] Create a `create_provider` factory function
- [ ] Implement provider classes in the `providers/` directory
- [ ] Use dependency injection with abstract interfaces
- [ ] Register providers with `lazy_provider_class` decorator
- [ ] Auto-configurar via variáveis de ambiente
- [ ] Auto-gerenciar recursos de IO/diretórios
- [ ] Configurar logging interno adequado

## Conclusion

Following these module abstraction principles ensures that the PepperPy framework maintains a clean, modular structure with proper separation of concerns. By adhering to dependency inversion and proper encapsulation, we create a system that is easier to maintain, extend, and use. 
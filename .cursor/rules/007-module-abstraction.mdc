---
title: Module Abstraction and Organization
description: Core guidelines for implementing and using modules in the PepperPy framework
globs: 
  - "pepperpy/**/*.py"
priority: 700
---

# Module Abstraction and Organization

## Overview

This rule defines the core standards for organizing modules and interfaces in the PepperPy framework, ensuring a clear abstraction between the public API and internal implementations. This is the single source of truth for module structure and organization.

## Module Structure

### Standard Directory Layout

Each module MUST follow this structure:

```
module_name/           # e.g., llm, rag, storage
├── __init__.py       # Public API exports
├── base.py          # Core interfaces, types, and base implementations
├── errors.py        # Domain-specific errors
├── config.py        # Domain configuration
└── providers/       # Provider implementations
    ├── __init__.py  # Provider exports
    └── specific.py  # Specific provider implementation
```

### File Responsibilities

1. **base.py** - Core Module Definition:
   - Interfaces (Protocols/ABC)
   - Base implementations
   - Data types and models
   - Core functionality
   - Type definitions (previously in types.py)

2. **__init__.py** - Public API:
   - Re-export public interfaces
   - Re-export provider implementations
   - Define module-level functions
   - Type exports

3. **errors.py** - Error Definitions:
   - Domain-specific exceptions
   - Error hierarchies
   - Error utilities

4. **config.py** - Configuration:
   - Environment variable definitions
   - Configuration classes
   - Default values

5. **providers/** - Implementations:
   - One file per provider
   - Provider-specific code
   - Follow base interfaces

## Interface Patterns

### 1. Base Module Organization

✅ **Correct**:
```python
# base.py
from typing import Protocol

class LLMError(PepperpyError):
    """Domain-specific errors."""

class Message:
    """Domain data types."""
    role: str
    content: str

class LLMProvider(Protocol):
    """Core provider interface."""
    async def initialize(self) -> None: ...
    async def generate(self, prompt: str) -> str: ...
```

❌ **Incorrect**:
```python
# Scattered across multiple files
# types.py - WRONG: Should be in base.py
class Message: ...

# provider.py - WRONG: Should be in base.py
class LLMProvider: ...

# errors.py - WRONG: Domain errors should be in base.py
class LLMError: ...
```

### 2. Public API Organization

✅ **Correct**:
```python
# __init__.py
from .base import LLMProvider, Message, LLMError
from .providers import OpenRouterProvider

__all__ = [
    "LLMProvider",
    "Message",
    "LLMError",
    "OpenRouterProvider"
]
```

❌ **Incorrect**:
```python
# __init__.py
# Don't expose internal details
from .providers.openrouter import OpenRouterProvider
from .base import _internal_function
```

### 3. Provider Implementation

✅ **Correct**:
```python
# providers/openrouter.py
from typing import Optional
from ..base import LLMProvider, Message, LLMError
from ..config import LLMConfig

class OpenRouterProvider(LLMProvider):
    """OpenRouter implementation."""
    def __init__(self, config: LLMConfig):
        self.config = config
        self._client: Optional[OpenRouterClient] = None

    async def initialize(self) -> None:
        """Initialize provider."""
        self._client = OpenRouterClient(self.config.api_key)

    async def generate(self, prompt: str) -> str:
        if not self._client:
            raise LLMError("Provider not initialized")
        return await self._client.generate(prompt)

    async def cleanup(self) -> None:
        """Cleanup resources."""
        if self._client:
            await self._client.close()
```

❌ **Incorrect**:
```python
# Don't implement in base.py
class OpenRouterProvider(LLMProvider):
    pass

# Don't create new interfaces in providers
class CustomProvider(Protocol):
    pass
```

## Module Usage

### 1. Importing Modules

✅ **Correct**:
```python
# Import from module root
from pepperpy.llm import LLMProvider
from pepperpy.rag import RAGContext

# Use interfaces, not implementations
provider: LLMProvider = ...
```

❌ **Incorrect**:
```python
# Don't import implementations directly
from pepperpy.llm.providers.openrouter import OpenRouterProvider

# Don't import from base
from pepperpy.llm.base import LLMProvider
```

### 2. Configuration

✅ **Correct**:
```python
from pepperpy.core import Config

# Use environment variables
config = Config(env_prefix="PEPPERPY_LLM_")
provider = LLMProvider(config)
```

❌ **Incorrect**:
```python
# Don't hardcode configuration
provider = OpenRouterProvider(
    api_key="sk-...",
    model="gpt-4"
)
```

### 3. Error Handling

✅ **Correct**:
```python
try:
    result = await provider.generate(prompt)
except LLMError as e:
    # Handle domain-specific error
    logger.error(f"LLM error: {e}")
finally:
    await provider.cleanup()
```

❌ **Incorrect**:
```python
# Don't catch generic exceptions
try:
    result = await provider.generate(prompt)
except Exception as e:
    pass
```

## Implementation Examples

### Example: RAG Module

```python
# base.py
from typing import Protocol

class RAGError(PepperpyError): ...

class Document:
    """Document for retrieval."""
    content: str
    metadata: dict

class RAGProvider(Protocol):
    """RAG provider interface."""
    async def add_documents(self, docs: list[Document]) -> None: ...
    async def query(self, text: str) -> list[Document]: ...

# __init__.py
from .base import RAGProvider, Document, RAGError
from .providers import ChromaProvider

__all__ = ["RAGProvider", "Document", "RAGError", "ChromaProvider"]

# providers/chroma.py
from ..base import RAGProvider, Document

class ChromaProvider(RAGProvider):
    """Chroma implementation."""
    async def add_documents(self, docs: list[Document]) -> None:
        # Implementation
        ...
```

## Best Practices

1. **Module Organization**:
   - Keep all core functionality in `base.py`
   - Export public API through `__init__.py`
   - Implement providers in `providers/`
   - Domain errors in `base.py`
   - Configuration in `config.py`

2. **Interface Design**:
   - Use Protocol for interfaces
   - Include domain-specific errors
   - Define clear data types
   - Keep interfaces minimal

3. **Provider Implementation**:
   - Follow interface contracts
   - Handle errors appropriately
   - Clean up resources
   - Keep provider-specific code isolated

4. **Module Usage**:
   - Import from module root
   - Use interfaces in type hints
   - Configure through environment
   - Handle errors properly

## Common Anti-patterns

### 1. Separate Component Files

❌ **NEVER create separate component files**:
```
module/
├── component.py      # WRONG: Should be in base.py
├── types.py         # WRONG: Should be in base.py
└── base.py          # Correct: All core code here
```

✅ **Keep all core code in base.py**:
```
module/
└── base.py          # All core code: components, types, etc.
```

### 2. Provider Implementation Location

❌ **NEVER create provider files outside providers/**:
```
module/
├── azure.py         # WRONG: Should be in providers/azure.py
├── github.py        # WRONG: Should be in providers/github.py
└── providers/       # Correct location for all providers
```

✅ **Always put providers in providers/**:
```
module/
└── providers/
    ├── azure.py     # Correct: Azure implementation
    └── github.py    # Correct: GitHub implementation
```

### 3. Cross-Module Providers

When a provider could belong to multiple modules:

1. Put it in the module where it's most used
2. If equal usage, put it in the more generic module
3. Document the decision in the provider file

Example:
```python
# pepperpy/storage/providers/azure.py
"""Azure Blob Storage provider.

Note: This provider is in storage/ instead of cloud/ because:
1. Primary use is for storage operations
2. Most similar to other storage providers
3. Implements StorageProvider interface
"""

# pepperpy/tts/providers/azure.py
"""Azure TTS provider.

Note: This provider is in tts/ instead of cloud/ because:
1. Primary use is for text-to-speech
2. Most similar to other TTS providers
3. Implements TTSProvider interface
"""
```

## Provider Organization Examples

### Example: TTS Module
```
tts/
├── __init__.py
├── base.py          # TTSProvider interface
├── errors.py
└── providers/
    ├── __init__.py
    ├── azure.py     # Azure TTS implementation
    └── elevenlabs.py
```

### Example: Repository Module
```
repository/
├── __init__.py
├── base.py          # RepositoryProvider interface
├── errors.py
└── providers/
    ├── __init__.py
    ├── github.py    # GitHub implementation
    └── gitlab.py
```

## Conclusion

Following these module abstraction patterns ensures:
1. Clean and consistent APIs
2. Clear separation of concerns
3. Easy provider swapping
4. Proper error handling
5. Resource cleanup
6. Configuration flexibility
7. Maintainable codebase
8. Consistent module structure 
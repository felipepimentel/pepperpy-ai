---
description: USE WHEN refactoring existing code to ensure proper execution of refactoring workflows
globs: 
  - "pepperpy/**/*.py"
  - "plugins/**/*.py"
  - "scripts/**/*.py"
alwaysApply: false
---

# Refactoring Workflow

## Overview

This rule defines the standardized workflow for refactoring existing code in the PepperPy framework. It ensures that refactoring operations maintain framework integrity, enhance code quality, and follow established patterns.

## Pre-Refactoring Analysis

Before ANY refactoring operations, perform these mandatory steps:

### 1. Code Understanding

```bash
# Analyze the code structure to understand
find pepperpy -type f -name "*.py" | grep relevant_pattern
grep -r "class TargetClass" pepperpy/
grep -r "def target_function" pepperpy/
```

### 2. Usage Analysis

```bash
# Find all usages of the target
grep -r "from pepperpy.target import Component" .
grep -r "Component(" .
```

### 3. Test Coverage

```bash
# Check test coverage for affected components
find tests -type f -name "test_*.py" | grep relevant_test
grep -r "test_target" tests/
```

## Refactoring Categories

### 1. Method Extraction

Extract a reusable method from duplicate code:

❌ **BEFORE**:
```python
def process_data(self, data):
    # Validation logic (duplicated)
    if not data:
        raise ValueError("Empty data")
    if not isinstance(data, dict):
        raise ValueError("Expected dict")
    
    # Processing
    result = self._internal_process(data)
    return result
    
def transform_data(self, data):
    # Validation logic (duplicated)
    if not data:
        raise ValueError("Empty data")
    if not isinstance(data, dict):
        raise ValueError("Expected dict")
    
    # Transformation
    transformed = self._internal_transform(data)
    return transformed
```

✅ **AFTER**:
```python
def _validate_data(self, data):
    """Validate input data.
    
    Args:
        data: Input data to validate
        
    Raises:
        ValueError: If validation fails
    """
    if not data:
        raise ValueError("Empty data")
    if not isinstance(data, dict):
        raise ValueError("Expected dict")

def process_data(self, data):
    # Validation
    self._validate_data(data)
    
    # Processing
    result = self._internal_process(data)
    return result
    
def transform_data(self, data):
    # Validation
    self._validate_data(data)
    
    # Transformation
    transformed = self._internal_transform(data)
    return transformed
```

### 2. Class Refactoring

Create a base class for shared functionality:

❌ **BEFORE**:
```python
class Processor1:
    def __init__(self, config):
        self.config = config
        self.logger = get_logger()
        
    def process(self, data):
        # Pre-processing (common)
        data = self._prepare(data)
        # Specific processing
        return self._specific_process(data)
        
    def _prepare(self, data):
        # Common preparation
        return data
        
    def _specific_process(self, data):
        # Specific implementation
        return data

class Processor2:
    def __init__(self, config):
        self.config = config
        self.logger = get_logger()
        
    def process(self, data):
        # Pre-processing (common)
        data = self._prepare(data)
        # Specific processing
        return self._specific_process(data)
        
    def _prepare(self, data):
        # Common preparation (duplicated)
        return data
        
    def _specific_process(self, data):
        # Different specific implementation
        return processed_data
```

✅ **AFTER**:
```python
class BaseProcessor:
    """Base processor with common functionality."""
    
    def __init__(self, config):
        self.config = config
        self.logger = get_logger()
        
    def process(self, data):
        """Process data using template method pattern.
        
        Args:
            data: Input data
            
        Returns:
            Processed data
        """
        # Pre-processing (common)
        data = self._prepare(data)
        # Specific processing (implemented by subclasses)
        return self._specific_process(data)
        
    def _prepare(self, data):
        """Common data preparation.
        
        Args:
            data: Input data
            
        Returns:
            Prepared data
        """
        # Common preparation
        return data
        
    def _specific_process(self, data):
        """Specific processing implementation.
        
        Args:
            data: Prepared data
            
        Returns:
            Processed data
        """
        raise NotImplementedError("Subclasses must implement")

class Processor1(BaseProcessor):
    """Processor implementation 1."""
    
    def _specific_process(self, data):
        """Specific processing for type 1."""
        # Specific implementation
        return data

class Processor2(BaseProcessor):
    """Processor implementation 2."""
    
    def _specific_process(self, data):
        """Specific processing for type 2."""
        # Different specific implementation
        return processed_data
```

### 3. Interface Extraction

Extract an interface from implementation:

❌ **BEFORE**:
```python
class TextProcessor:
    def __init__(self, config):
        self.config = config
        
    def process(self, text):
        # Implementation
        return processed_text
        
    def analyze(self, text):
        # Implementation
        return analysis_result
```

✅ **AFTER**:
```python
from typing import Protocol, Dict, Any

class TextProcessorProtocol(Protocol):
    """Text processor interface."""
    
    def process(self, text: str) -> str:
        """Process text.
        
        Args:
            text: Input text
            
        Returns:
            Processed text
        """
        ...
        
    def analyze(self, text: str) -> Dict[str, Any]:
        """Analyze text.
        
        Args:
            text: Input text
            
        Returns:
            Analysis results
        """
        ...

class TextProcessor:
    """Text processor implementation."""
    
    def __init__(self, config):
        self.config = config
        
    def process(self, text: str) -> str:
        """Process text.
        
        Args:
            text: Input text
            
        Returns:
            Processed text
        """
        # Implementation
        return processed_text
        
    def analyze(self, text: str) -> Dict[str, Any]:
        """Analyze text.
        
        Args:
            text: Input text
            
        Returns:
            Analysis results
        """
        # Implementation
        return analysis_result
```

### 4. Config Refactoring

Refactor configuration handling:

❌ **BEFORE**:
```python
class Processor:
    def __init__(self, **kwargs):
        # Manual config handling
        self.api_key = kwargs.get("api_key", os.environ.get("API_KEY"))
        self.model = kwargs.get("model", "default")
        self.temperature = kwargs.get("temperature", 0.7)
        
        if not self.api_key:
            raise ValueError("API key required")
```

✅ **AFTER**:
```python
from pepperpy.core.config import ConfigMixin

class Processor(ConfigMixin):
    """Processor with proper configuration."""
    
    # Type-annotated config attributes
    api_key: str
    model: str = "default"
    temperature: float = 0.7
    
    def __init__(self, **kwargs):
        """Initialize with configuration.
        
        Args:
            **kwargs: Configuration options
            
        Raises:
            ValueError: If required config is missing
        """
        super().__init__(**kwargs)
        
        # Validation
        if not self.api_key:
            raise ValueError("API key required")
```

### 5. Error Handling Refactoring

Refactor error handling:

❌ **BEFORE**:
```python
def process(self, data):
    try:
        # Validation
        if not data:
            raise ValueError("Empty data")
            
        # Processing
        result = self.client.process(data)
        
        # Checking result
        if not result:
            raise RuntimeError("Processing failed")
            
        return result
    except ValueError as e:
        self.logger.error(f"Validation error: {e}")
        raise
    except ClientError as e:
        self.logger.error(f"Client error: {e}")
        raise RuntimeError(f"Processing error: {e}")
    except Exception as e:
        self.logger.error(f"Unexpected error: {e}")
        raise RuntimeError(f"Unknown error: {e}")
```

✅ **AFTER**:
```python
from pepperpy.core.errors import ValidationError, ProcessingError

def process(self, data):
    """Process data safely.
    
    Args:
        data: Input data
        
    Returns:
        Processed result
        
    Raises:
        ValidationError: If data validation fails
        ProcessingError: If processing fails
    """
    try:
        # Validation
        if not data:
            raise ValidationError("Empty data")
            
        # Processing
        result = self.client.process(data)
        
        # Checking result
        if not result:
            raise ProcessingError("Processing failed")
            
        return result
    except ValidationError:
        # Already domain error, just re-raise
        raise
    except ClientError as e:
        # Convert to domain error
        raise ProcessingError(f"Client error: {e}") from e
    except Exception as e:
        # Unexpected error
        self.logger.error(f"Unexpected error: {e}")
        raise ProcessingError(f"Unexpected error") from e
```

## Refactoring Strategies

### 1. Extract Method Strategy

1. **Identify duplicated code** in multiple methods
2. **Extract to private method** with clear name
3. **Add parameters** for any differences
4. **Add docstring** explaining purpose
5. **Replace duplicates** with method call

```python
# Before
if condition:
    # Complex code block 1
else:
    # Complex code block 2

# After
if condition:
    self._handle_condition_true()
else:
    self._handle_condition_false()
    
def _handle_condition_true(self):
    """Handle the true condition case."""
    # Complex code block 1
    
def _handle_condition_false(self):
    """Handle the false condition case."""
    # Complex code block 2
```

### 2. Pull Up Method Strategy

1. **Identify common methods** in subclasses
2. **Move to parent class** if identical
3. **Create abstract method** in parent if implementation varies
4. **Adjust visibility** if needed

```python
# Before
class Parent:
    def common(self):
        pass

class Child1(Parent):
    def specific(self):
        # Implementation 1

class Child2(Parent):
    def specific(self):
        # Same as Child1

# After
class Parent:
    def common(self):
        pass
        
    def specific(self):
        # Pulled up implementation
```

### 3. Replace Conditional with Polymorphism

1. **Identify conditional logic** that switches on type
2. **Create subclasses** for each case
3. **Move conditional branches** to subclasses
4. **Use factory method** to create correct type

```python
# Before
def process(self, data):
    if data["type"] == "text":
        # Text processing
    elif data["type"] == "image":
        # Image processing
    else:
        # Default processing

# After
class Processor:
    @classmethod
    def create(cls, data):
        processor_type = data["type"]
        if processor_type == "text":
            return TextProcessor(data)
        elif processor_type == "image":
            return ImageProcessor(data)
        else:
            return DefaultProcessor(data)
            
    def process(self):
        raise NotImplementedError()

class TextProcessor(Processor):
    def process(self):
        # Text processing

class ImageProcessor(Processor):
    def process(self):
        # Image processing
```

### 4. Introduce Parameter Object

1. **Identify methods** with many parameters
2. **Create parameter class** to hold related parameters
3. **Replace parameter list** with parameter object
4. **Add validation** in parameter object

```python
# Before
def process(self, api_key, model, temperature, max_tokens, timeout):
    # Implementation

# After
class ProcessingConfig:
    def __init__(self, api_key, model, temperature=0.7, max_tokens=1000, timeout=30):
        self.api_key = api_key
        self.model = model
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.timeout = timeout
        
    def validate(self):
        if not self.api_key:
            raise ValueError("API key required")
        if self.temperature < 0 or self.temperature > 1:
            raise ValueError("Temperature must be between 0 and 1")

def process(self, config: ProcessingConfig):
    config.validate()
    # Implementation
```

## Refactoring Safety Measures

### 1. Pre-Refactoring Verification

```bash
# Run tests before refactoring
pytest tests/path/to/relevant_tests.py -v

# Verify lint status
flake8 pepperpy/path/to/refactor

# Verify type checking
mypy pepperpy/path/to/refactor
```

### 2. Incremental Approach

1. **Make small, focused changes** (one refactoring at a time)
2. **Run tests after each change**
3. **Commit frequently** with descriptive messages

### 3. Post-Refactoring Verification

```bash
# Run tests after refactoring
pytest tests/path/to/relevant_tests.py -v

# Verify no regressions
pytest

# Verify lint status
flake8 pepperpy/path/to/refactor

# Verify type checking
mypy pepperpy/path/to/refactor
```

## Anti-Patterns to Avoid

### 1. Breaking Public APIs

❌ **AVOID**: Changing method signatures of public methods
```python
# WRONG: Breaking API
# Before: def process(self, data, options=None)
# After:  def process(self, data, config) # Breaking change!
```

✅ **CORRECT**: Maintain backward compatibility
```python
# Correct: Backward compatible
def process(self, data, options=None, config=None):
    # Handle both old and new style
    if options is not None and config is None:
        # Convert options to config format
        config = self._create_config(options)
    
    # Use config for processing
```

### 2. Excessive Abstraction

❌ **AVOID**: Creating abstractions prematurely
```python
# WRONG: Excessive abstraction
class RequestProcessorFactoryProvider:
    def get_factory(self):
        return RequestProcessorFactory()

class RequestProcessorFactory:
    def create_processor(self, type):
        return RequestProcessor()

class RequestProcessor:
    def process(self, request):
        # Actual processing
```

✅ **CORRECT**: Appropriate abstraction level
```python
# Correct: Appropriate abstraction
class RequestProcessor:
    @classmethod
    def create(cls, type):
        # Factory method in the class
        return cls()
        
    def process(self, request):
        # Actual processing
```

### 3. Incomplete Refactoring

❌ **AVOID**: Leaving refactoring halfway
```python
# WRONG: Partial refactoring
# Some methods using old pattern:
def old_style_method(self):
    # Old pattern
    
# Some methods using new pattern:
def new_style_method(self):
    # New pattern
```

✅ **CORRECT**: Complete refactoring
```python
# Correct: Consistent pattern
def first_method(self):
    # New pattern
    
def second_method(self):
    # New pattern
```

## Refactoring Examples

### Example 1: Method Extraction

❌ **BEFORE**:
```python
class TextProcessor:
    def process_document(self, document):
        # Extract text
        raw_text = document.get_text()
        
        # Normalize
        text = raw_text.lower()
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # Remove special chars
        text = re.sub(r'[^\w\s]', '', text)
        
        # Process normalized text
        result = self._process(text)
        return result
    
    def process_string(self, string):
        # Normalize
        text = string.lower()
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # Remove special chars
        text = re.sub(r'[^\w\s]', '', text)
        
        # Process normalized text
        result = self._process(text)
        return result
```

✅ **AFTER**:
```python
class TextProcessor:
    def process_document(self, document):
        """Process a document.
        
        Args:
            document: Document to process
            
        Returns:
            Processed result
        """
        # Extract text
        raw_text = document.get_text()
        
        # Normalize and process
        return self._normalize_and_process(raw_text)
    
    def process_string(self, string):
        """Process a string.
        
        Args:
            string: String to process
            
        Returns:
            Processed result
        """
        # Normalize and process
        return self._normalize_and_process(string)
        
    def _normalize_and_process(self, text):
        """Normalize and process text.
        
        Args:
            text: Raw text to normalize and process
            
        Returns:
            Processed result
        """
        # Normalize
        text = text.lower()
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        # Remove special chars
        text = re.sub(r'[^\w\s]', '', text)
        
        # Process normalized text
        return self._process(text)
```

### Example 2: Interface Extraction and Implementation

❌ **BEFORE**:
```python
# Directly using implementation
class OpenAILLM:
    def __init__(self, api_key, model="gpt-3.5-turbo"):
        self.api_key = api_key
        self.model = model
        self.client = None
        
    async def initialize(self):
        if hasattr(self, 'client') and self.client:
            return
            
        self.client = OpenAI(api_key=self.api_key)
        
    async def generate(self, prompt):
        if not self.client:
            await self.initialize()
            
        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
        
    async def cleanup(self):
        if self.client:
            await self.client.close()
            self.client = None

# Using directly
async with OpenAILLM(api_key="...") as llm:
    result = await llm.generate("Hello")
```

✅ **AFTER**:
```python
# Define interface in base.py
from typing import Protocol

class LLMProvider(Protocol):
    """LLM provider interface."""
    
    async def initialize(self) -> None:
        """Initialize the provider."""
        ...
        
    async def generate(self, prompt: str) -> str:
        """Generate text from prompt.
        
        Args:
            prompt: Input prompt
            
        Returns:
            Generated text
        """
        ...
        
    async def cleanup(self) -> None:
        """Clean up resources."""
        ...

# Factory function
def create_llm(provider_type: str = None, **config) -> LLMProvider:
    """Create an LLM provider.
    
    Args:
        provider_type: Type of provider
        **config: Provider configuration
        
    Returns:
        LLM provider instance
    """
    provider_type = provider_type or os.environ.get("PEPPERPY_LLM_PROVIDER", "openai")
    
    if provider_type == "openai":
        from .providers.openai import OpenAIProvider
        return OpenAIProvider(**config)
    elif provider_type == "anthropic":
        from .providers.anthropic import AnthropicProvider
        return AnthropicProvider(**config)
    else:
        raise ValueError(f"Unknown provider type: {provider_type}")

# Implementation
class OpenAIProvider(ProviderPlugin):
    """OpenAI implementation of LLM provider."""
    
    # Type-annotated config
    api_key: str
    model: str = "gpt-3.5-turbo"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.client = None
        
    async def initialize(self) -> None:
        """Initialize provider."""
        if self.initialized:
            return
            
        self.client = OpenAI(api_key=self.api_key)
        
    async def generate(self, prompt: str) -> str:
        """Generate text from prompt.
        
        Args:
            prompt: Input prompt
            
        Returns:
            Generated text
        """
        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
        
    async def cleanup(self) -> None:
        """Clean up resources."""
        if self.client:
            await self.client.close()
            self.client = None

# Using with factory
async with create_llm(api_key="...") as llm:
    result = await llm.generate("Hello")
```

## Conclusion

This refactoring workflow ensures:

1. **Safe transformation** of existing code
2. **Improved architecture** and maintainability
3. **Consistent patterns** across the framework
4. **Enhanced readability** and reusability
5. **Preserved behavior** through testing

Always follow this workflow when refactoring code in the PepperPy framework to ensure quality and consistency.
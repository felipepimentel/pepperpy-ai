---
description: USE WHEN working with scripts/refactoring_tools or scripts/refactor.py
globs: scripts/refactoring_tools/**/*.py,scripts/refactor.py
alwaysApply: false
---

# Refactoring Tools Guidelines

## Core Components

1. **RefactoringContext** (`context.py`):
   - Central configuration and logging
   - Workspace management
   - Error tracking

2. **AICodeSearcher** (`ai_search.py`):
   - Pattern-based code search
   - Similarity scoring
   - Caching of search results

3. **CodePatternAnalyzer** (`pattern_analyzer.py`):
   - AST-based analysis
   - Pattern extraction
   - Implementation suggestions

## Command Structure

Commands in `refactor.py` should follow:

```python
@click.command()
@click.option('--option', help='Option description')
def my_command(option):
    """Command description."""
    context = RefactoringContext()
    try:
        # Use local tools
        tool = MyTool(context)
        result = tool.process()
        # Handle result
    except Exception as e:
        context.logger.error(f"Command failed: {e}")
        raise
```

## Error Handling

1. **Context Usage**:
```python
try:
    # Operation
except Exception as e:
    self.context.logger.error(f"Operation failed: {e}")
    raise  # Only raise if fatal
```

2. **File Operations**:
```python
try:
    with open(file_path, "r") as f:
        content = f.read()
except FileNotFoundError:
    self.context.logger.warning(f"File not found: {file_path}")
    return None
except Exception as e:
    self.context.logger.error(f"Failed to read {file_path}: {e}")
    raise
```

## AST Processing

1. **Node Handling**:
```python
def process_node(self, node: ast.AST) -> Any:
    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
        return self._process_function(node)
    elif isinstance(node, ast.ClassDef):
        return self._process_class(node)
    return None
```

2. **Safe Attribute Access**:
```python
def get_node_info(self, node: ast.AST) -> Dict:
    return {
        "lineno": getattr(node, "lineno", 0),
        "end_lineno": getattr(node, "end_lineno", 
                             getattr(node, "lineno", 0)),
        "name": getattr(node, "name", None)
    }
```

## Pattern Matching

1. **Code Similarity**:
```python
def calculate_similarity(self, code1: str, code2: str) -> float:
    """Calculate code similarity score."""
    # Normalize code
    code1_norm = self._normalize_code(code1)
    code2_norm = self._normalize_code(code2)
    
    # Compare
    return self._compare_normalized(code1_norm, code2_norm)
```

2. **Pattern Extraction**:
```python
def extract_pattern(self, node: ast.AST) -> Dict:
    """Extract implementation pattern from AST node."""
    return {
        "type": type(node).__name__,
        "structure": self._get_structure(node),
        "context": self._get_context(node)
    }
```

## Best Practices

1. **Local Imports**:
   - Use relative imports within tools
   - Keep dependencies minimal
   - Document external requirements

2. **Tool Design**:
   - Single responsibility
   - Clear interfaces
   - Comprehensive documentation

3. **Performance**:
   - Cache expensive operations
   - Use generators for large files
   - Profile critical paths

4. **Testing**:
   - Unit test each tool
   - Mock file operations
   - Test error cases

## Common Mistakes to Avoid

1. **DO NOT**:
   - Import from pepperpy library
   - Mix responsibilities between tools
   - Skip error handling
   - Ignore type hints
   - Leave debug logs

2. **ALWAYS**:
   - Use RefactoringContext
   - Document public APIs
   - Handle file operations safely
   - Cache when appropriate
   - Log meaningful messages 
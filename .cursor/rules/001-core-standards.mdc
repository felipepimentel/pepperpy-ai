---
description: ALWAYS use when writing or modifying Python code to ensure consistent standards, best practices, and maintainability. This rule combines core project standards with Python-specific guidelines.
globs: ["**/*.py", "**/*.pyi", "**/*.pyx"]
version: 1.0
priority: critical
tags: ["python", "standards", "core", "best-practices"]
---

<?xml version="1.0" encoding="UTF-8"?>
<rule>
  <metadata>
    <n>core_standards</n>
    <description>ALWAYS use when writing or modifying Python code to ensure consistent standards, best practices, and maintainability. This rule combines core project standards with Python-specific guidelines.</description>
    <priority>critical</priority>
    <version>1.0</version>
    <tags>
      <tag>python</tag>
      <tag>standards</tag>
      <tag>core</tag>
      <tag>best-practices</tag>
    </tags>
  </metadata>

  <filters>
    <filter>
      <type>file_extension</type>
      <pattern>\.py[ix]?$</pattern>
      <description>Match Python files including type stubs and Cython</description>
    </filter>
  </filters>

  <actions>
    <action>
      <type>validate</type>
      <conditions>
        <condition>
          <pattern>^(?!.*def\s+\w+\s*\([^)]*\)\s*(?:->\s*\w+)?:).*$</pattern>
          <message>All functions must have type hints</message>
        </condition>
        <condition>
          <pattern>^(?!.*class\s+\w+).*$</pattern>
          <message>All classes must have docstrings</message>
        </condition>
      </conditions>
    </action>
  </actions>

  <guidelines>
    <overview>
      <description>This document combines core project standards with Python-specific guidelines to ensure consistency, maintainability, and code quality across the Pepperpy project.</description>
    </overview>

    <core_standards>
      <goals>
        <goal>Ensure Python code adheres to PEP 8 standards and uses explicit type annotations</goal>
        <goal>Generate modular, scalable, and extensible code that aligns with project structure</goal>
        <goal>Apply Google-style docstrings to all public APIs</goal>
        <goal>Manage project status and tasks effectively</goal>
        <goal>Maintain architectural integrity through validation</goal>
      </goals>

      <project_structure>
        <requirement>Validate against `.product/project_structure.yml`</requirement>
        <requirement>Use `./scripts/validate_structure.py` for structure verification</requirement>
        <requirement>Keep `.product/kanban.md` updated with tasks and progress</requirement>
      </project_structure>
    </core_standards>

    <python_guidelines>
      <philosophy>
        <principle name="readability">Prefer clear and concise code over clever solutions</principle>
        <principle name="naming">Use `snake_case` for functions/variables, `CamelCase` for classes</principle>
        <principle name="responsibility">Keep functions and classes focused</principle>
        <principle name="error_handling">Use Pythonic error handling with try/except (EAFP)</principle>
      </philosophy>

      <code_organization>
        <section name="imports">
          <group>Standard library</group>
          <group>Third-party packages</group>
          <group>Local modules</group>
        </section>

        <section name="class_structure">
          <order>
            <item>Class-level docstring</item>
            <item>Class attributes</item>
            <item>__init__</item>
            <item>Public methods</item>
            <item>Protected methods</item>
            <item>Private methods</item>
          </order>
        </section>
      </code_organization>

      <priorities>
        <priority level="medium">
          <item>Code formatting (Black)</item>
          <item>Import sorting (isort)</item>
          <item>Documentation examples</item>
        </priority>
        <priority level="low">
          <item>Optional type hints in private methods</item>
          <item>Internal documentation</item>
          <item>Performance optimizations</item>
        </priority>
      </priorities>
    </python_guidelines>
  </guidelines>

  <examples>
    <example>
      <correct>
        <description>Complete function with proper type hints, docstring, and error handling</description>
        <content>
          <![CDATA[
from pathlib import Path
from typing import List, Optional

from pepperpy.exceptions import FileProcessError
from pepperpy.utils.logging import get_logger

logger = get_logger(__name__)

def process_files(
    directory: Path,
    pattern: str = "*.txt",
    max_files: Optional[int] = None
) -> List[Path]:
    """Process files in the given directory matching the pattern.

    Args:
        directory: Directory to search for files
        pattern: Glob pattern to match files
        max_files: Maximum number of files to process

    Returns:
        List of processed file paths

    Raises:
        FileProcessError: If directory doesn't exist or is not readable
    """
    try:
        files = list(directory.glob(pattern))
        if max_files is not None:
            files = files[:max_files]
        
        logger.info(
            "Processing files",
            extra={"directory": str(directory), "count": len(files)}
        )
        return files
    except Exception as e:
        raise FileProcessError(f"Failed to process files: {e}") from e
          ]]>
        </content>
      </correct>
      <incorrect>
        <description>Poor code without type hints, proper error handling, or docstring</description>
        <content>
          <![CDATA[
# Bad: No type hints, poor error handling, no docstring
def process(dir, pat=None):
    try:
        return [f for f in dir.glob(pat or "*")]
    except:  # Bad: Bare except
        print("Error")  # Bad: Print instead of logging
        return []
          ]]>
        </content>
        <errors>
          <e>Missing type hints</e>
          <e>No docstring</e>
          <e>Bare except clause</e>
          <e>Using print instead of logger</e>
          <e>Poor variable naming</e>
        </errors>
      </incorrect>
    </example>
  </examples>
</rule> 
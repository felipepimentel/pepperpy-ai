---
title: File Management and Organization
description: Apply this rule when creating new files, organizing code, or restructuring the PepperPy codebase to maintain consistent file structure and naming conventions
globs:
  - "pepperpy/**/*.py"
priority: 200
---

# File Management and Organization

## Overview

This rule defines the high-level organization and structure of the PepperPy framework. It provides guidelines for file locations, naming conventions, and module organization to ensure consistency across the codebase.

## Framework Structure

### 1. Core Framework

```bash
pepperpy/core/
├── __init__.py     # Core framework exports
├── base.py         # Base classes and interfaces
├── errors.py       # Framework exceptions
├── config.py       # Configuration management
├── http.py         # HTTP client utilities
└── utils/          # Shared utilities
    ├── __init__.py
    ├── text.py
    └── validation.py
```

### 2. Domain Modules

```bash
pepperpy/domain_name/
├── __init__.py     # Public API
├── base.py         # Domain interfaces
├── config.py       # Domain configuration
├── errors.py       # Domain-specific errors
├── providers/      # Provider implementations
│   ├── __init__.py
│   └── specific_provider.py
└── utils/          # Domain utilities
    └── __init__.py
```

### 3. Tests

```bash
tests/
├── unit/          # Unit tests
│   ├── core/
│   └── domain_name/
├── integration/    # Integration tests
└── e2e/           # End-to-end tests
```

## File Categories

### 1. Framework Files

Core framework files MUST be in `pepperpy/core/`:
- Base interfaces (`base.py`)
- Framework exceptions (`errors.py`)
- Configuration management (`config.py`)
- HTTP utilities (`http.py`)
- Shared utilities (`utils/`)

### 2. Domain Files

Domain-specific files MUST be in their respective domains:
- Public API (`__init__.py`)
- Domain interfaces (`base.py`)
- Domain configuration (`config.py`)
- Domain errors (`errors.py`)
- Provider implementations (`providers/`)
- Domain utilities (`utils/`)

### 3. Test Files

Test files MUST be organized by type:
- Unit tests in `tests/unit/`
- Integration tests in `tests/integration/`
- End-to-end tests in `tests/e2e/`

## Naming Conventions

### 1. Python Files

- Use snake_case for all files
- End test files with `_test.py`
- End type files with `_types.py`
- End utility files with `_utils.py`

Examples:
```bash
# Correct
text_utils.py
openai_provider.py
base_types.py
client_test.py

# Wrong
textUtils.py
OpenAIProvider.py
BaseTypes.py
clientTest.py
```

### 2. Special Files

- Base interfaces: `base.py`
- Public API: `__init__.py`
- Domain errors: `errors.py`
- Configuration: `config.py`
- Type definitions: `types.py`

### 3. Test Files

- Unit tests: `test_module.py`
- Integration tests: `test_integration_module.py`
- E2E tests: `test_e2e_module.py`

## Module Organization

### 1. Public API (`__init__.py`)

```python
"""Module description."""

from .base import BaseClass
from .providers import Provider1, Provider2

__all__ = [
    "BaseClass",
    "Provider1",
    "Provider2",
]
```

### 2. Base Interfaces (`base.py`)

```python
"""Base interfaces for the module."""

from typing import Protocol

class BaseProvider(Protocol):
    """Base provider interface."""
    
    def method(self) -> None:
        """Method description."""
        pass
```

### 3. Provider Implementations

```python
"""Provider implementation."""

from ..base import BaseProvider

class SpecificProvider(BaseProvider):
    """Specific provider implementation."""
    
    def method(self) -> None:
        """Implementation."""
        pass
```

## Documentation

### 1. Module Documentation

Every module MUST have:
- Module docstring
- Import organization
- Public API exports

Example:
```python
"""
Module Name
===========

Module description and usage examples.

Examples:
    Basic usage:
    >>> from module import Class
    >>> obj = Class()
"""

from typing import Optional

from .base import BaseClass

__all__ = ["BaseClass"]
```

### 2. API Documentation

Public APIs MUST have:
- Class docstrings
- Method docstrings
- Type hints
- Usage examples

Example:
```python
class Provider:
    """Provider implementation.
    
    Examples:
        >>> provider = Provider()
        >>> result = provider.process()
    """
    
    def process(self, data: dict) -> str:
        """Process the data.
        
        Args:
            data: The input data.
            
        Returns:
            The processed result.
            
        Raises:
            ValueError: If data is invalid.
        """
        pass
```

## Conclusion

Following these guidelines ensures:
1. Consistent file organization
2. Clear module boundaries
3. Easy navigation
4. Maintainable structure
5. Scalable architecture

NEVER deviate from these conventions. When in doubt, check existing modules for examples. 
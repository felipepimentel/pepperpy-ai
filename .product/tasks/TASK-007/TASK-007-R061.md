# R061: Unificação do Sistema de Gerenciamento de Recursos

## Descrição

Unificar e padronizar o sistema de gerenciamento de recursos em todo o framework, estabelecendo uma interface consistente para alocação, liberação e monitoramento de recursos. O sistema atual possui diferentes implementações de gerenciamento de recursos espalhadas em vários módulos, dificultando a manutenção e o controle efetivo dos recursos.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R026: Padronização do Sistema de Logging
- R045: Consolidação do Sistema de Gerenciamento de Recursos

## Estado Atual

Atualmente, o gerenciamento de recursos está distribuído em vários módulos:

1. Em `core/resources/manager.py`:
```python
class ResourceManager:
    """Manage system resources."""
    
    def __init__(self):
        self._resources = {}
        
    async def allocate(
        self,
        resource_type: str,
        **options: Any
    ) -> Resource:
        """Allocate a resource."""
        # Implementation
        pass
        
    async def release(
        self,
        resource: Resource
    ) -> None:
        """Release a resource."""
        # Implementation
        pass
```

2. Em `memory/resources.py`:
```python
class MemoryResourceManager:
    """Manage memory resources."""
    
    def __init__(self, limits: Dict[str, int]):
        self._limits = limits
        self._allocated = {}
        
    async def allocate_memory(
        self,
        size: int,
        **options: Any
    ) -> MemoryResource:
        """Allocate memory."""
        # Implementation
        pass
        
    async def release_memory(
        self,
        resource: MemoryResource
    ) -> None:
        """Release memory."""
        # Implementation
        pass
```

## Plano de Implementação

1. Criar sistema base de recursos:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar
from dataclasses import dataclass
from datetime import datetime

T = TypeVar("T")

@dataclass
class ResourceMetadata:
    """Metadata for resource allocation."""
    resource_type: str
    allocation_time: datetime
    expiration_time: Optional[datetime]
    limits: Dict[str, Any]
    tags: Dict[str, str]

@dataclass
class Resource(Generic[T]):
    """Base class for resources."""
    id: str
    data: T
    metadata: ResourceMetadata
    state: str
    error: Optional[str]

class ResourceProvider(ABC, Generic[T]):
    """Base class for resource providers."""
    
    @abstractmethod
    async def allocate(
        self,
        resource_type: str,
        metadata: ResourceMetadata,
        **options: Any
    ) -> Resource[T]:
        """Allocate a resource."""
        pass
    
    @abstractmethod
    async def release(
        self,
        resource: Resource[T]
    ) -> None:
        """Release a resource."""
        pass
    
    @abstractmethod
    async def validate(
        self,
        resource: Resource[T]
    ) -> List[str]:
        """Validate resource state."""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up provider resources."""
        pass
```

2. Implementar sistema de gerenciamento unificado:

```python
class UnifiedResourceManager:
    """Unified resource management system."""
    
    def __init__(self):
        self._providers: Dict[str, ResourceProvider] = {}
        self._resources: Dict[str, Resource] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_provider(
        self,
        resource_type: str,
        provider: ResourceProvider
    ) -> None:
        """Register a resource provider."""
        self._providers[resource_type] = provider
        
    async def allocate(
        self,
        resource_type: str,
        **options: Any
    ) -> Resource:
        """Allocate a resource."""
        if resource_type not in self._providers:
            raise ValueError(f"Provider not found: {resource_type}")
            
        provider = self._providers[resource_type]
        
        metadata = ResourceMetadata(
            resource_type=resource_type,
            allocation_time=datetime.now(),
            expiration_time=options.get("expiration_time"),
            limits=options.get("limits", {}),
            tags=options.get("tags", {})
        )
        
        try:
            resource = await provider.allocate(
                resource_type,
                metadata,
                **options
            )
            
            self._resources[resource.id] = resource
            
            self._metrics.counter(
                "resource_allocations",
                1,
                resource_type=resource_type,
                success="true"
            )
            
            return resource
            
        except Exception as e:
            self._metrics.counter(
                "resource_allocations",
                1,
                resource_type=resource_type,
                success="false"
            )
            
            self._logger.error(
                "Resource allocation failed",
                extra={
                    "resource_type": resource_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def release(
        self,
        resource_id: str
    ) -> None:
        """Release a resource."""
        if resource_id not in self._resources:
            raise ValueError(f"Resource not found: {resource_id}")
            
        resource = self._resources[resource_id]
        provider = self._providers[resource.metadata.resource_type]
        
        try:
            await provider.release(resource)
            
            del self._resources[resource_id]
            
            self._metrics.counter(
                "resource_releases",
                1,
                resource_type=resource.metadata.resource_type,
                success="true"
            )
            
        except Exception as e:
            self._metrics.counter(
                "resource_releases",
                1,
                resource_type=resource.metadata.resource_type,
                success="false"
            )
            
            self._logger.error(
                "Resource release failed",
                extra={
                    "resource_id": resource_id,
                    "error": str(e)
                }
            )
            
            raise
            
    async def cleanup(self) -> None:
        """Clean up all resources."""
        for provider in self._providers.values():
            try:
                await provider.cleanup()
            except Exception as e:
                self._logger.error(
                    "Provider cleanup failed",
                    extra={"error": str(e)}
                )
```

3. Implementar provedores específicos:

```python
class MemoryResourceProvider(ResourceProvider[int]):
    """Provider for memory resources."""
    
    def __init__(self, limits: Dict[str, int]):
        self._limits = limits
        self._allocated: Dict[str, int] = {}
        self._metrics = MetricsManager.get_instance()
        
    async def allocate(
        self,
        resource_type: str,
        metadata: ResourceMetadata,
        size: int,
        **options: Any
    ) -> Resource[int]:
        """Allocate memory."""
        if sum(self._allocated.values()) + size > self._limits.get("total", 1000000):
            raise ValueError("Memory limit exceeded")
            
        resource_id = str(uuid.uuid4())
        self._allocated[resource_id] = size
        
        return Resource(
            id=resource_id,
            data=size,
            metadata=metadata,
            state="allocated",
            error=None
        )
        
    async def release(
        self,
        resource: Resource[int]
    ) -> None:
        """Release memory."""
        if resource.id in self._allocated:
            del self._allocated[resource.id]
            
    async def validate(
        self,
        resource: Resource[int]
    ) -> List[str]:
        """Validate resource state."""
        errors = []
        
        if resource.id not in self._allocated:
            errors.append("Resource not allocated")
            
        if resource.data > self._limits.get("max_size", 100000):
            errors.append("Resource size exceeds limit")
            
        return errors
        
    async def cleanup(self) -> None:
        """Clean up provider resources."""
        self._allocated.clear()
```

4. Implementar sistema de monitoramento:

```python
class ResourceMonitor:
    """Monitor for resource management."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_allocation(
        self,
        resource_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record resource allocation."""
        self._metrics.counter(
            "resource_operations",
            1,
            operation="allocate",
            resource_type=resource_type,
            success=str(success).lower(),
            **labels
        )
        
    async def record_release(
        self,
        resource_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record resource release."""
        self._metrics.counter(
            "resource_operations",
            1,
            operation="release",
            resource_type=resource_type,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/resources/manager.py`
   - Atualizar `memory/resources.py`
   - Criar novos provedores conforme necessário

## Validação

```python
async def test_resource_system():
    # Setup
    manager = UnifiedResourceManager()
    monitor = ResourceMonitor()
    
    # Register providers
    memory_provider = MemoryResourceProvider({"total": 1000000})
    manager.register_provider("memory", memory_provider)
    
    # Test allocation
    resource = await manager.allocate(
        "memory",
        size=1000,
        tags={"purpose": "test"}
    )
    
    assert resource.data == 1000
    assert resource.state == "allocated"
    assert resource.metadata.tags["purpose"] == "test"
    
    # Test validation
    errors = await memory_provider.validate(resource)
    assert not errors
    
    # Test release
    await manager.release(resource.id)
    
    # Test monitoring
    await monitor.record_allocation("memory", True)
    await monitor.record_release("memory", True)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_resource_system():
    # Restore legacy implementations
    shutil.copy("core/resources/manager_legacy.py", "core/resources/manager.py")
    shutil.copy("memory/resources_legacy.py", "memory/resources.py")
    
    # Cleanup new implementations
    os.remove("core/resources/unified.py")
    os.remove("core/resources/providers.py")
    os.remove("core/resources/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de gerenciamento
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para alocação
   - Latência < 20ms para liberação
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de recursos
- [ ] Implementação do gerenciamento unificado
- [ ] Implementação dos provedores específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
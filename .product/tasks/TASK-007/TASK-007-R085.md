# R085: Unificação do Sistema de Capacidades

## Descrição

Unificar e padronizar o sistema de capacidades em todo o framework, estabelecendo uma interface consistente para o desenvolvimento e gerenciamento de capacidades. O sistema atual possui diferentes implementações de capacidades espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R067: Padronização do Sistema de Composição
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, as capacidades estão distribuídas em vários módulos:

1. Em `core/capabilities/base.py`:
```python
class Capability(ABC):
    """Base class for capabilities."""
    
    def __init__(self, config: Dict[str, Any]):
        self._config = config
        
    @property
    def config(self) -> Dict[str, Any]:
        """Get capability config."""
        return self._config
        
    async def initialize(self) -> None:
        """Initialize capability."""
        pass
        
    async def cleanup(self) -> None:
        """Cleanup capability."""
        pass
```

2. Em `agents/capabilities/tools.py`:
```python
class ToolCapability(Capability):
    """Capability for tool operations."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self._tools = {}
        
    async def register_tool(
        self,
        name: str,
        tool: Tool
    ) -> None:
        """Register tool."""
        self._tools[name] = tool
        
    async def execute_tool(
        self,
        name: str,
        *args: Any,
        **kwargs: Any
    ) -> Any:
        """Execute tool."""
        if name not in self._tools:
            raise ValueError(f"Tool {name} not found")
            
        tool = self._tools[name]
        return await tool.execute(*args, **kwargs)
```

## Plano de Implementação

1. Criar sistema base de capacidades:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging

T = TypeVar("T")

class CapabilityType(Enum):
    """Capability types."""
    
    TOOLS = "tools"
    MEMORY = "memory"
    STORAGE = "storage"
    CUSTOM = "custom"

@dataclass
class CapabilityMetadata:
    """Metadata for capabilities."""
    
    name: str
    type: CapabilityType
    description: str
    version: str
    requirements: List[str] = field(default_factory=list)
    labels: Dict[str, str] = field(default_factory=dict)

class Capability(ABC, Generic[T]):
    """Base class for capabilities."""
    
    def __init__(
        self,
        metadata: CapabilityMetadata,
        config: T
    ):
        self._metadata = metadata
        self._config = config
        self._state = {}
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> CapabilityMetadata:
        """Get capability metadata."""
        return self._metadata
        
    @property
    def config(self) -> T:
        """Get capability config."""
        return self._config
        
    @property
    def state(self) -> Dict[str, Any]:
        """Get capability state."""
        return self._state
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize capability."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup capability."""
        pass
        
    async def validate(self) -> None:
        """Validate capability."""
        pass
        
    async def reload(self) -> None:
        """Reload capability."""
        await self.cleanup()
        await self.initialize()
```

2. Implementar sistema de gerenciamento de capacidades:

```python
class CapabilityManager:
    """Manager for capabilities."""
    
    def __init__(self):
        self._capabilities: Dict[str, Capability[Any]] = {}
        self._logger = logging.getLogger(__name__)
        
    async def register(
        self,
        capability: Capability[Any]
    ) -> None:
        """Register capability."""
        try:
            name = capability.metadata.name
            
            if name in self._capabilities:
                raise ValueError(f"Capability {name} already registered")
                
            await capability.validate()
            await capability.initialize()
            
            self._capabilities[name] = capability
            
        except Exception as e:
            self._logger.error(
                "Failed to register capability",
                extra={
                    "name": capability.metadata.name,
                    "type": capability.metadata.type.value,
                    "error": str(e)
                }
            )
            raise
            
    async def unregister(
        self,
        name: str
    ) -> None:
        """Unregister capability."""
        try:
            if name not in self._capabilities:
                raise ValueError(f"Capability {name} not found")
                
            capability = self._capabilities[name]
            await capability.cleanup()
            
            del self._capabilities[name]
            
        except Exception as e:
            self._logger.error(
                "Failed to unregister capability",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    def get_capability(
        self,
        name: str
    ) -> Optional[Capability[Any]]:
        """Get capability by name."""
        return self._capabilities.get(name)
        
    def get_capabilities_by_type(
        self,
        type: CapabilityType
    ) -> List[Capability[Any]]:
        """Get capabilities by type."""
        return [
            cap for cap in self._capabilities.values()
            if cap.metadata.type == type
        ]
        
    def get_capabilities_by_requirement(
        self,
        requirement: str
    ) -> List[Capability[Any]]:
        """Get capabilities by requirement."""
        return [
            cap for cap in self._capabilities.values()
            if requirement in cap.metadata.requirements
        ]
        
    async def reload_capability(
        self,
        name: str
    ) -> None:
        """Reload capability."""
        try:
            if name not in self._capabilities:
                raise ValueError(f"Capability {name} not found")
                
            capability = self._capabilities[name]
            await capability.reload()
            
        except Exception as e:
            self._logger.error(
                "Failed to reload capability",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    async def cleanup(self) -> None:
        """Cleanup all capabilities."""
        for name in list(self._capabilities.keys()):
            await self.unregister(name)
```

3. Implementar tipos comuns de capacidades:

```python
class ToolCapability(Capability[T]):
    """Capability for tool operations."""
    
    def __init__(
        self,
        metadata: CapabilityMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._tools: Dict[str, Tool] = {}
        
    @property
    def tools(self) -> Dict[str, Tool]:
        """Get registered tools."""
        return self._tools
        
    async def register_tool(
        self,
        name: str,
        tool: Tool
    ) -> None:
        """Register tool."""
        if name in self._tools:
            raise ValueError(f"Tool {name} already registered")
            
        self._tools[name] = tool
        
    async def unregister_tool(
        self,
        name: str
    ) -> None:
        """Unregister tool."""
        if name not in self._tools:
            raise ValueError(f"Tool {name} not found")
            
        del self._tools[name]
        
    async def execute_tool(
        self,
        name: str,
        *args: Any,
        **kwargs: Any
    ) -> Any:
        """Execute tool."""
        if name not in self._tools:
            raise ValueError(f"Tool {name} not found")
            
        tool = self._tools[name]
        return await tool.execute(*args, **kwargs)
        
    async def initialize(self) -> None:
        """Initialize tool capability."""
        await self._initialize_tools()
        
    async def cleanup(self) -> None:
        """Cleanup tool capability."""
        await self._cleanup_tools()
        
    @abstractmethod
    async def _initialize_tools(self) -> None:
        """Initialize tools."""
        pass
        
    @abstractmethod
    async def _cleanup_tools(self) -> None:
        """Cleanup tools."""
        pass

class MemoryCapability(Capability[T]):
    """Capability for memory operations."""
    
    def __init__(
        self,
        metadata: CapabilityMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._store = None
        
    @property
    def store(self) -> Optional[MemoryStore]:
        """Get memory store."""
        return self._store
        
    async def initialize(self) -> None:
        """Initialize memory capability."""
        await self._initialize_store()
        
    async def cleanup(self) -> None:
        """Cleanup memory capability."""
        if self._store is not None:
            await self._cleanup_store()
            
    @abstractmethod
    async def _initialize_store(self) -> None:
        """Initialize memory store."""
        pass
        
    @abstractmethod
    async def _cleanup_store(self) -> None:
        """Cleanup memory store."""
        pass
```

4. Implementar sistema de monitoramento:

```python
class CapabilityMonitor:
    """Monitor for capability operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def record_operation(
        self,
        operation: str,
        capability_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record capability operation."""
        try:
            self._metrics.counter(
                "capability_operations",
                1,
                operation=operation,
                type=capability_type,
                success=str(success).lower(),
                **labels
            )
            
            if success:
                self._metrics.histogram(
                    "capability_duration",
                    duration,
                    operation=operation,
                    type=capability_type,
                    **labels
                )
                
        except Exception as e:
            self._logger.error(
                "Failed to record capability operation",
                extra={
                    "operation": operation,
                    "type": capability_type,
                    "success": success,
                    "duration": duration,
                    "labels": labels,
                    "error": str(e)
                }
            )
```

5. Migrar implementações existentes:
   - Converter capacidades para nova interface
   - Atualizar gerenciamento de capacidades
   - Implementar monitoramento específico

## Validação

```python
async def test_capability_system():
    # Setup
    manager = CapabilityManager()
    monitor = CapabilityMonitor()
    
    # Create tool capability
    tool_metadata = CapabilityMetadata(
        name="test_tools",
        type=CapabilityType.TOOLS,
        description="Test tool capability",
        version="1.0.0",
        requirements=["core"],
        labels={"env": "test"}
    )
    
    tool_config = ToolConfig(
        name="test",
        enabled=True
    )
    
    tool_capability = TestToolCapability(
        tool_metadata,
        tool_config
    )
    
    # Create memory capability
    memory_metadata = CapabilityMetadata(
        name="test_memory",
        type=CapabilityType.MEMORY,
        description="Test memory capability",
        version="1.0.0",
        requirements=["core"],
        labels={"env": "test"}
    )
    
    memory_config = MemoryConfig(
        name="test",
        enabled=True
    )
    
    memory_capability = TestMemoryCapability(
        memory_metadata,
        memory_config
    )
    
    # Register capabilities
    await manager.register(tool_capability)
    await manager.register(memory_capability)
    
    # Test operations
    capabilities = manager.get_capabilities_by_type(CapabilityType.TOOLS)
    assert len(capabilities) == 1
    assert capabilities[0].metadata.name == "test_tools"
    
    capabilities = manager.get_capabilities_by_requirement("core")
    assert len(capabilities) == 2
    
    # Test reload
    await manager.reload_capability("test_tools")
    
    # Test unregister
    await manager.unregister("test_memory")
    
    # Test monitoring
    await monitor.record_operation(
        "register",
        "tools",
        True,
        0.001,
        name="test_tools"
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_capability_system():
    # Restore legacy implementations
    shutil.copy("core/capabilities/base_legacy.py", "core/capabilities/base.py")
    shutil.copy("agents/capabilities/tools_legacy.py", "agents/capabilities/tools.py")
    
    # Cleanup new implementations
    os.remove("core/capabilities/base/base.py")
    os.remove("core/capabilities/base/manager.py")
    os.remove("core/capabilities/base/types.py")
    os.remove("core/capabilities/base/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de capacidades
   - Interface consistente
   - Metadados unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas de capacidade
   - Documentação completa

3. **Performance**:
   - Latência < 1ms por operação
   - Baixo consumo de memória
   - Carregamento eficiente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de capacidades
- [ ] Implementação do gerenciamento de capacidades
- [ ] Implementação dos tipos comuns
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
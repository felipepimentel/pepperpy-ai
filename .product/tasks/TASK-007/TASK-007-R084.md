# R084: Consolidação do Sistema de Provedores

## Descrição

Unificar e padronizar o sistema de provedores em todo o framework, estabelecendo uma interface consistente para o desenvolvimento e gerenciamento de provedores. O sistema atual possui diferentes implementações de provedores espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R067: Padronização do Sistema de Composição
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, os provedores estão distribuídos em vários módulos:

1. Em `providers/base.py`:
```python
class Provider(ABC):
    """Base class for providers."""
    
    def __init__(self, config: Dict[str, Any]):
        self._config = config
        
    @property
    def config(self) -> Dict[str, Any]:
        """Get provider config."""
        return self._config
        
    async def initialize(self) -> None:
        """Initialize provider."""
        pass
        
    async def cleanup(self) -> None:
        """Cleanup provider."""
        pass
```

2. Em `memory/providers/local.py`:
```python
class LocalProvider(Provider):
    """Provider for local storage."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self._store = None
        
    async def initialize(self) -> None:
        """Initialize provider."""
        self._store = LocalStore(self._config)
        await self._store.initialize()
        
    async def cleanup(self) -> None:
        """Cleanup provider."""
        if self._store is not None:
            await self._store.cleanup()
```

## Plano de Implementação

1. Criar sistema base de provedores:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging

T = TypeVar("T")

class ProviderType(Enum):
    """Provider types."""
    
    MEMORY = "memory"
    STORAGE = "storage"
    CAPABILITY = "capability"
    CUSTOM = "custom"

@dataclass
class ProviderMetadata:
    """Metadata for providers."""
    
    name: str
    type: ProviderType
    description: str
    version: str
    capabilities: List[str] = field(default_factory=list)
    labels: Dict[str, str] = field(default_factory=dict)

class Provider(ABC, Generic[T]):
    """Base class for providers."""
    
    def __init__(
        self,
        metadata: ProviderMetadata,
        config: T
    ):
        self._metadata = metadata
        self._config = config
        self._state = {}
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> ProviderMetadata:
        """Get provider metadata."""
        return self._metadata
        
    @property
    def config(self) -> T:
        """Get provider config."""
        return self._config
        
    @property
    def state(self) -> Dict[str, Any]:
        """Get provider state."""
        return self._state
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize provider."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup provider."""
        pass
        
    async def validate(self) -> None:
        """Validate provider."""
        pass
        
    async def reload(self) -> None:
        """Reload provider."""
        await self.cleanup()
        await self.initialize()
```

2. Implementar sistema de gerenciamento de provedores:

```python
class ProviderManager:
    """Manager for providers."""
    
    def __init__(self):
        self._providers: Dict[str, Provider[Any]] = {}
        self._logger = logging.getLogger(__name__)
        
    async def register(
        self,
        provider: Provider[Any]
    ) -> None:
        """Register provider."""
        try:
            name = provider.metadata.name
            
            if name in self._providers:
                raise ValueError(f"Provider {name} already registered")
                
            await provider.validate()
            await provider.initialize()
            
            self._providers[name] = provider
            
        except Exception as e:
            self._logger.error(
                "Failed to register provider",
                extra={
                    "name": provider.metadata.name,
                    "type": provider.metadata.type.value,
                    "error": str(e)
                }
            )
            raise
            
    async def unregister(
        self,
        name: str
    ) -> None:
        """Unregister provider."""
        try:
            if name not in self._providers:
                raise ValueError(f"Provider {name} not found")
                
            provider = self._providers[name]
            await provider.cleanup()
            
            del self._providers[name]
            
        except Exception as e:
            self._logger.error(
                "Failed to unregister provider",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    def get_provider(
        self,
        name: str
    ) -> Optional[Provider[Any]]:
        """Get provider by name."""
        return self._providers.get(name)
        
    def get_providers_by_type(
        self,
        type: ProviderType
    ) -> List[Provider[Any]]:
        """Get providers by type."""
        return [
            prov for prov in self._providers.values()
            if prov.metadata.type == type
        ]
        
    def get_providers_by_capability(
        self,
        capability: str
    ) -> List[Provider[Any]]:
        """Get providers by capability."""
        return [
            prov for prov in self._providers.values()
            if capability in prov.metadata.capabilities
        ]
        
    async def reload_provider(
        self,
        name: str
    ) -> None:
        """Reload provider."""
        try:
            if name not in self._providers:
                raise ValueError(f"Provider {name} not found")
                
            provider = self._providers[name]
            await provider.reload()
            
        except Exception as e:
            self._logger.error(
                "Failed to reload provider",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    async def cleanup(self) -> None:
        """Cleanup all providers."""
        for name in list(self._providers.keys()):
            await self.unregister(name)
```

3. Implementar tipos comuns de provedores:

```python
class MemoryProvider(Provider[T]):
    """Provider for memory operations."""
    
    def __init__(
        self,
        metadata: ProviderMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._store = None
        
    @property
    def store(self) -> Optional[MemoryStore]:
        """Get provider store."""
        return self._store
        
    async def initialize(self) -> None:
        """Initialize memory provider."""
        await self._initialize_store()
        
    async def cleanup(self) -> None:
        """Cleanup memory provider."""
        if self._store is not None:
            await self._cleanup_store()
            
    @abstractmethod
    async def _initialize_store(self) -> None:
        """Initialize memory store."""
        pass
        
    @abstractmethod
    async def _cleanup_store(self) -> None:
        """Cleanup memory store."""
        pass

class StorageProvider(Provider[T]):
    """Provider for storage operations."""
    
    def __init__(
        self,
        metadata: ProviderMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._storage = None
        
    @property
    def storage(self) -> Optional[Storage]:
        """Get provider storage."""
        return self._storage
        
    async def initialize(self) -> None:
        """Initialize storage provider."""
        await self._initialize_storage()
        
    async def cleanup(self) -> None:
        """Cleanup storage provider."""
        if self._storage is not None:
            await self._cleanup_storage()
            
    @abstractmethod
    async def _initialize_storage(self) -> None:
        """Initialize storage."""
        pass
        
    @abstractmethod
    async def _cleanup_storage(self) -> None:
        """Cleanup storage."""
        pass
```

4. Implementar sistema de monitoramento:

```python
class ProviderMonitor:
    """Monitor for provider operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def record_operation(
        self,
        operation: str,
        provider_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record provider operation."""
        try:
            self._metrics.counter(
                "provider_operations",
                1,
                operation=operation,
                type=provider_type,
                success=str(success).lower(),
                **labels
            )
            
            if success:
                self._metrics.histogram(
                    "provider_duration",
                    duration,
                    operation=operation,
                    type=provider_type,
                    **labels
                )
                
        except Exception as e:
            self._logger.error(
                "Failed to record provider operation",
                extra={
                    "operation": operation,
                    "type": provider_type,
                    "success": success,
                    "duration": duration,
                    "labels": labels,
                    "error": str(e)
                }
            )
```

5. Migrar implementações existentes:
   - Converter provedores para nova interface
   - Atualizar gerenciamento de provedores
   - Implementar monitoramento específico

## Validação

```python
async def test_provider_system():
    # Setup
    manager = ProviderManager()
    monitor = ProviderMonitor()
    
    # Create memory provider
    memory_metadata = ProviderMetadata(
        name="test_memory",
        type=ProviderType.MEMORY,
        description="Test memory provider",
        version="1.0.0",
        capabilities=["store", "search"],
        labels={"env": "test"}
    )
    
    memory_config = MemoryConfig(
        name="test",
        enabled=True
    )
    
    memory_provider = TestMemoryProvider(
        memory_metadata,
        memory_config
    )
    
    # Create storage provider
    storage_metadata = ProviderMetadata(
        name="test_storage",
        type=ProviderType.STORAGE,
        description="Test storage provider",
        version="1.0.0",
        capabilities=["store", "retrieve"],
        labels={"env": "test"}
    )
    
    storage_config = StorageConfig(
        name="test",
        enabled=True
    )
    
    storage_provider = TestStorageProvider(
        storage_metadata,
        storage_config
    )
    
    # Register providers
    await manager.register(memory_provider)
    await manager.register(storage_provider)
    
    # Test operations
    providers = manager.get_providers_by_type(ProviderType.MEMORY)
    assert len(providers) == 1
    assert providers[0].metadata.name == "test_memory"
    
    providers = manager.get_providers_by_capability("store")
    assert len(providers) == 2
    
    # Test reload
    await manager.reload_provider("test_memory")
    
    # Test unregister
    await manager.unregister("test_storage")
    
    # Test monitoring
    await monitor.record_operation(
        "register",
        "memory",
        True,
        0.001,
        name="test_memory"
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_provider_system():
    # Restore legacy implementations
    shutil.copy("providers/base_legacy.py", "providers/base.py")
    shutil.copy("memory/providers/local_legacy.py", "memory/providers/local.py")
    
    # Cleanup new implementations
    os.remove("providers/base/base.py")
    os.remove("providers/base/manager.py")
    os.remove("providers/base/types.py")
    os.remove("providers/base/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de provedores
   - Interface consistente
   - Metadados unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas de provedor
   - Documentação completa

3. **Performance**:
   - Latência < 1ms por operação
   - Baixo consumo de memória
   - Carregamento eficiente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de provedores
- [ ] Implementação do gerenciamento de provedores
- [ ] Implementação dos tipos comuns
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R057: Unificação do Sistema de Busca e Recuperação

## Descrição

Padronizar os mecanismos de busca e recuperação em todo o framework, eliminando implementações redundantes e inconsistentes. O sistema atual apresenta diferentes abordagens para busca e recuperação de dados em vários módulos, dificultando a manutenção e a consistência.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R055: Consolidação do Sistema de Memória

## Estado Atual

Atualmente, a busca e recuperação de dados está implementada de forma inconsistente em diferentes módulos:

1. Em `memory/providers/local.py`:
```python
class LocalProvider:
    async def search(self, pattern: str) -> List[str]:
        return [key for key in self.entries.keys() 
                if key.startswith(pattern)]
```

2. Em `core/registry.py`:
```python
class ProviderRegistry:
    def find_provider(self, name: str) -> Optional[Provider]:
        for provider in self._providers:
            if provider.name == name:
                return provider
        return None
```

## Plano de Implementação

1. Criar interface unificada para busca e recuperação:

```python
from abc import ABC, abstractmethod
from typing import Any, AsyncIterator, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime

T = TypeVar("T")

@dataclass
class SearchResult(Generic[T]):
    id: str
    score: float
    data: T
    metadata: Optional[Dict[str, Any]] = None
    timestamp: datetime = datetime.now()

class SearchQuery:
    def __init__(
        self,
        query: str,
        filters: Optional[Dict[str, Any]] = None,
        sort: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ):
        self.query = query
        self.filters = filters or {}
        self.sort = sort or []
        self.limit = limit
        self.offset = offset

class SearchProvider(ABC, Generic[T]):
    @abstractmethod
    async def search(
        self,
        query: SearchQuery
    ) -> AsyncIterator[SearchResult[T]]:
        """Execute search query and return results."""
        pass

    @abstractmethod
    async def get(self, id: str) -> Optional[T]:
        """Get item by ID."""
        pass

    @abstractmethod
    async def exists(self, id: str) -> bool:
        """Check if item exists."""
        pass
```

2. Implementar provider base com funcionalidades comuns:

```python
class BaseSearchProvider(SearchProvider[T]):
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._lock = asyncio.Lock()

    async def exists(self, id: str) -> bool:
        result = await self.get(id)
        return result is not None

    async def _record_operation(
        self,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        self._metrics.counter(
            f"search_provider_{operation}",
            1,
            success=str(success).lower(),
            **labels
        )

    def _calculate_score(
        self,
        item: T,
        query: str,
        **context: Any
    ) -> float:
        """Calculate relevance score for item."""
        # Implementar lógica de scoring
        return 1.0
```

3. Implementar providers específicos:

```python
class MemorySearchProvider(BaseSearchProvider[T]):
    def __init__(self, store: MemoryStore[T]):
        super().__init__()
        self._store = store

    async def search(
        self,
        query: SearchQuery
    ) -> AsyncIterator[SearchResult[T]]:
        async with self._lock:
            async for key in self._store.scan(query.query):
                entry = await self._store.get(key)
                if entry is None:
                    continue

                if not self._matches_filters(entry, query.filters):
                    continue

                score = self._calculate_score(entry.value, query.query)
                yield SearchResult(
                    id=key,
                    score=score,
                    data=entry.value,
                    metadata=entry.metadata,
                    timestamp=entry.created_at
                )

    def _matches_filters(
        self,
        entry: MemoryEntry[T],
        filters: Dict[str, Any]
    ) -> bool:
        for key, value in filters.items():
            if key not in entry.metadata:
                return False
            if entry.metadata[key] != value:
                return False
        return True

    async def get(self, id: str) -> Optional[T]:
        entry = await self._store.get(id)
        if entry is None:
            await self._record_operation("get", False, reason="not_found")
            return None

        await self._record_operation("get", True)
        return entry.value
```

4. Implementar gerenciador de busca:

```python
class SearchManager(Generic[T]):
    def __init__(self):
        self._providers: Dict[str, SearchProvider[T]] = {}
        self._metrics = MetricsManager.get_instance()

    def register_provider(
        self,
        name: str,
        provider: SearchProvider[T]
    ) -> None:
        self._providers[name] = provider

    async def search(
        self,
        query: Union[str, SearchQuery],
        provider: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterator[SearchResult[T]]:
        if isinstance(query, str):
            query = SearchQuery(query, **kwargs)

        if provider:
            if provider not in self._providers:
                raise ValueError(f"Provider not found: {provider}")
            async for result in self._providers[provider].search(query):
                yield result
        else:
            # Search across all providers
            results: List[SearchResult[T]] = []
            for p in self._providers.values():
                async for result in p.search(query):
                    results.append(result)

            # Sort by score
            results.sort(key=lambda r: r.score, reverse=True)

            # Apply limit and offset
            start = query.offset or 0
            end = start + query.limit if query.limit else None
            for result in results[start:end]:
                yield result

    async def get(
        self,
        id: str,
        provider: Optional[str] = None
    ) -> Optional[T]:
        if provider:
            if provider not in self._providers:
                raise ValueError(f"Provider not found: {provider}")
            return await self._providers[provider].get(id)

        # Try all providers
        for p in self._providers.values():
            result = await p.get(id)
            if result is not None:
                return result

        return None
```

5. Migrar implementações existentes:
   - Atualizar `memory/providers/local.py`
   - Atualizar `core/registry.py`
   - Criar novos providers conforme necessário

## Validação

```python
async def test_search_system():
    # Setup
    manager = SearchManager[str]()
    store = LocalMemoryStore[str]()
    provider = MemorySearchProvider(store)
    manager.register_provider("memory", provider)

    # Test basic search
    await store.set("key1", "value1", metadata={"type": "test"})
    await store.set("key2", "value2", metadata={"type": "test"})
    await store.set("other", "value3", metadata={"type": "other"})

    results = []
    async for result in manager.search(
        SearchQuery(
            query="key",
            filters={"type": "test"}
        )
    ):
        results.append(result)

    assert len(results) == 2
    assert all(r.data.startswith("value") for r in results)
    assert all(r.score > 0 for r in results)

    # Test get by ID
    value = await manager.get("key1")
    assert value == "value1"

    # Test non-existent ID
    value = await manager.get("invalid")
    assert value is None
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_search_system():
    # Restore legacy implementations
    shutil.copy("memory/providers/local_legacy.py", "memory/providers/local.py")
    shutil.copy("core/registry_legacy.py", "core/registry.py")

    # Cleanup new implementations
    os.remove("core/search/provider.py")
    os.remove("core/search/manager.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de busca
   - Interface consistente
   - Providers unificados

2. **Desempenho**:
   - Latência < 10ms para buscas simples
   - Throughput > 1k ops/s
   - Uso eficiente de recursos

3. **Qualidade**:
   - 100% de cobertura de testes
   - Resultados relevantes
   - Ordenação consistente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface SearchProvider
- [ ] Implementação do BaseSearchProvider
- [ ] Implementação dos providers específicos
- [ ] Implementação do SearchManager
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
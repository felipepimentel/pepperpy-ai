# ConsolidaÃ§Ã£o do Sistema de Cache

**Task ID**: TASK-007
**Requirement**: R022
**Status**: ğŸ“‹ To Do
**Created**: 2024-02-22
**Updated**: 2024-02-22

## Description

Implementar um sistema de cache unificado para todo o projeto, consolidando as diferentes implementaÃ§Ãµes em uma soluÃ§Ã£o centralizada e eficiente. O sistema deve fornecer polÃ­ticas de cache configurÃ¡veis, mÃ©tricas centralizadas e suporte a diferentes backends de armazenamento.

## Dependencies

- R020 (UnificaÃ§Ã£o do Sistema de ConfiguraÃ§Ã£o)
- R015 (ConsolidaÃ§Ã£o do Sistema de MÃ©tricas)

## Current State

```python
# Cache implementado de forma dispersa:
- core/client.py: _cache_enabled e _cache_store
- core/memory/cache.py: implementaÃ§Ã£o bÃ¡sica
- providers/cache/: implementaÃ§Ãµes especÃ­ficas
# Falta de polÃ­ticas de cache unificadas
# Sem mÃ©tricas centralizadas de cache
# InconsistÃªncia no tratamento de invalidaÃ§Ã£o
```

## Implementation Plan

1. Criar estrutura base do sistema de cache:
```
caching/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ base.py
â”œâ”€â”€ types.py
â”œâ”€â”€ errors.py
â”œâ”€â”€ policies/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py
â”‚   â”œâ”€â”€ lru.py
â”‚   â””â”€â”€ ttl.py
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py
â”‚   â”œâ”€â”€ memory.py
â”‚   â””â”€â”€ redis.py
â”œâ”€â”€ metrics/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ collector.py
â”‚   â””â”€â”€ exporter.py
â””â”€â”€ invalidation/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ strategy.py
    â””â”€â”€ patterns.py
```

2. Implementar interface base de cache:
```python
from abc import ABC, abstractmethod
from typing import Any, Optional, Dict

class CacheBackend(ABC):
    @abstractmethod
    def get(self, key: str) -> Optional[Any]:
        pass
        
    @abstractmethod
    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        pass
        
    @abstractmethod
    def delete(self, key: str) -> bool:
        pass
        
    @abstractmethod
    def clear(self) -> bool:
        pass
```

3. Implementar polÃ­ticas de cache:
```python
class CachePolicy(ABC):
    @abstractmethod
    def should_cache(self, key: str, value: Any) -> bool:
        pass
        
    @abstractmethod
    def should_evict(self, key: str) -> bool:
        pass

class LRUPolicy(CachePolicy):
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self._usage = {}
        
    def should_cache(self, key: str, value: Any) -> bool:
        return len(self._usage) < self.max_size
        
    def should_evict(self, key: str) -> bool:
        return key == min(self._usage.items(), key=lambda x: x[1])[0]
```

4. Implementar sistema de mÃ©tricas:
```python
class CacheMetrics:
    def __init__(self):
        self.hits = 0
        self.misses = 0
        self.evictions = 0
        
    def track_hit(self):
        self.hits += 1
        
    def track_miss(self):
        self.misses += 1
        
    def track_eviction(self):
        self.evictions += 1
        
    def get_hit_ratio(self) -> float:
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0
```

5. Implementar sistema de invalidaÃ§Ã£o:
```python
class InvalidationStrategy(ABC):
    @abstractmethod
    def should_invalidate(self, key: str, metadata: Dict[str, Any]) -> bool:
        pass

class TTLInvalidation(InvalidationStrategy):
    def should_invalidate(self, key: str, metadata: Dict[str, Any]) -> bool:
        if 'ttl' not in metadata:
            return False
        return time.time() > metadata['created_at'] + metadata['ttl']
```

## Validation

```python
def test_cache_system():
    # Verificar backend de memÃ³ria
    from pepperpy.caching.stores import MemoryStore
    store = MemoryStore()
    assert store.set("key", "value") is True
    assert store.get("key") == "value"
    
    # Verificar polÃ­tica LRU
    from pepperpy.caching.policies import LRUPolicy
    policy = LRUPolicy(max_size=2)
    assert policy.should_cache("key1", "value1") is True
    assert policy.should_cache("key2", "value2") is True
    assert policy.should_cache("key3", "value3") is False
    
    # Verificar mÃ©tricas
    from pepperpy.caching.metrics import CacheMetrics
    metrics = CacheMetrics()
    metrics.track_hit()
    metrics.track_miss()
    assert metrics.get_hit_ratio() == 0.5
    
    # Verificar invalidaÃ§Ã£o
    from pepperpy.caching.invalidation import TTLInvalidation
    invalidator = TTLInvalidation()
    assert invalidator.should_invalidate("key", {"ttl": 60, "created_at": time.time() - 61}) is True
```

## Rollback Plan

1. Backup do estado atual:
   - Exportar dados de cache existentes
   - Salvar configuraÃ§Ãµes de cache
   - Backup de mÃ©tricas

2. Procedimento de rollback:
   ```python
   def rollback():
       # Desativar novo sistema de cache
       disable_unified_cache()
       
       # Restaurar implementaÃ§Ãµes antigas
       restore_legacy_cache_implementations()
       
       # Importar dados de backup
       import_cache_backup()
   ```

3. ValidaÃ§Ã£o pÃ³s-rollback:
   - Verificar funcionamento dos caches antigos
   - Validar integridade dos dados
   - Confirmar mÃ©tricas de performance

## Success Metrics

1. Performance:
   - Hit ratio > 80%
   - LatÃªncia mÃ©dia < 5ms
   - Uso de memÃ³ria controlado
   - Zero memory leaks

2. Funcionalidade:
   - 100% dos caches migrados
   - Todas as polÃ­ticas implementadas
   - Sistema de mÃ©tricas completo

3. Qualidade:
   - 100% de cobertura de testes
   - Zero regressÃµes
   - DocumentaÃ§Ã£o completa

## Progress Updates

- [x] 2024-02-22: Requirement criado e documentado
- [ ] ImplementaÃ§Ã£o da estrutura base
- [ ] Desenvolvimento dos backends
- [ ] ImplementaÃ§Ã£o das polÃ­ticas
- [ ] Sistema de mÃ©tricas
- [ ] Sistema de invalidaÃ§Ã£o
- [ ] Testes e validaÃ§Ã£o
- [ ] DocumentaÃ§Ã£o final 
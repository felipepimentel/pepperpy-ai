# R089: Padroniza√ß√£o do Sistema de Limpeza de Recursos

## Descri√ß√£o

Implementar um sistema unificado de limpeza de recursos que garanta a libera√ß√£o adequada e oportuna de recursos do sistema. O sistema deve gerenciar o ciclo de vida dos recursos, implementar estrat√©gias de limpeza autom√°tica e garantir que recursos n√£o utilizados sejam liberados de forma apropriada.

## Depend√™ncias

- R080: Padroniza√ß√£o do Sistema de Recursos
- R087: Padroniza√ß√£o do Sistema de Monitoramento de Recursos
- R088: Padroniza√ß√£o do Sistema de Recupera√ß√£o de Recursos

## Estado Atual

üìã To Do

## Objetivos

1. Criar sistema unificado de limpeza de recursos
2. Implementar estrat√©gias de limpeza autom√°tica
3. Desenvolver mecanismos de detec√ß√£o de recursos inativos
4. Garantir libera√ß√£o segura de recursos
5. Implementar monitoramento do processo de limpeza

## Plano de Implementa√ß√£o

1. Implementar sistema base de limpeza:

```python
from typing import Any, Dict, List, Optional, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
import asyncio
import weakref

@dataclass
class CleanupConfig:
    """Configuration for resource cleanup."""
    
    idle_timeout: float = 300.0  # 5 minutes
    check_interval: float = 60.0  # 1 minute
    batch_size: int = 50
    force_cleanup_threshold: int = 1000

class ResourceCleaner:
    """Cleaner for system resources."""
    
    def __init__(
        self,
        config: CleanupConfig
    ):
        self._config = config
        self._resource_manager = ResourceManager.get_instance()
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        self._cleanup_task: Optional[asyncio.Task] = None
        self._resources_to_clean: Set[str] = set()
        
    async def start(self) -> None:
        """Start the resource cleaner."""
        if self._cleanup_task:
            return
            
        self._cleanup_task = asyncio.create_task(
            self._cleanup_loop()
        )
        
    async def stop(self) -> None:
        """Stop the resource cleaner."""
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            self._cleanup_task = None
            
    async def schedule_cleanup(
        self,
        resource_id: str
    ) -> None:
        """Schedule a resource for cleanup."""
        self._resources_to_clean.add(resource_id)
        
        if len(self._resources_to_clean) >= self._config.force_cleanup_threshold:
            await self._cleanup_resources()
            
    async def _cleanup_loop(self) -> None:
        """Main cleanup loop."""
        while True:
            try:
                await self._cleanup_resources()
            except Exception as e:
                self._logger.error(
                    "Cleanup loop failed",
                    extra={"error": str(e)}
                )
                
            await asyncio.sleep(self._config.check_interval)
            
    async def _cleanup_resources(self) -> None:
        """Clean up resources."""
        if not self._resources_to_clean:
            return
            
        resources = list(self._resources_to_clean)[:self._config.batch_size]
        self._resources_to_clean.difference_update(resources)
        
        start = time.perf_counter()
        cleaned = 0
        failed = 0
        
        for resource_id in resources:
            try:
                resource = await self._resource_manager.get_resource(resource_id)
                
                if not resource:
                    continue
                    
                if self._should_cleanup(resource):
                    await self._cleanup_resource(resource)
                    cleaned += 1
                    
            except Exception as e:
                failed += 1
                self._logger.error(
                    "Failed to clean up resource",
                    extra={
                        "resource_id": resource_id,
                        "error": str(e)
                    }
                )
                
        duration = time.perf_counter() - start
        
        self._metrics.histogram(
            "cleanup_duration",
            duration,
            batch_size=str(len(resources))
        )
        
        self._metrics.counter(
            "cleanup_operations",
            cleaned,
            result="success"
        )
        
        self._metrics.counter(
            "cleanup_operations",
            failed,
            result="failure"
        )
        
    def _should_cleanup(
        self,
        resource: Any
    ) -> bool:
        """Check if resource should be cleaned up."""
        if not hasattr(resource, "last_used"):
            return False
            
        idle_time = (
            datetime.now() - resource.last_used
        ).total_seconds()
        
        return idle_time >= self._config.idle_timeout
        
    async def _cleanup_resource(
        self,
        resource: Any
    ) -> None:
        """Clean up a single resource."""
        resource_id = getattr(resource, "id", "unknown")
        
        try:
            start = time.perf_counter()
            
            if hasattr(resource, "cleanup"):
                await resource.cleanup()
                
            duration = time.perf_counter() - start
            
            self._metrics.histogram(
                "resource_cleanup_duration",
                duration,
                resource_type=type(resource).__name__
            )
            
            self._logger.info(
                "Resource cleaned up successfully",
                extra={
                    "resource_id": resource_id,
                    "duration": duration
                }
            )
            
        except Exception as e:
            self._metrics.counter(
                "resource_cleanup_errors",
                1,
                resource_type=type(resource).__name__,
                error_type=type(e).__name__
            )
            
            raise ResourceCleanupError(
                f"Failed to clean up resource {resource_id}: {e}"
            ) from e
```

2. Implementar sistema de detec√ß√£o de recursos inativos:

```python
class InactiveResourceDetector:
    """Detector for inactive resources."""
    
    def __init__(
        self,
        config: CleanupConfig
    ):
        self._config = config
        self._resource_manager = ResourceManager.get_instance()
        self._cleaner = ResourceCleaner.get_instance()
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def check_resources(self) -> None:
        """Check for inactive resources."""
        resources = await self._resource_manager.list_resources()
        
        for resource in resources:
            if self._is_inactive(resource):
                await self._cleaner.schedule_cleanup(resource.id)
                
                self._metrics.counter(
                    "inactive_resources_detected",
                    1,
                    resource_type=type(resource).__name__
                )
                
    def _is_inactive(
        self,
        resource: Any
    ) -> bool:
        """Check if resource is inactive."""
        if not hasattr(resource, "last_used"):
            return False
            
        if not hasattr(resource, "state"):
            return False
            
        idle_time = (
            datetime.now() - resource.last_used
        ).total_seconds()
        
        return (
            idle_time >= self._config.idle_timeout and
            resource.state not in ["cleaning", "cleaned"]
        )
```

## Crit√©rios de Aceita√ß√£o

1. Sistema de limpeza implementado e funcional
2. Detec√ß√£o de recursos inativos funcionando
3. Limpeza autom√°tica sendo executada conforme configurado
4. M√©tricas de limpeza sendo coletadas
5. Documenta√ß√£o completa e atualizada
6. Testes unit√°rios e de integra√ß√£o implementados
7. Zero regress√µes nos sistemas existentes 
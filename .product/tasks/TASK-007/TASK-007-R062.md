# R062: Padronização de Fábricas e Registros

## Descrição

Unificar e padronizar o sistema de fábricas e registros em todo o framework, estabelecendo uma interface consistente para criação e gerenciamento de componentes. O sistema atual possui diferentes implementações de fábricas e registros espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, as fábricas e registros estão distribuídos em vários módulos:

1. Em `core/factory.py`:
```python
class ComponentFactory:
    """Factory for creating components."""
    
    def __init__(self):
        self._types = {}
        
    def register_type(
        self,
        name: str,
        component_type: Type[Any]
    ) -> None:
        """Register a component type."""
        if name in self._types:
            raise ValueError(f"Type already registered: {name}")
        self._types[name] = component_type
        
    def create(
        self,
        name: str,
        **options: Any
    ) -> Any:
        """Create a component."""
        if name not in self._types:
            raise ValueError(f"Type not found: {name}")
        return self._types[name](**options)
```

2. Em `core/registry.py`:
```python
class ComponentRegistry:
    """Registry for components."""
    
    def __init__(self):
        self._components = {}
        
    def register(
        self,
        name: str,
        component: Any
    ) -> None:
        """Register a component."""
        if name in self._components:
            raise ValueError(f"Component already registered: {name}")
        self._components[name] = component
        
    def get(
        self,
        name: str
    ) -> Any:
        """Get a component."""
        if name not in self._components:
            raise ValueError(f"Component not found: {name}")
        return self._components[name]
```

## Plano de Implementação

1. Criar sistema base de fábricas:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar
from dataclasses import dataclass
from datetime import datetime

T = TypeVar("T")

@dataclass
class ComponentMetadata:
    """Metadata for components."""
    name: str
    version: str
    description: str
    dependencies: List[str]
    options: Dict[str, Any]

class ComponentFactory(ABC, Generic[T]):
    """Base class for component factories."""
    
    @abstractmethod
    def create(
        self,
        metadata: ComponentMetadata,
        **options: Any
    ) -> T:
        """Create a component."""
        pass
    
    @abstractmethod
    def validate(
        self,
        component: T
    ) -> List[str]:
        """Validate component."""
        pass
    
    @abstractmethod
    def cleanup(self) -> None:
        """Clean up factory resources."""
        pass
```

2. Implementar sistema de registro unificado:

```python
class UnifiedRegistry:
    """Unified registry for components and factories."""
    
    def __init__(self):
        self._factories: Dict[str, Dict[str, ComponentFactory]] = {}
        self._components: Dict[str, Dict[str, Any]] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_factory(
        self,
        component_type: str,
        version: str,
        factory: ComponentFactory
    ) -> None:
        """Register a component factory."""
        if component_type not in self._factories:
            self._factories[component_type] = {}
        self._factories[component_type][version] = factory
        
    def register_component(
        self,
        component_type: str,
        version: str,
        component: Any
    ) -> None:
        """Register a component instance."""
        if component_type not in self._components:
            self._components[component_type] = {}
        self._components[component_type][version] = component
        
    def create_component(
        self,
        component_type: str,
        version: Optional[str] = None,
        **options: Any
    ) -> Any:
        """Create a component using factory."""
        if component_type not in self._factories:
            raise ValueError(f"Factory not found: {component_type}")
            
        factories = self._factories[component_type]
        if not version:
            # Get latest version
            version = max(factories.keys())
            
        if version not in factories:
            raise ValueError(f"Version not found: {version}")
            
        factory = factories[version]
        
        metadata = ComponentMetadata(
            name=component_type,
            version=version,
            description=options.get("description", ""),
            dependencies=options.get("dependencies", []),
            options=options
        )
        
        try:
            component = factory.create(metadata, **options)
            
            self._metrics.counter(
                "component_creations",
                1,
                component_type=component_type,
                success="true"
            )
            
            return component
            
        except Exception as e:
            self._metrics.counter(
                "component_creations",
                1,
                component_type=component_type,
                success="false"
            )
            
            self._logger.error(
                "Component creation failed",
                extra={
                    "component_type": component_type,
                    "error": str(e)
                }
            )
            
            raise
            
    def get_component(
        self,
        component_type: str,
        version: Optional[str] = None
    ) -> Any:
        """Get a registered component instance."""
        if component_type not in self._components:
            raise ValueError(f"Component not found: {component_type}")
            
        components = self._components[component_type]
        if not version:
            # Get latest version
            version = max(components.keys())
            
        if version not in components:
            raise ValueError(f"Version not found: {version}")
            
        return components[version]
        
    def cleanup(self) -> None:
        """Clean up all factories."""
        for factories in self._factories.values():
            for factory in factories.values():
                try:
                    factory.cleanup()
                except Exception as e:
                    self._logger.error(
                        "Factory cleanup failed",
                        extra={"error": str(e)}
                    )
```

3. Implementar fábricas específicas:

```python
class MemoryFactory(ComponentFactory[Memory]):
    """Factory for memory components."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    def create(
        self,
        metadata: ComponentMetadata,
        **options: Any
    ) -> Memory:
        """Create a memory component."""
        memory_type = options.get("memory_type", "local")
        
        if memory_type == "local":
            return LocalMemory(**options)
        elif memory_type == "redis":
            return RedisMemory(**options)
        else:
            raise ValueError(f"Invalid memory type: {memory_type}")
            
    def validate(
        self,
        component: Memory
    ) -> List[str]:
        """Validate memory component."""
        errors = []
        
        try:
            # Validate component
            if not isinstance(component, Memory):
                errors.append("Invalid component type")
                
            # Validate configuration
            if hasattr(component, "validate"):
                errors.extend(component.validate())
                
        except Exception as e:
            errors.append(f"Validation failed: {e}")
            
        return errors
        
    def cleanup(self) -> None:
        """Clean up factory resources."""
        pass

class ProcessorFactory(ComponentFactory[Processor]):
    """Factory for processor components."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    def create(
        self,
        metadata: ComponentMetadata,
        **options: Any
    ) -> Processor:
        """Create a processor component."""
        processor_type = options.get("processor_type", "text")
        
        if processor_type == "text":
            return TextProcessor(**options)
        elif processor_type == "code":
            return CodeProcessor(**options)
        else:
            raise ValueError(f"Invalid processor type: {processor_type}")
            
    def validate(
        self,
        component: Processor
    ) -> List[str]:
        """Validate processor component."""
        errors = []
        
        try:
            # Validate component
            if not isinstance(component, Processor):
                errors.append("Invalid component type")
                
            # Validate configuration
            if hasattr(component, "validate"):
                errors.extend(component.validate())
                
        except Exception as e:
            errors.append(f"Validation failed: {e}")
            
        return errors
        
    def cleanup(self) -> None:
        """Clean up factory resources."""
        pass
```

4. Implementar sistema de monitoramento:

```python
class FactoryMonitor:
    """Monitor for factories and registries."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_creation(
        self,
        component_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record component creation."""
        self._metrics.counter(
            "factory_operations",
            1,
            operation="create",
            component_type=component_type,
            success=str(success).lower(),
            **labels
        )
        
    async def record_registration(
        self,
        component_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record component registration."""
        self._metrics.counter(
            "factory_operations",
            1,
            operation="register",
            component_type=component_type,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/factory.py`
   - Atualizar `core/registry.py`
   - Criar novas fábricas conforme necessário

## Validação

```python
async def test_factory_system():
    # Setup
    registry = UnifiedRegistry()
    monitor = FactoryMonitor()
    
    # Register factories
    memory_factory = MemoryFactory()
    processor_factory = ProcessorFactory()
    
    registry.register_factory("memory", "1.0.0", memory_factory)
    registry.register_factory("processor", "1.0.0", processor_factory)
    
    # Test component creation
    memory = registry.create_component(
        "memory",
        memory_type="local",
        capacity=1000
    )
    
    assert isinstance(memory, Memory)
    assert memory.capacity == 1000
    
    processor = registry.create_component(
        "processor",
        processor_type="text",
        max_length=100
    )
    
    assert isinstance(processor, Processor)
    assert processor.max_length == 100
    
    # Test validation
    errors = memory_factory.validate(memory)
    assert not errors
    
    errors = processor_factory.validate(processor)
    assert not errors
    
    # Test monitoring
    await monitor.record_creation("memory", True)
    await monitor.record_registration("processor", True)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_factory_system():
    # Restore legacy implementations
    shutil.copy("core/factory_legacy.py", "core/factory.py")
    shutil.copy("core/registry_legacy.py", "core/registry.py")
    
    # Cleanup new implementations
    os.remove("core/factory/base.py")
    os.remove("core/factory/unified.py")
    os.remove("core/factory/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de fábricas
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de criação não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para criação
   - Latência < 10ms para registro
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de fábricas
- [ ] Implementação do registro unificado
- [ ] Implementação das fábricas específicas
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# Padroniza√ß√£o do Sistema de Gerenciamento de Estado

**Task ID**: TASK-007
**Requirement**: R027
**Status**: üìã To Do
**Created**: 2024-02-22
**Updated**: 2024-02-22

## Description

Implementar um sistema padronizado de gerenciamento de estado que unifique as transi√ß√µes, valida√ß√µes e monitoramento de estados em todos os componentes do sistema. O sistema deve garantir consist√™ncia e previsibilidade no comportamento dos componentes.

## Dependencies

- R019 (Padroniza√ß√£o de Lifecycle Management)
- R024 (Consolida√ß√£o do Sistema de Observabilidade)
- R026 (Consolida√ß√£o do Sistema de Resource Management)

## Current State

```python
# Estados inconsistentes entre componentes:
- core/client.py: _initialized booleano
- core/config/unified.py: ConfigState enum
- core/types.py: ComponentState enum
# Transi√ß√µes de estado n√£o padronizadas
# Falta de valida√ß√£o de estado
# Aus√™ncia de monitoramento de transi√ß√µes
# Inconsist√™ncia em tratamento de erros
```

## Implementation Plan

1. Criar estrutura base do sistema de estados:
```
state/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ base.py
‚îú‚îÄ‚îÄ types.py
‚îú‚îÄ‚îÄ errors.py
‚îú‚îÄ‚îÄ machine/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ transitions.py
‚îú‚îÄ‚îÄ validation/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ validators.py
‚îî‚îÄ‚îÄ monitoring/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ base.py
    ‚îî‚îÄ‚îÄ metrics.py
```

2. Implementar m√°quina de estados unificada:
```python
from enum import Enum
from typing import Dict, Set, Optional, Any
from dataclasses import dataclass

class State(Enum):
    UNREGISTERED = "unregistered"
    REGISTERED = "registered"
    INITIALIZING = "initializing"
    READY = "ready"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"
    TERMINATED = "terminated"

@dataclass
class Transition:
    from_state: State
    to_state: State
    validation: Optional[callable] = None
    before: Optional[callable] = None
    after: Optional[callable] = None

class StateMachine:
    def __init__(self):
        self.current_state = State.UNREGISTERED
        self.transitions: Dict[State, Dict[State, Transition]] = {}
        self.metadata: Dict[str, Any] = {}
        
    def add_transition(self, transition: Transition):
        if transition.from_state not in self.transitions:
            self.transitions[transition.from_state] = {}
        self.transitions[transition.from_state][transition.to_state] = transition
        
    def can_transition(self, to_state: State) -> bool:
        if self.current_state not in self.transitions:
            return False
        return to_state in self.transitions[self.current_state]
        
    def transition(self, to_state: State) -> bool:
        if not self.can_transition(to_state):
            return False
            
        transition = self.transitions[self.current_state][to_state]
        
        if transition.validation and not transition.validation(self):
            return False
            
        if transition.before:
            transition.before(self)
            
        self.current_state = to_state
        
        if transition.after:
            transition.after(self)
            
        return True
```

3. Implementar sistema de valida√ß√£o:
```python
from abc import ABC, abstractmethod

class StateValidator(ABC):
    @abstractmethod
    def validate(self, machine: StateMachine) -> bool:
        pass

class TransitionValidator:
    def __init__(self):
        self.validators: Dict[State, StateValidator] = {}
        
    def register_validator(self, state: State, validator: StateValidator):
        self.validators[state] = validator
        
    def validate(self, machine: StateMachine, to_state: State) -> bool:
        if to_state in self.validators:
            return self.validators[to_state].validate(machine)
        return True
```

4. Implementar monitoramento de estados:
```python
from prometheus_client import Counter, Gauge, Histogram
from datetime import datetime

class StateMetrics:
    def __init__(self):
        self.state_changes = Counter(
            'pepperpy_state_changes_total',
            'Total number of state changes',
            ['from_state', 'to_state']
        )
        self.state_duration = Histogram(
            'pepperpy_state_duration_seconds',
            'Time spent in each state',
            ['state']
        )
        self.current_states = Gauge(
            'pepperpy_current_states',
            'Number of components in each state',
            ['state']
        )
        self.transition_errors = Counter(
            'pepperpy_transition_errors_total',
            'Total number of transition errors',
            ['from_state', 'to_state']
        )
```

5. Implementar sistema de eventos:
```python
from typing import Callable, List
from dataclasses import dataclass

@dataclass
class StateEvent:
    state: State
    timestamp: datetime
    metadata: Dict[str, Any]

class StateEventEmitter:
    def __init__(self):
        self.listeners: Dict[State, List[Callable[[StateEvent], None]]] = {}
        
    def on(self, state: State, listener: Callable[[StateEvent], None]):
        if state not in self.listeners:
            self.listeners[state] = []
        self.listeners[state].append(listener)
        
    def emit(self, event: StateEvent):
        if event.state in self.listeners:
            for listener in self.listeners[event.state]:
                listener(event)
```

## Validation

```python
def test_state_system():
    # Verificar m√°quina de estados
    from pepperpy.state.machine import StateMachine, State, Transition
    machine = StateMachine()
    machine.add_transition(Transition(State.UNREGISTERED, State.REGISTERED))
    assert machine.transition(State.REGISTERED) is True
    assert machine.current_state == State.REGISTERED
    
    # Verificar valida√ß√£o
    from pepperpy.state.validation import StateValidator, TransitionValidator
    
    class ReadyValidator(StateValidator):
        def validate(self, machine: StateMachine) -> bool:
            return machine.current_state == State.REGISTERED
            
    validator = TransitionValidator()
    validator.register_validator(State.READY, ReadyValidator())
    assert validator.validate(machine, State.READY) is True
    
    # Verificar m√©tricas
    from pepperpy.state.monitoring import StateMetrics
    metrics = StateMetrics()
    metrics.state_changes.labels(
        from_state="unregistered",
        to_state="registered"
    ).inc()
    assert metrics.state_changes._value.get() > 0
    
    # Verificar eventos
    from pepperpy.state.events import StateEventEmitter, StateEvent
    emitter = StateEventEmitter()
    events = []
    emitter.on(State.REGISTERED, lambda e: events.append(e))
    emitter.emit(StateEvent(State.REGISTERED, datetime.now(), {}))
    assert len(events) == 1
```

## Rollback Plan

1. Backup do estado atual:
   - Mapear estados atuais
   - Exportar m√©tricas de transi√ß√µes
   - Backup de configura√ß√µes

2. Procedimento de rollback:
   ```python
   def rollback():
       # Desativar novo sistema
       disable_state_management()
       
       # Restaurar estados originais
       restore_legacy_states()
       
       # Limpar m√©tricas
       cleanup_state_metrics()
   ```

3. Valida√ß√£o p√≥s-rollback:
   - Verificar estados dos componentes
   - Validar transi√ß√µes
   - Confirmar m√©tricas antigas

## Success Metrics

1. Consist√™ncia:
   - 100% dos componentes usando o novo sistema
   - Zero inconsist√™ncias de estado
   - Todas as transi√ß√µes validadas
   - Estados monitorados em tempo real

2. Performance:
   - Tempo de transi√ß√£o < 1ms
   - Overhead de valida√ß√£o < 0.1ms
   - Zero impacto em runtime
   - Lat√™ncia de eventos < 5ms

3. Qualidade:
   - 100% de cobertura de testes
   - Zero regress√µes
   - Documenta√ß√£o completa
   - M√©tricas detalhadas

## Progress Updates

- [x] 2024-02-22: Requirement criado e documentado
- [ ] Implementa√ß√£o da estrutura base
- [ ] M√°quina de estados
- [ ] Sistema de valida√ß√£o
- [ ] Sistema de m√©tricas
- [ ] Sistema de eventos
- [ ] Testes e valida√ß√£o
- [ ] Documenta√ß√£o final 
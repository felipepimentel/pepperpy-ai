# R076: Unificação do Sistema de Rate Limiting

## Descrição

Unificar e padronizar o sistema de rate limiting em todo o framework, estabelecendo uma abordagem consistente para controle de taxa de requisições e operações. O sistema atual possui diferentes implementações de rate limiting espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R068: Consolidação do Sistema de Processamento Assíncrono
- R073: Padronização do Sistema de Configuração
- R074: Consolidação do Sistema de Cache

## Estado Atual

Atualmente, o rate limiting está distribuído em vários módulos:

1. Em `core/limiter.py`:
```python
class TokenBucket:
    """Simple token bucket limiter."""
    
    def __init__(
        self,
        rate: float,
        capacity: int
    ):
        self.rate = rate
        self.capacity = capacity
        self.tokens = capacity
        self.last_update = time.time()
        
    async def acquire(self) -> bool:
        """Acquire a token."""
        now = time.time()
        elapsed = now - self.last_update
        self.tokens = min(
            self.capacity,
            self.tokens + elapsed * self.rate
        )
        
        if self.tokens >= 1:
            self.tokens -= 1
            self.last_update = now
            return True
            
        return False
```

2. Em `agents/limiter.py`:
```python
class RateLimiter:
    """Rate limiter for agent operations."""
    
    def __init__(self, redis_url: str):
        self._redis = Redis.from_url(redis_url)
        
    async def check_limit(
        self,
        key: str,
        limit: int,
        window: int
    ) -> bool:
        """Check rate limit."""
        current = await self._redis.incr(key)
        if current == 1:
            await self._redis.expire(key, window)
        return current <= limit
```

## Plano de Implementação

1. Criar sistema base de rate limiting:

```python
from typing import Any, Dict, Optional, Type, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import time
import asyncio

T = TypeVar("T")

class LimitStrategy(Enum):
    """Rate limiting strategies."""
    
    TOKEN_BUCKET = "token_bucket"
    FIXED_WINDOW = "fixed_window"
    SLIDING_WINDOW = "sliding_window"
    LEAKY_BUCKET = "leaky_bucket"

@dataclass
class LimitConfig:
    """Configuration for rate limiting."""
    
    rate: float
    capacity: int
    window: Optional[int] = None
    strategy: LimitStrategy = LimitStrategy.TOKEN_BUCKET
    distributed: bool = False
    
    def validate(self) -> None:
        """Validate configuration."""
        if self.rate <= 0:
            raise ValueError("Rate must be positive")
        if self.capacity <= 0:
            raise ValueError("Capacity must be positive")
        if self.window is not None and self.window <= 0:
            raise ValueError("Window must be positive")
        if self.strategy in {LimitStrategy.FIXED_WINDOW, LimitStrategy.SLIDING_WINDOW}:
            if self.window is None:
                raise ValueError("Window required for window-based strategies")

class LimitKey:
    """Rate limit key with metadata."""
    
    def __init__(
        self,
        namespace: str,
        key: str,
        version: Optional[str] = None
    ):
        self.namespace = namespace
        self.key = key
        self.version = version
        
    def __str__(self) -> str:
        """Get string representation."""
        parts = [self.namespace, self.key]
        if self.version:
            parts.append(self.version)
        return ":".join(parts)
        
    @classmethod
    def from_str(cls, key: str) -> "LimitKey":
        """Create from string."""
        parts = key.split(":")
        return cls(
            namespace=parts[0],
            key=parts[1],
            version=parts[2] if len(parts) > 2 else None
        )

class BaseLimiter:
    """Base class for rate limiters."""
    
    def __init__(self, config: LimitConfig):
        self.config = config
        
    @property
    def strategy(self) -> LimitStrategy:
        """Get limiter strategy."""
        return self.config.strategy
        
    async def acquire(self, key: LimitKey) -> bool:
        """Acquire permission."""
        raise NotImplementedError
        
    async def release(self, key: LimitKey) -> None:
        """Release permission."""
        raise NotImplementedError
```

2. Implementar sistema de gerenciamento de rate limiting:

```python
class RateLimitManager:
    """Manager for rate limiting."""
    
    def __init__(self):
        self._limiters: Dict[str, BaseLimiter] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_limiter(
        self,
        name: str,
        limiter: BaseLimiter
    ) -> None:
        """Register a rate limiter."""
        self._limiters[name] = limiter
        
    async def acquire(
        self,
        key: Union[str, LimitKey],
        limiter_name: str = "default"
    ) -> bool:
        """Acquire permission from limiter."""
        if isinstance(key, str):
            key = LimitKey.from_str(key)
            
        if limiter_name not in self._limiters:
            raise ValueError(f"No rate limiter registered for: {limiter_name}")
            
        try:
            start = time.perf_counter()
            result = await self._limiters[limiter_name].acquire(key)
            duration = time.perf_counter() - start
            
            self._metrics.counter(
                "rate_limit_requests",
                1,
                limiter=limiter_name,
                namespace=key.namespace,
                allowed=str(result).lower()
            )
            
            self._metrics.histogram(
                "rate_limit_duration",
                duration,
                limiter=limiter_name,
                namespace=key.namespace
            )
            
            if not result:
                self._metrics.counter(
                    "rate_limit_exceeded",
                    1,
                    limiter=limiter_name,
                    namespace=key.namespace
                )
                
                self._logger.warning(
                    "Rate limit exceeded",
                    extra={
                        "key": str(key),
                        "limiter": limiter_name
                    }
                )
                
            return result
            
        except Exception as e:
            self._metrics.counter(
                "rate_limit_errors",
                1,
                limiter=limiter_name,
                namespace=key.namespace
            )
            
            self._logger.error(
                "Rate limit check failed",
                extra={
                    "key": str(key),
                    "limiter": limiter_name,
                    "error": str(e)
                }
            )
            
            raise
```

3. Implementar limiters específicos:

```python
class TokenBucketLimiter(BaseLimiter):
    """Token bucket rate limiter."""
    
    def __init__(self, config: LimitConfig):
        super().__init__(config)
        self._buckets: Dict[str, Dict[str, float]] = {}
        
    async def acquire(self, key: LimitKey) -> bool:
        """Acquire permission."""
        bucket = self._buckets.setdefault(str(key), {
            "tokens": self.config.capacity,
            "last_update": time.time()
        })
        
        now = time.time()
        elapsed = now - bucket["last_update"]
        bucket["tokens"] = min(
            self.config.capacity,
            bucket["tokens"] + elapsed * self.config.rate
        )
        
        if bucket["tokens"] >= 1:
            bucket["tokens"] -= 1
            bucket["last_update"] = now
            return True
            
        return False

class FixedWindowLimiter(BaseLimiter):
    """Fixed window rate limiter."""
    
    def __init__(self, config: LimitConfig):
        super().__init__(config)
        self._windows: Dict[str, Dict[str, Any]] = {}
        
    async def acquire(self, key: LimitKey) -> bool:
        """Acquire permission."""
        now = time.time()
        window = self._windows.setdefault(str(key), {
            "count": 0,
            "start": now
        })
        
        if now - window["start"] >= self.config.window:
            window["count"] = 0
            window["start"] = now
            
        if window["count"] < self.config.capacity:
            window["count"] += 1
            return True
            
        return False

class RedisLimiter(BaseLimiter):
    """Distributed rate limiter using Redis."""
    
    def __init__(
        self,
        config: LimitConfig,
        redis_url: str
    ):
        super().__init__(config)
        self._redis = Redis.from_url(redis_url)
        
    async def acquire(self, key: LimitKey) -> bool:
        """Acquire permission."""
        lua_script = """
        local key = KEYS[1]
        local now = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local capacity = tonumber(ARGV[3])
        
        redis.call('ZREMRANGEBYSCORE', key, '-inf', now - window)
        local count = redis.call('ZCARD', key)
        
        if count < capacity then
            redis.call('ZADD', key, now, now)
            redis.call('EXPIRE', key, window)
            return 1
        end
        
        return 0
        """
        
        result = await self._redis.eval(
            lua_script,
            1,
            str(key),
            time.time(),
            self.config.window,
            self.config.capacity
        )
        
        return bool(result)
```

4. Implementar sistema de monitoramento:

```python
class RateLimitMonitor:
    """Monitor for rate limiting operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        limiter: str,
        namespace: str,
        allowed: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record rate limit operation."""
        self._metrics.counter(
            "rate_limit_operations",
            1,
            limiter=limiter,
            namespace=namespace,
            allowed=str(allowed).lower(),
            **labels
        )
        
        if allowed:
            self._metrics.histogram(
                "rate_limit_duration",
                duration,
                limiter=limiter,
                namespace=namespace,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter limiters para nova interface
   - Atualizar chamadas de rate limiting
   - Implementar políticas específicas

## Validação

```python
async def test_rate_limit_system():
    # Setup
    manager = RateLimitManager()
    monitor = RateLimitMonitor()
    
    # Register limiters
    token_config = LimitConfig(
        rate=10.0,
        capacity=10,
        strategy=LimitStrategy.TOKEN_BUCKET
    )
    
    window_config = LimitConfig(
        rate=10.0,
        capacity=10,
        window=60,
        strategy=LimitStrategy.FIXED_WINDOW
    )
    
    redis_config = LimitConfig(
        rate=10.0,
        capacity=10,
        window=60,
        strategy=LimitStrategy.SLIDING_WINDOW,
        distributed=True
    )
    
    token_limiter = TokenBucketLimiter(token_config)
    window_limiter = FixedWindowLimiter(window_config)
    redis_limiter = RedisLimiter(
        redis_config,
        "redis://localhost"
    )
    
    manager.register_limiter("token", token_limiter)
    manager.register_limiter("window", window_limiter)
    manager.register_limiter("redis", redis_limiter)
    
    # Test token bucket
    key = LimitKey("test", "token1", "v1")
    allowed = await manager.acquire(key, "token")
    assert allowed is True
    
    # Test fixed window
    key = LimitKey("test", "window1", "v1")
    for _ in range(10):
        allowed = await manager.acquire(key, "window")
        assert allowed is True
        
    allowed = await manager.acquire(key, "window")
    assert allowed is False
    
    # Test Redis limiter
    key = LimitKey("test", "redis1", "v1")
    allowed = await manager.acquire(key, "redis")
    assert allowed is True
    
    # Test monitoring
    await monitor.record_operation(
        "token",
        "test",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_rate_limit_system():
    # Restore legacy implementations
    shutil.copy("core/limiter_legacy.py", "core/limiter.py")
    shutil.copy("agents/limiter_legacy.py", "agents/limiter.py")
    
    # Cleanup new implementations
    os.remove("core/rate_limit/base.py")
    os.remove("core/rate_limit/manager.py")
    os.remove("core/rate_limit/limiters.py")
    os.remove("core/rate_limit/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de rate limiting
   - Interface consistente
   - Políticas unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas não tratadas
   - Documentação completa

3. **Performance**:
   - Latência < 1ms para verificações locais
   - Latência < 10ms para verificações distribuídas
   - Precisão > 99%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de rate limiting
- [ ] Implementação do gerenciamento de limiters
- [ ] Implementação dos limiters específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
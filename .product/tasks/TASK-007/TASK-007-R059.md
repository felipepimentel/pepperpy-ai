# R059: Padronização de Protocolos e Interfaces

## Descrição

Unificar e padronizar protocolos e interfaces base em todo o framework, eliminando duplicações e inconsistências. O sistema atual apresenta diferentes implementações de protocolos e interfaces similares em vários módulos, dificultando a manutenção e a consistência.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Unificação do Tratamento de Erros

## Estado Atual

Atualmente, os protocolos e interfaces estão dispersos em diferentes módulos:

1. Em `core/protocols.py`:
```python
@runtime_checkable
class Memory(Protocol[K_contra, V_co]):
    """Protocol for agent memory systems."""
    
    @abstractmethod
    async def list(
        self,
        scope: MemoryScope | None = None,
        pattern: str | None = None,
    ) -> AsyncIterator[MemoryEntry[V_co]]:
        """List memory entries."""
        ...
```

2. Em `memory/base.py`:
```python
class BaseMemory(ABC, Generic[K, V]):
    """Base interface for memory implementations."""
    
    @abstractmethod
    async def similar(
        self,
        key: K,
        limit: int = 10,
        min_score: float = 0.0,
    ) -> AsyncIterator[MemorySearchResult[V]]:
        """Find similar entries."""
        pass
```

## Plano de Implementação

1. Criar sistema unificado de protocolos base:

```python
from abc import ABC, abstractmethod
from typing import Any, AsyncIterator, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime

T = TypeVar("T")
K = TypeVar("K")
V = TypeVar("V")

class BaseProtocol(ABC, Generic[T]):
    """Base protocol for all interfaces."""
    
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize the component."""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up resources."""
        pass
    
    @abstractmethod
    async def validate(self) -> List[str]:
        """Validate component state."""
        pass

@dataclass
class ProtocolMetadata:
    """Metadata for protocol implementations."""
    name: str
    version: str
    description: str
    capabilities: List[str]
    metadata: Dict[str, Any]

class ProtocolProvider(ABC, Generic[T]):
    """Base class for protocol providers."""
    
    @property
    @abstractmethod
    def metadata(self) -> ProtocolMetadata:
        """Get provider metadata."""
        pass
    
    @abstractmethod
    async def get_implementation(self) -> T:
        """Get protocol implementation."""
        pass
```

2. Implementar sistema de registro de protocolos:

```python
class ProtocolRegistry:
    """Registry for protocol implementations."""
    
    def __init__(self):
        self._protocols: Dict[str, Dict[str, Type[BaseProtocol]]] = {}
        self._providers: Dict[str, Dict[str, ProtocolProvider]] = {}
        self._metrics = MetricsManager.get_instance()
        
    def register_protocol(
        self,
        name: str,
        version: str,
        protocol: Type[BaseProtocol]
    ) -> None:
        """Register a protocol implementation."""
        if name not in self._protocols:
            self._protocols[name] = {}
        self._protocols[name][version] = protocol
        
    def register_provider(
        self,
        provider: ProtocolProvider
    ) -> None:
        """Register a protocol provider."""
        metadata = provider.metadata
        if metadata.name not in self._providers:
            self._providers[metadata.name] = {}
        self._providers[metadata.name][metadata.version] = provider
        
    async def get_implementation(
        self,
        name: str,
        version: Optional[str] = None
    ) -> BaseProtocol:
        """Get protocol implementation."""
        if name not in self._providers:
            raise ValueError(f"Protocol not found: {name}")
            
        providers = self._providers[name]
        if not version:
            # Get latest version
            version = max(providers.keys())
            
        if version not in providers:
            raise ValueError(f"Version not found: {version}")
            
        provider = providers[version]
        return await provider.get_implementation()
```

3. Implementar sistema de validação de protocolos:

```python
class ProtocolValidator:
    """Validator for protocol implementations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def validate_implementation(
        self,
        protocol: Type[BaseProtocol],
        implementation: Any
    ) -> List[str]:
        """Validate protocol implementation."""
        errors = []
        
        # Check interface
        if not isinstance(implementation, protocol):
            errors.append(
                f"Implementation does not implement protocol: {protocol.__name__}"
            )
            
        # Check methods
        for method in protocol.__abstractmethods__:
            if not hasattr(implementation, method):
                errors.append(f"Missing method: {method}")
                continue
                
            impl_method = getattr(implementation, method)
            if not callable(impl_method):
                errors.append(f"Method not callable: {method}")
                
        return errors
        
    async def validate_provider(
        self,
        provider: ProtocolProvider
    ) -> List[str]:
        """Validate protocol provider."""
        errors = []
        
        try:
            implementation = await provider.get_implementation()
            metadata = provider.metadata
            
            # Validate metadata
            if not metadata.name:
                errors.append("Missing provider name")
            if not metadata.version:
                errors.append("Missing provider version")
                
            # Validate implementation
            impl_errors = await self.validate_implementation(
                BaseProtocol,
                implementation
            )
            errors.extend(impl_errors)
            
        except Exception as e:
            errors.append(f"Provider validation failed: {e}")
            
        return errors
```

4. Implementar sistema de monitoramento:

```python
class ProtocolMonitor:
    """Monitor for protocol implementations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        protocol: str,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record protocol operation."""
        self._metrics.counter(
            f"protocol_{operation}",
            1,
            protocol=protocol,
            success=str(success).lower(),
            **labels
        )
        
    async def record_error(
        self,
        protocol: str,
        error: str,
        **labels: str
    ) -> None:
        """Record protocol error."""
        self._metrics.counter(
            "protocol_errors",
            1,
            protocol=protocol,
            error=error,
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/protocols.py`
   - Atualizar `memory/base.py`
   - Criar novos protocolos conforme necessário

## Validação

```python
async def test_protocol_system():
    # Setup
    registry = ProtocolRegistry()
    validator = ProtocolValidator()
    monitor = ProtocolMonitor()
    
    # Test protocol registration
    class TestProtocol(BaseProtocol[str]):
        async def initialize(self) -> None:
            pass
            
        async def cleanup(self) -> None:
            pass
            
        async def validate(self) -> List[str]:
            return []
            
    class TestProvider(ProtocolProvider[str]):
        @property
        def metadata(self) -> ProtocolMetadata:
            return ProtocolMetadata(
                name="test",
                version="1.0.0",
                description="Test protocol",
                capabilities=["test"],
                metadata={}
            )
            
        async def get_implementation(self) -> str:
            return "test"
            
    registry.register_protocol("test", "1.0.0", TestProtocol)
    registry.register_provider(TestProvider())
    
    # Test implementation retrieval
    impl = await registry.get_implementation("test")
    assert isinstance(impl, TestProtocol)
    
    # Test validation
    errors = await validator.validate_provider(TestProvider())
    assert len(errors) == 0
    
    # Test monitoring
    await monitor.record_operation("test", "get")
    await monitor.record_error("test", "test_error")
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_protocol_system():
    # Restore legacy implementations
    shutil.copy("core/protocols_legacy.py", "core/protocols.py")
    shutil.copy("memory/base_legacy.py", "memory/base.py")
    
    # Cleanup new implementations
    os.remove("core/protocols/registry.py")
    os.remove("core/protocols/validator.py")
    os.remove("core/protocols/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de protocolos
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero violações de protocolo
   - Documentação completa

3. **Monitoramento**:
   - Métricas de uso
   - Rastreamento de erros
   - Validação contínua

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de protocolos
- [ ] Implementação do registro de protocolos
- [ ] Implementação do sistema de validação
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R072: Padronização do Sistema de Auditoria

## Descrição

Unificar e padronizar o sistema de auditoria em todo o framework, criando uma abordagem consistente para rastreamento de operações, mudanças de estado e eventos do sistema. O sistema atual possui diferentes implementações de auditoria espalhadas em vários módulos, dificultando a manutenção e a consistência do código. O novo sistema deve integrar-se com as ferramentas de observabilidade existentes.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces
- R070: Consolidação do Sistema de Compatibilidade

## Estado Atual

Atualmente, a auditoria está distribuída em vários módulos:

1. Em `memory/stores/redis.py`:
```python
def record_operation(
    self,
    operation: str,
    key: str,
    success: bool = True
) -> None:
    """Record memory operation."""
    self._logger.info(
        f"Memory operation: {operation}",
        extra={
            "key": key,
            "success": success
        }
    )
```

2. Em `agents/executor.py`:
```python
def log_execution(
    self,
    agent_id: str,
    task_id: str,
    status: str
) -> None:
    """Log agent execution."""
    self._logger.info(
        f"Agent execution: {status}",
        extra={
            "agent_id": agent_id,
            "task_id": task_id
        }
    )
```

## Plano de Implementação

1. Criar sistema base de auditoria:

```python
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
import json
import uuid

class AuditLevel(Enum):
    """Audit level."""
    
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"

@dataclass
class AuditEvent:
    """Audit event."""
    
    id: str
    timestamp: datetime
    level: AuditLevel
    category: str
    action: str
    status: str
    actor: Optional[str]
    target: Optional[str]
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "level": self.level.value,
            "category": self.category,
            "action": self.action,
            "status": self.status,
            "actor": self.actor,
            "target": self.target,
            "metadata": self.metadata
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AuditEvent":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            level=AuditLevel(data["level"]),
            category=data["category"],
            action=data["action"],
            status=data["status"],
            actor=data.get("actor"),
            target=data.get("target"),
            metadata=data.get("metadata", {})
        )
```

2. Implementar sistema de gerenciamento de auditoria:

```python
class AuditManager:
    """Manager for audit events."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        self._storage: Dict[str, List[AuditEvent]] = {}
        
    async def record(
        self,
        category: str,
        action: str,
        status: str = "success",
        level: AuditLevel = AuditLevel.INFO,
        actor: Optional[str] = None,
        target: Optional[str] = None,
        **metadata: Any
    ) -> AuditEvent:
        """Record audit event."""
        event = AuditEvent(
            id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            level=level,
            category=category,
            action=action,
            status=status,
            actor=actor,
            target=target,
            metadata=metadata
        )
        
        try:
            # Store event
            if category not in self._storage:
                self._storage[category] = []
            self._storage[category].append(event)
            
            # Log event
            self._logger.log(
                logging.INFO if level == AuditLevel.INFO else logging.ERROR,
                f"Audit event: {action}",
                extra=event.to_dict()
            )
            
            # Record metrics
            self._metrics.counter(
                "audit_events",
                1,
                category=category,
                action=action,
                status=status,
                level=level.value
            )
            
            return event
            
        except Exception as e:
            self._logger.error(
                "Failed to record audit event",
                extra={
                    "category": category,
                    "action": action,
                    "error": str(e)
                }
            )
            
            raise
            
    async def query(
        self,
        category: Optional[str] = None,
        action: Optional[str] = None,
        status: Optional[str] = None,
        level: Optional[AuditLevel] = None,
        actor: Optional[str] = None,
        target: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None
    ) -> List[AuditEvent]:
        """Query audit events."""
        events = []
        
        for cat_events in self._storage.values():
            if category and cat_events[0].category != category:
                continue
                
            for event in cat_events:
                if action and event.action != action:
                    continue
                if status and event.status != status:
                    continue
                if level and event.level != level:
                    continue
                if actor and event.actor != actor:
                    continue
                if target and event.target != target:
                    continue
                if start_time and event.timestamp < start_time:
                    continue
                if end_time and event.timestamp > end_time:
                    continue
                    
                events.append(event)
                
        return events
```

3. Implementar sistema de persistência:

```python
class AuditStorage:
    """Storage for audit events."""
    
    def __init__(self, path: str):
        self._path = path
        self._ensure_path()
        
    def _ensure_path(self) -> None:
        """Ensure storage path exists."""
        os.makedirs(self._path, exist_ok=True)
        
    async def store(self, event: AuditEvent) -> None:
        """Store audit event."""
        category_path = os.path.join(
            self._path,
            event.category
        )
        os.makedirs(category_path, exist_ok=True)
        
        file_path = os.path.join(
            category_path,
            f"{event.timestamp.date().isoformat()}.jsonl"
        )
        
        async with aiofiles.open(file_path, "a") as f:
            await f.write(json.dumps(event.to_dict()) + "\n")
            
    async def load(
        self,
        category: str,
        date: datetime
    ) -> List[AuditEvent]:
        """Load audit events."""
        file_path = os.path.join(
            self._path,
            category,
            f"{date.date().isoformat()}.jsonl"
        )
        
        if not os.path.exists(file_path):
            return []
            
        events = []
        async with aiofiles.open(file_path, "r") as f:
            async for line in f:
                data = json.loads(line)
                events.append(AuditEvent.from_dict(data))
                
        return events
```

4. Implementar sistema de monitoramento:

```python
class AuditMonitor:
    """Monitor for audit operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        category: str,
        action: str,
        status: str = "success",
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record audit operation."""
        self._metrics.counter(
            "audit_operations",
            1,
            category=category,
            action=action,
            status=status,
            **labels
        )
        
        if status == "success":
            self._metrics.histogram(
                "audit_duration",
                duration,
                category=category,
                action=action,
                **labels
            )
```

5. Migrar implementações existentes:
   - Atualizar módulos para usar o novo sistema
   - Implementar auditoria em pontos críticos
   - Criar visualizações e relatórios

## Validação

```python
async def test_audit_system():
    # Setup
    manager = AuditManager()
    storage = AuditStorage("/tmp/audit")
    monitor = AuditMonitor()
    
    # Test recording
    event = await manager.record(
        category="memory",
        action="set",
        actor="test_user",
        target="test_key",
        value="test_data"
    )
    
    assert event.category == "memory"
    assert event.action == "set"
    
    # Test storage
    await storage.store(event)
    events = await storage.load(
        category="memory",
        date=datetime.now()
    )
    
    assert len(events) == 1
    assert events[0].id == event.id
    
    # Test querying
    results = await manager.query(
        category="memory",
        action="set",
        actor="test_user"
    )
    
    assert len(results) == 1
    assert results[0].id == event.id
    
    # Test monitoring
    await monitor.record_operation(
        category="memory",
        action="set",
        duration=0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_audit_system():
    # Restore legacy implementations
    shutil.copy("memory/audit_legacy.py", "memory/audit.py")
    shutil.copy("agents/audit_legacy.py", "agents/audit.py")
    
    # Cleanup new implementations
    os.remove("core/audit/base.py")
    os.remove("core/audit/manager.py")
    os.remove("core/audit/storage.py")
    os.remove("core/audit/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de auditoria
   - Interface consistente
   - Eventos unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero eventos perdidos
   - Documentação completa

3. **Performance**:
   - Latência < 10ms para registro
   - Uso eficiente de recursos
   - Compressão eficiente de logs

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de auditoria
- [ ] Implementação do gerenciamento de eventos
- [ ] Implementação do sistema de persistência
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
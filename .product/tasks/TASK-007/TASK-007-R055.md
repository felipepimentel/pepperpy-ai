# R055: Consolidação do Sistema de Memória

## Descrição

Unificar as implementações de gerenciamento de memória, removendo duplicações entre os diferentes providers e stores. O sistema atual apresenta implementações similares em diferentes módulos, com padrões inconsistentes de gerenciamento de estado, busca e armazenamento.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R026: Sistema de Resource Management

## Estado Atual

Atualmente, o gerenciamento de memória está disperso em diferentes módulos com implementações similares:

1. Em `memory/providers/local.py`:
```python
class LocalProvider(MemoryProvider):
    async def keys(self, pattern: Optional[str] = None, **kwargs: Any) -> List[str]:
        try:
            async with self._lock:
                if pattern:
                    return [key for key in self.entries 
                           if key.startswith(pattern) and 
                           not (self.entries[key].expires_at and 
                                self.entries[key].expires_at <= datetime.now())]
```

2. Em `memory/stores/redis.py`:
```python
class RedisMemoryStore(BaseMemoryStore[T]):
    async def _scan_keys(self, pattern: str) -> list[str]:
        if not self._client:
            raise RedisMemoryError("Redis client not initialized")

        keys = []
        cursor = 0
        while True:
            cursor, matches = await self._client.scan(cursor, pattern)
            keys.extend(matches)
            if cursor == 0:
                break
        return keys
```

## Plano de Implementação

1. Criar uma interface unificada para gerenciamento de memória:

```python
from abc import ABC, abstractmethod
from typing import Any, AsyncIterator, Dict, Generic, List, Optional, TypeVar
from datetime import datetime, timedelta

T = TypeVar("T")

class MemoryEntry(Generic[T]):
    def __init__(
        self,
        key: str,
        value: T,
        expires_at: Optional[datetime] = None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        self.key = key
        self.value = value
        self.expires_at = expires_at
        self.metadata = metadata or {}
        self.created_at = datetime.now()
        self.updated_at = self.created_at

class MemoryStore(ABC, Generic[T]):
    @abstractmethod
    async def get(self, key: str) -> Optional[MemoryEntry[T]]:
        """Get entry by key."""
        pass
    
    @abstractmethod
    async def set(
        self,
        key: str,
        value: T,
        ttl: Optional[timedelta] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """Set entry value."""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """Delete entry by key."""
        pass
    
    @abstractmethod
    async def exists(self, key: str) -> bool:
        """Check if key exists."""
        pass
    
    @abstractmethod
    async def scan(
        self,
        pattern: Optional[str] = None,
        batch_size: int = 100
    ) -> AsyncIterator[str]:
        """Scan keys matching pattern."""
        pass
    
    @abstractmethod
    async def clear(self, pattern: Optional[str] = None) -> int:
        """Clear entries matching pattern."""
        pass
```

2. Implementar store base com funcionalidades comuns:

```python
class BaseMemoryStore(MemoryStore[T]):
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._lock = asyncio.Lock()
        
    async def exists(self, key: str) -> bool:
        entry = await self.get(key)
        return entry is not None
        
    async def clear(self, pattern: Optional[str] = None) -> int:
        count = 0
        async for key in self.scan(pattern):
            if await self.delete(key):
                count += 1
        return count
        
    def _is_expired(self, entry: MemoryEntry[T]) -> bool:
        return (
            entry.expires_at is not None and
            entry.expires_at <= datetime.now()
        )
        
    async def _record_operation(
        self,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        self._metrics.counter(
            f"memory_store_{operation}",
            1,
            success=str(success).lower(),
            **labels
        )
```

3. Implementar stores específicos:

```python
class LocalMemoryStore(BaseMemoryStore[T]):
    def __init__(self):
        super().__init__()
        self._entries: Dict[str, MemoryEntry[T]] = {}
        
    async def get(self, key: str) -> Optional[MemoryEntry[T]]:
        async with self._lock:
            entry = self._entries.get(key)
            if entry is None:
                await self._record_operation("get", False, reason="not_found")
                return None
                
            if self._is_expired(entry):
                await self.delete(key)
                await self._record_operation("get", False, reason="expired")
                return None
                
            await self._record_operation("get", True)
            return entry
            
    async def set(
        self,
        key: str,
        value: T,
        ttl: Optional[timedelta] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        expires_at = (
            datetime.now() + ttl if ttl is not None
            else None
        )
        
        entry = MemoryEntry(
            key=key,
            value=value,
            expires_at=expires_at,
            metadata=metadata
        )
        
        async with self._lock:
            self._entries[key] = entry
            await self._record_operation("set", True)
            
    async def scan(
        self,
        pattern: Optional[str] = None,
        batch_size: int = 100
    ) -> AsyncIterator[str]:
        async with self._lock:
            keys = list(self._entries.keys())
            
        for i in range(0, len(keys), batch_size):
            batch = keys[i:i + batch_size]
            for key in batch:
                if pattern and not key.startswith(pattern):
                    continue
                    
                if await self.exists(key):
                    yield key
```

4. Implementar gerenciador de memória unificado:

```python
class MemoryManager(Generic[T]):
    def __init__(self):
        self._stores: Dict[str, MemoryStore[T]] = {}
        self._default_store: Optional[str] = None
        self._metrics = MetricsManager.get_instance()
        
    def register_store(
        self,
        name: str,
        store: MemoryStore[T],
        default: bool = False
    ) -> None:
        self._stores[name] = store
        if default:
            self._default_store = name
            
    async def get(
        self,
        key: str,
        store: Optional[str] = None
    ) -> Optional[MemoryEntry[T]]:
        store_name = store or self._default_store
        if not store_name:
            raise ValueError("No store specified and no default store")
            
        if store_name not in self._stores:
            raise ValueError(f"Store not found: {store_name}")
            
        return await self._stores[store_name].get(key)
        
    async def set(
        self,
        key: str,
        value: T,
        ttl: Optional[timedelta] = None,
        metadata: Optional[Dict[str, Any]] = None,
        store: Optional[str] = None
    ) -> None:
        store_name = store or self._default_store
        if not store_name:
            raise ValueError("No store specified and no default store")
            
        if store_name not in self._stores:
            raise ValueError(f"Store not found: {store_name}")
            
        await self._stores[store_name].set(
            key,
            value,
            ttl=ttl,
            metadata=metadata
        )
```

5. Migrar implementações existentes:
   - Atualizar `memory/providers/local.py`
   - Atualizar `memory/stores/redis.py`
   - Criar novos stores conforme necessário

## Validação

```python
async def test_memory_system():
    # Setup
    manager = MemoryManager[str]()
    local_store = LocalMemoryStore[str]()
    manager.register_store("local", local_store, default=True)
    
    # Test basic operations
    await manager.set("test", "value")
    entry = await manager.get("test")
    assert entry is not None
    assert entry.value == "value"
    
    # Test TTL
    await manager.set("temp", "value", ttl=timedelta(seconds=1))
    entry = await manager.get("temp")
    assert entry is not None
    await asyncio.sleep(1.1)
    entry = await manager.get("temp")
    assert entry is None
    
    # Test scanning
    await manager.set("prefix:1", "value1")
    await manager.set("prefix:2", "value2")
    keys = []
    async for key in local_store.scan("prefix:"):
        keys.append(key)
    assert len(keys) == 2
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_memory_system():
    # Restore legacy implementations
    shutil.copy("memory/providers/local_legacy.py", "memory/providers/local.py")
    shutil.copy("memory/stores/redis_legacy.py", "memory/stores/redis.py")
    
    # Cleanup new implementations
    os.remove("memory/store.py")
    os.remove("memory/manager.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código
   - Interface consistente
   - Padrões unificados

2. **Desempenho**:
   - Latência < 1ms para operações locais
   - Throughput > 10k ops/s
   - Uso de memória otimizado

3. **Confiabilidade**:
   - Zero vazamentos de memória
   - Recuperação automática de falhas
   - Consistência de dados

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface MemoryStore
- [ ] Implementação do BaseMemoryStore
- [ ] Implementação dos stores específicos
- [ ] Implementação do MemoryManager
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
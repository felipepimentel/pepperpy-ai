# R080: Padronização do Sistema de Recursos

## Descrição

Unificar e padronizar o sistema de gerenciamento de recursos em todo o framework, criando uma abordagem consistente para gerenciamento de recursos do sistema, incluindo conexões, arquivos e outros recursos que precisam ser gerenciados adequadamente. O sistema atual possui diferentes implementações de gerenciamento de recursos espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R067: Padronização do Sistema de Composição
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, o gerenciamento de recursos está distribuído em vários módulos:

1. Em `core/resources.py`:
```python
class ResourceManager:
    """Simple resource manager."""
    
    def __init__(self):
        self._resources = {}
        
    async def acquire(self, key: str, resource: Any) -> None:
        """Acquire resource."""
        self._resources[key] = resource
        
    async def release(self, key: str) -> None:
        """Release resource."""
        if key in self._resources:
            resource = self._resources.pop(key)
            if hasattr(resource, "close"):
                await resource.close()
```

2. Em `memory/connections.py`:
```python
class ConnectionPool:
    """Pool for database connections."""
    
    def __init__(self, url: str):
        self._url = url
        self._pool = []
        
    async def get_connection(self) -> Connection:
        """Get connection from pool."""
        if not self._pool:
            return await self._create_connection()
        return self._pool.pop()
        
    async def release_connection(self, conn: Connection) -> None:
        """Release connection to pool."""
        self._pool.append(conn)
```

## Plano de Implementação

1. Criar sistema base de recursos:

```python
from typing import Any, Dict, Generic, Optional, Type, TypeVar, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
import asyncio
import weakref

T = TypeVar("T")

class ResourceType(Enum):
    """Resource types."""
    
    CONNECTION = "connection"
    FILE = "file"
    SOCKET = "socket"
    PROCESS = "process"
    MEMORY = "memory"

@dataclass
class ResourceMetadata:
    """Metadata for resources."""
    
    id: str
    type: ResourceType
    created_at: datetime
    owner: str
    ttl: Optional[int] = None
    labels: Dict[str, str] = field(default_factory=dict)

class Resource(ABC):
    """Base class for resources."""
    
    def __init__(
        self,
        metadata: ResourceMetadata
    ):
        self._metadata = metadata
        self._state = "created"
        self._last_used = datetime.now()
        
    @property
    def metadata(self) -> ResourceMetadata:
        """Get resource metadata."""
        return self._metadata
        
    @property
    def state(self) -> str:
        """Get resource state."""
        return self._state
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize resource."""
        self._state = "initialized"
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup resource."""
        self._state = "cleaned"
        
    def touch(self) -> None:
        """Update last used timestamp."""
        self._last_used = datetime.now()
        
    def is_expired(self) -> bool:
        """Check if resource is expired."""
        if not self.metadata.ttl:
            return False
        return (
            datetime.now() - self._last_used
        ).total_seconds() > self.metadata.ttl

class ResourceError(Exception):
    """Base class for resource errors."""
    pass

class ResourceNotFoundError(ResourceError):
    """Error when resource is not found."""
    pass

class ResourceInitError(ResourceError):
    """Error when resource fails to initialize."""
    pass

class ResourceCleanupError(ResourceError):
    """Error when resource fails to cleanup."""
    pass
```

2. Implementar sistema de gerenciamento de recursos:

```python
class ResourceManager:
    """Manager for resources."""
    
    def __init__(self):
        self._resources: Dict[str, Resource] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def register(
        self,
        resource: Resource
    ) -> None:
        """Register a resource."""
        if resource.metadata.id in self._resources:
            raise ResourceError(
                f"Resource already registered: {resource.metadata.id}"
            )
            
        try:
            start = time.perf_counter()
            await resource.initialize()
            duration = time.perf_counter() - start
            
            self._resources[resource.metadata.id] = resource
            
            self._metrics.counter(
                "resource_operations",
                1,
                operation="register",
                type=resource.metadata.type.value,
                success="true"
            )
            
            self._metrics.histogram(
                "resource_init_duration",
                duration,
                type=resource.metadata.type.value
            )
            
        except Exception as e:
            self._metrics.counter(
                "resource_operations",
                1,
                operation="register",
                type=resource.metadata.type.value,
                success="false"
            )
            
            self._logger.error(
                "Resource registration failed",
                extra={
                    "id": resource.metadata.id,
                    "type": resource.metadata.type.value,
                    "error": str(e)
                }
            )
            
            raise ResourceInitError(f"Failed to initialize resource: {e}") from e
            
    async def acquire(
        self,
        resource_id: str
    ) -> Resource:
        """Acquire a resource."""
        if resource_id not in self._resources:
            raise ResourceNotFoundError(
                f"Resource not found: {resource_id}"
            )
            
        resource = self._resources[resource_id]
        resource.touch()
        
        self._metrics.counter(
            "resource_operations",
            1,
            operation="acquire",
            type=resource.metadata.type.value,
            success="true"
        )
        
        return resource
        
    async def release(
        self,
        resource_id: str
    ) -> None:
        """Release a resource."""
        if resource_id not in self._resources:
            return
            
        try:
            start = time.perf_counter()
            resource = self._resources.pop(resource_id)
            await resource.cleanup()
            duration = time.perf_counter() - start
            
            self._metrics.counter(
                "resource_operations",
                1,
                operation="release",
                type=resource.metadata.type.value,
                success="true"
            )
            
            self._metrics.histogram(
                "resource_cleanup_duration",
                duration,
                type=resource.metadata.type.value
            )
            
        except Exception as e:
            self._metrics.counter(
                "resource_operations",
                1,
                operation="release",
                type=resource.metadata.type.value,
                success="false"
            )
            
            self._logger.error(
                "Resource cleanup failed",
                extra={
                    "id": resource_id,
                    "error": str(e)
                }
            )
            
            raise ResourceCleanupError(f"Failed to cleanup resource: {e}") from e
            
    async def cleanup_expired(self) -> None:
        """Cleanup expired resources."""
        expired = [
            resource_id
            for resource_id, resource in self._resources.items()
            if resource.is_expired()
        ]
        
        for resource_id in expired:
            await self.release(resource_id)
            
        if expired:
            self._metrics.counter(
                "resource_cleanups",
                len(expired)
            )
```

3. Implementar recursos específicos:

```python
class ConnectionResource(Resource):
    """Resource for database connections."""
    
    def __init__(
        self,
        url: str,
        pool_size: int = 10,
        **labels: str
    ):
        super().__init__(
            ResourceMetadata(
                id=str(uuid.uuid4()),
                type=ResourceType.CONNECTION,
                created_at=datetime.now(),
                owner="system",
                labels=labels
            )
        )
        self._url = url
        self._pool_size = pool_size
        self._pool: List[Connection] = []
        
    async def initialize(self) -> None:
        """Initialize connection pool."""
        await super().initialize()
        for _ in range(self._pool_size):
            conn = await self._create_connection()
            self._pool.append(conn)
            
    async def cleanup(self) -> None:
        """Cleanup connection pool."""
        for conn in self._pool:
            await conn.close()
        self._pool.clear()
        await super().cleanup()
        
    async def get_connection(self) -> Connection:
        """Get connection from pool."""
        if not self._pool:
            return await self._create_connection()
        return self._pool.pop()
        
    async def release_connection(self, conn: Connection) -> None:
        """Release connection to pool."""
        self._pool.append(conn)
        
    async def _create_connection(self) -> Connection:
        """Create new connection."""
        return await create_connection(self._url)

class FileResource(Resource):
    """Resource for file handles."""
    
    def __init__(
        self,
        path: str,
        mode: str = "r",
        **labels: str
    ):
        super().__init__(
            ResourceMetadata(
                id=str(uuid.uuid4()),
                type=ResourceType.FILE,
                created_at=datetime.now(),
                owner="system",
                labels=labels
            )
        )
        self._path = path
        self._mode = mode
        self._file = None
        
    async def initialize(self) -> None:
        """Open file."""
        await super().initialize()
        self._file = await aiofiles.open(
            self._path,
            self._mode
        )
        
    async def cleanup(self) -> None:
        """Close file."""
        if self._file:
            await self._file.close()
            self._file = None
        await super().cleanup()
        
    async def read(self) -> str:
        """Read from file."""
        if not self._file:
            raise ResourceError("File not initialized")
        return await self._file.read()
        
    async def write(self, data: str) -> None:
        """Write to file."""
        if not self._file:
            raise ResourceError("File not initialized")
        await self._file.write(data)
```

4. Implementar sistema de monitoramento:

```python
class ResourceMonitor:
    """Monitor for resource operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        resource_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record resource operation."""
        self._metrics.counter(
            "resource_operations",
            1,
            operation=operation,
            type=resource_type,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "resource_duration",
                duration,
                operation=operation,
                type=resource_type,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter recursos para nova interface
   - Atualizar gerenciamento de recursos
   - Implementar limpeza automática

## Validação

```python
async def test_resource_system():
    # Setup
    manager = ResourceManager()
    monitor = ResourceMonitor()
    
    # Test connection resource
    conn_resource = ConnectionResource(
        "postgresql://localhost/test",
        pool_size=5
    )
    
    await manager.register(conn_resource)
    
    # Get and use connection
    conn = await conn_resource.get_connection()
    # ... use connection ...
    await conn_resource.release_connection(conn)
    
    # Test file resource
    file_resource = FileResource(
        "/tmp/test.txt",
        mode="w"
    )
    
    await manager.register(file_resource)
    
    # Write to file
    await file_resource.write("test data")
    
    # Cleanup resources
    await manager.release(conn_resource.metadata.id)
    await manager.release(file_resource.metadata.id)
    
    # Test monitoring
    await monitor.record_operation(
        "register",
        "connection",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_resource_system():
    # Restore legacy implementations
    shutil.copy("core/resources_legacy.py", "core/resources.py")
    shutil.copy("memory/connections_legacy.py", "memory/connections.py")
    
    # Cleanup new implementations
    os.remove("core/resources/base.py")
    os.remove("core/resources/manager.py")
    os.remove("core/resources/resources.py")
    os.remove("core/resources/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de recursos
   - Interface consistente
   - Gerenciamento unificado

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 1ms para operações
   - Uso eficiente de recursos
   - Limpeza garantida

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de recursos
- [ ] Implementação do gerenciamento de recursos
- [ ] Implementação dos recursos específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
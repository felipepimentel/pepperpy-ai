---
title: Padroniza√ß√£o do Sistema de Logging
task: TASK-007
code: R043
status: üìã To Do
created: 2024-02-22
updated: 2024-02-22
started: null
completed: null
---

# Requirement
Unificar e padronizar o sistema de logging, consolidando o LoggerProtocol e implementa√ß√µes dispersas em um √∫nico sistema consistente e eficiente.

# Dependencies
- R024 (Consolida√ß√£o do Sistema de Observabilidade)

## Current State
```python
# Duplica√ß√£o e inconsist√™ncia em logging:

# Em agents/providers/base.py
class LoggerProtocol(Protocol):
    def error(self, message: str, **context: str) -> None: ...
    def info(self, message: str, **context: str) -> None: ...
    def debug(self, message: str, **context: str) -> None: ...
    def warning(self, message: str, **context: str) -> None: ...

# Em core/enums.py
class LogLevel(Enum):
    DEBUG = auto()
    INFO = auto()
    WARNING = auto()
    ERROR = auto()
    CRITICAL = auto()

# Uso inconsistente em v√°rios m√≥dulos:
logger.error("Error message")  # Uso direto
self.logger.error("Error", extra={"context": "value"})  # Com contexto
logging.error("Error occurred", exc_info=True)  # Com exce√ß√£o
```

## Implementation
```python
# 1. Criar novo m√≥dulo unificado em core/logging/base.py
from enum import Enum, auto
from typing import Any, Dict, Optional
import structlog
from structlog.types import EventDict, Processor

class LogLevel(Enum):
    """Log levels for the unified logging system."""
    DEBUG = auto()
    INFO = auto()
    WARNING = auto()
    ERROR = auto()
    CRITICAL = auto()

class UnifiedLogger:
    """Unified logger implementation."""
    
    def __init__(
        self,
        name: str,
        context: Optional[Dict[str, Any]] = None,
        processors: Optional[list[Processor]] = None,
    ) -> None:
        self.name = name
        self._context = context or {}
        self._logger = self._setup_logger(processors)
    
    def _setup_logger(
        self,
        processors: Optional[list[Processor]] = None,
    ) -> structlog.BoundLogger:
        """Setup structured logger with processors."""
        default_processors = [
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.add_log_level,
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog.processors.JSONRenderer(),
        ]
        
        if processors:
            default_processors.extend(processors)
        
        return structlog.wrap_logger(
            structlog.PrintLogger(),
            processors=default_processors,
            context_class=dict,
            wrapper_class=structlog.BoundLogger,
            cache_logger_on_first_use=True,
        )
    
    def with_context(self, **kwargs: Any) -> "UnifiedLogger":
        """Create new logger with additional context."""
        new_context = {**self._context, **kwargs}
        return UnifiedLogger(self.name, new_context)
    
    def debug(self, message: str, **kwargs: Any) -> None:
        """Log debug message."""
        self._log(LogLevel.DEBUG, message, **kwargs)
    
    def info(self, message: str, **kwargs: Any) -> None:
        """Log info message."""
        self._log(LogLevel.INFO, message, **kwargs)
    
    def warning(self, message: str, **kwargs: Any) -> None:
        """Log warning message."""
        self._log(LogLevel.WARNING, message, **kwargs)
    
    def error(
        self,
        message: str,
        exc_info: bool = False,
        **kwargs: Any,
    ) -> None:
        """Log error message."""
        self._log(LogLevel.ERROR, message, exc_info=exc_info, **kwargs)
    
    def critical(
        self,
        message: str,
        exc_info: bool = True,
        **kwargs: Any,
    ) -> None:
        """Log critical message."""
        self._log(LogLevel.CRITICAL, message, exc_info=exc_info, **kwargs)
    
    def _log(
        self,
        level: LogLevel,
        message: str,
        exc_info: bool = False,
        **kwargs: Any,
    ) -> None:
        """Internal log method."""
        context = {**self._context, **kwargs}
        logger = self._logger.bind(**context)
        
        log_method = getattr(logger, level.name.lower())
        log_method(message, exc_info=exc_info)

# 2. Criar factory para loggers em core/logging/factory.py
class LoggerFactory:
    """Factory for creating unified loggers."""
    
    _instances: Dict[str, UnifiedLogger] = {}
    
    @classmethod
    def get_logger(
        cls,
        name: str,
        context: Optional[Dict[str, Any]] = None,
        processors: Optional[list[Processor]] = None,
    ) -> UnifiedLogger:
        """Get or create logger instance."""
        if name not in cls._instances:
            cls._instances[name] = UnifiedLogger(name, context, processors)
        return cls._instances[name]

# 3. Remover implementa√ß√µes antigas:
# - Remover LoggerProtocol de agents/providers/base.py
# - Remover LogLevel de core/enums.py
# - Atualizar todos os usos de logging para usar o novo sistema

# 4. Exemplo de uso do novo sistema:
from pepperpy.core.logging import LoggerFactory

logger = LoggerFactory.get_logger(__name__)
logger.info("Operation started", operation="backup")

with_context = logger.with_context(user_id="123")
with_context.error("Operation failed", exc_info=True)
```

## Validation
```python
def test_unified_logging():
    """Test unified logging system."""
    # Test basic logging
    logger = LoggerFactory.get_logger("test")
    logger.info("Test message")
    
    # Test context
    with_context = logger.with_context(user="test")
    with_context.error("Error occurred")
    
    # Test processors
    def custom_processor(logger: Any, name: str, event_dict: EventDict) -> EventDict:
        event_dict["custom"] = "value"
        return event_dict
    
    logger = LoggerFactory.get_logger(
        "test_processors",
        processors=[custom_processor],
    )
    logger.info("Test processors")
    
    # Test exception handling
    try:
        raise ValueError("Test error")
    except ValueError:
        logger.error("Error caught", exc_info=True)
```

## Rollback Plan
1. Manter backup das implementa√ß√µes antigas
2. Script de revers√£o para restaurar arquivos originais:
   ```bash
   cp agents/providers/base.py.bak agents/providers/base.py
   cp core/enums.py.bak core/enums.py
   rm -rf core/logging/
   ```
3. Reverter todos os imports e usos do novo sistema

## Success Metrics
- [ ] Zero duplica√ß√£o de c√≥digo de logging
- [ ] Todos os logs usando o novo sistema unificado
- [ ] Formato consistente de logs em toda a aplica√ß√£o
- [ ] Melhor rastreabilidade com contexto estruturado
- [ ] Performance igual ou melhor que implementa√ß√£o anterior
- [ ] Documenta√ß√£o completa do novo sistema

# Progress Updates

## 2024-02-22
- Status: üìã To Do
- Progress: Requirement criado e documentado 
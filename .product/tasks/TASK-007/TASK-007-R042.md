---
title: Unifica√ß√£o do Sistema de Configura√ß√£o Core
task: TASK-007
code: R042
status: üìã To Do
created: 2024-02-22
updated: 2024-02-22
started: null
completed: null
---

# Requirement
Unificar as implementa√ß√µes duplicadas do sistema de configura√ß√£o entre core/config/base.py e core/config.py, removendo duplicidades e estabelecendo um padr√£o √∫nico e consistente.

# Dependencies
- R020 (Unifica√ß√£o do Sistema de Configura√ß√£o)

## Current State
```python
# Duplica√ß√£o entre core/config/base.py e core/config.py
# Exemplo de duplica√ß√£o no m√©todo _get_default_config:

# Em core/config/base.py
def _get_default_config(self) -> Dict[str, Dict[str, Any]]:
    return {
        "llm": {
            "default": {
                "type": "openai",
                "config": {"model": "gpt-3.5-turbo", "temperature": 0.7},
            }
        },
        # ... c√≥digo duplicado ...
    }

# Em core/config.py
def _get_default_config(self) -> Dict[str, Dict[str, Any]]:
    return {
        "llm": {
            "default": {
                "type": "openai",
                "config": {"model": "gpt-3.5-turbo", "temperature": 0.7},
            }
        },
        # ... c√≥digo duplicado ...
    }
```

## Implementation
```python
# 1. Criar novo m√≥dulo unificado em core/config/unified.py
from typing import Any, Dict, Optional, Type, TypeVar
from pydantic import BaseModel

T = TypeVar("T", bound=BaseModel)

class UnifiedConfiguration(Generic[T]):
    """Unified configuration management for Pepperpy framework."""
    
    def __init__(
        self,
        config_class: Type[T],
        config_path: Optional[Path] = None,
        metrics: Optional[MetricsCollector] = None,
    ) -> None:
        self._config_class = config_class
        self._config_path = config_path
        self._metrics = metrics
        self._config: Optional[T] = None
        self._lock = asyncio.Lock()

    async def load(self) -> T:
        """Load configuration from file or defaults."""
        async with self._lock:
            if self._config is None:
                if self._config_path and self._config_path.exists():
                    self._config = await self._load_from_file()
                else:
                    self._config = self._config_class(**self._get_default_config())
            return self._config

    def _get_default_config(self) -> Dict[str, Any]:
        """Get default configuration."""
        return {
            "llm": {
                "default": {
                    "type": "openai",
                    "config": {"model": "gpt-3.5-turbo", "temperature": 0.7},
                }
            },
            "content": {
                "default": {
                    "type": "rss",
                    "config": {
                        "sources": ["https://news.google.com/rss"],
                        "language": "pt-BR",
                    },
                }
            },
            "synthesis": {
                "default": {
                    "type": "openai",
                    "config": {"voice": "alloy", "model": "tts-1"},
                }
            },
            "memory": {
                "default": {
                    "type": "local",
                    "config": {"path": "~/.pepperpy/memory"}
                }
            }
        }

# 2. Remover arquivos antigos ap√≥s migra√ß√£o
# - core/config/base.py
# - core/config.py

# 3. Atualizar imports em todos os arquivos que usam as classes antigas
from pepperpy.core.config.unified import UnifiedConfiguration
```

## Validation
```python
def test_unified_configuration():
    """Test unified configuration system."""
    # Test configuration loading
    config = UnifiedConfiguration(ConfigModel)
    loaded = await config.load()
    assert loaded is not None
    assert loaded.llm.default.type == "openai"
    
    # Test file loading
    config_path = Path("test_config.yaml")
    config_path.write_text(yaml.dump({"llm": {"default": {"type": "test"}}}))
    config = UnifiedConfiguration(ConfigModel, config_path)
    loaded = await config.load()
    assert loaded.llm.default.type == "test"
    
    # Test metrics
    metrics = MetricsCollector()
    config = UnifiedConfiguration(ConfigModel, metrics=metrics)
    await config.load()
    assert metrics.get_counter("config_loads").get_value() == 1
```

## Rollback Plan
1. Manter backup dos arquivos originais antes da remo√ß√£o
2. Script de revers√£o para restaurar arquivos originais:
   ```bash
   cp core/config/base.py.bak core/config/base.py
   cp core/config.py.bak core/config.py
   rm core/config/unified.py
   ```
3. Reverter imports nos arquivos afetados

## Success Metrics
- [ ] Zero duplica√ß√£o de c√≥digo de configura√ß√£o
- [ ] Todos os testes passando
- [ ] M√©tricas de configura√ß√£o funcionando
- [ ] Documenta√ß√£o atualizada
- [ ] Performance igual ou melhor que a implementa√ß√£o anterior

# Progress Updates

## 2024-02-22
- Status: üìã To Do
- Progress: Requirement criado e documentado 
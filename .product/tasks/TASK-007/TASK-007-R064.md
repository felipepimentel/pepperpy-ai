# R064: Padronização do Sistema de Lifecycle Management

## Descrição

Unificar e padronizar o sistema de gerenciamento de ciclo de vida em todo o framework, estabelecendo uma interface consistente para inicialização, limpeza e validação de componentes. O sistema atual possui diferentes implementações de gerenciamento de ciclo de vida espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R048: Unificação do Sistema de Lifecycle Management

## Estado Atual

Atualmente, o gerenciamento de ciclo de vida está distribuído em vários módulos:

1. Em `core/client.py`:
```python
class PepperpyClient(PepperpyClientProtocol, Lifecycle):
    """Main client interface."""
    
    async def initialize(self) -> None:
        """Initialize client."""
        if self._initialized:
            return
            
        try:
            # Initialize components
            await self._initialize_components()
            self._initialized = True
            
        except Exception as e:
            raise StateError(f"Failed to initialize client: {e}")
            
    async def cleanup(self) -> None:
        """Clean up client resources."""
        try:
            # Clean up components
            await self._cleanup_components()
            self._initialized = False
            
        except Exception as e:
            raise StateError(f"Failed to clean up client: {e}")
```

2. Em `agents/providers/base.py`:
```python
class BaseProvider(BaseComponent):
    """Base provider implementation."""
    
    async def initialize(self) -> None:
        """Initialize provider."""
        if self.state != ProviderState.NEW:
            return
            
        try:
            # Initialize resources
            await self._initialize_resources()
            self.state = ProviderState.READY
            
        except Exception as e:
            self.state = ProviderState.ERROR
            raise StateError(f"Failed to initialize provider: {e}")
            
    async def cleanup(self) -> None:
        """Clean up provider resources."""
        try:
            # Clean up resources
            await self._cleanup_resources()
            self.state = ProviderState.CLOSED
            
        except Exception as e:
            self.state = ProviderState.ERROR
            raise StateError(f"Failed to clean up provider: {e}")
```

## Plano de Implementação

1. Criar sistema base de lifecycle:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class LifecycleState(Enum):
    """Component lifecycle states."""
    NEW = "new"
    INITIALIZING = "initializing"
    READY = "ready"
    STOPPING = "stopping"
    STOPPED = "stopped"
    ERROR = "error"

@dataclass
class LifecycleMetadata:
    """Metadata for lifecycle management."""
    component_id: str
    component_type: str
    state: LifecycleState
    created_at: datetime
    updated_at: datetime
    error: Optional[str]
    dependencies: List[str]

class LifecycleComponent(ABC):
    """Base class for components with lifecycle management."""
    
    def __init__(self) -> None:
        """Initialize component."""
        self._metadata = LifecycleMetadata(
            component_id=str(uuid.uuid4()),
            component_type=self.__class__.__name__,
            state=LifecycleState.NEW,
            created_at=datetime.now(),
            updated_at=datetime.now(),
            error=None,
            dependencies=[]
        )
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> LifecycleMetadata:
        """Get component metadata."""
        return self._metadata
        
    async def initialize(self) -> None:
        """Initialize component."""
        if self._metadata.state != LifecycleState.NEW:
            return
            
        try:
            self._metadata.state = LifecycleState.INITIALIZING
            self._metadata.updated_at = datetime.now()
            
            # Initialize dependencies
            await self._initialize_dependencies()
            
            # Initialize component
            await self._initialize()
            
            self._metadata.state = LifecycleState.READY
            self._metadata.updated_at = datetime.now()
            
            self._metrics.counter(
                "lifecycle_operations",
                1,
                operation="initialize",
                component_type=self._metadata.component_type,
                success="true"
            )
            
        except Exception as e:
            self._metadata.state = LifecycleState.ERROR
            self._metadata.error = str(e)
            self._metadata.updated_at = datetime.now()
            
            self._metrics.counter(
                "lifecycle_operations",
                1,
                operation="initialize",
                component_type=self._metadata.component_type,
                success="false"
            )
            
            self._logger.error(
                "Failed to initialize component",
                extra={
                    "component_type": self._metadata.component_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def cleanup(self) -> None:
        """Clean up component resources."""
        if self._metadata.state == LifecycleState.STOPPED:
            return
            
        try:
            self._metadata.state = LifecycleState.STOPPING
            self._metadata.updated_at = datetime.now()
            
            # Clean up component
            await self._cleanup()
            
            # Clean up dependencies
            await self._cleanup_dependencies()
            
            self._metadata.state = LifecycleState.STOPPED
            self._metadata.updated_at = datetime.now()
            
            self._metrics.counter(
                "lifecycle_operations",
                1,
                operation="cleanup",
                component_type=self._metadata.component_type,
                success="true"
            )
            
        except Exception as e:
            self._metadata.state = LifecycleState.ERROR
            self._metadata.error = str(e)
            self._metadata.updated_at = datetime.now()
            
            self._metrics.counter(
                "lifecycle_operations",
                1,
                operation="cleanup",
                component_type=self._metadata.component_type,
                success="false"
            )
            
            self._logger.error(
                "Failed to clean up component",
                extra={
                    "component_type": self._metadata.component_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def validate(self) -> List[str]:
        """Validate component state."""
        errors = []
        
        try:
            # Validate state
            if self._metadata.state == LifecycleState.ERROR:
                errors.append(f"Component in error state: {self._metadata.error}")
                
            # Validate dependencies
            dependency_errors = await self._validate_dependencies()
            errors.extend(dependency_errors)
            
            # Validate component
            component_errors = await self._validate()
            errors.extend(component_errors)
            
        except Exception as e:
            errors.append(f"Validation failed: {e}")
            
        return errors
        
    @abstractmethod
    async def _initialize(self) -> None:
        """Initialize component implementation."""
        pass
        
    @abstractmethod
    async def _cleanup(self) -> None:
        """Clean up component implementation."""
        pass
        
    @abstractmethod
    async def _validate(self) -> List[str]:
        """Validate component implementation."""
        pass
        
    async def _initialize_dependencies(self) -> None:
        """Initialize component dependencies."""
        pass
        
    async def _cleanup_dependencies(self) -> None:
        """Clean up component dependencies."""
        pass
        
    async def _validate_dependencies(self) -> List[str]:
        """Validate component dependencies."""
        return []
```

2. Implementar sistema de gerenciamento unificado:

```python
class LifecycleManager:
    """Manager for component lifecycle."""
    
    def __init__(self):
        self._components: Dict[str, LifecycleComponent] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def register_component(
        self,
        component: LifecycleComponent
    ) -> None:
        """Register a component."""
        self._components[component.metadata.component_id] = component
        
    async def unregister_component(
        self,
        component_id: str
    ) -> None:
        """Unregister a component."""
        if component_id in self._components:
            component = self._components[component_id]
            await component.cleanup()
            del self._components[component_id]
            
    async def initialize_all(self) -> None:
        """Initialize all components."""
        for component in self._components.values():
            await component.initialize()
            
    async def cleanup_all(self) -> None:
        """Clean up all components."""
        for component in self._components.values():
            await component.cleanup()
            
    async def validate_all(self) -> Dict[str, List[str]]:
        """Validate all components."""
        results = {}
        for component_id, component in self._components.items():
            results[component_id] = await component.validate()
        return results
```

3. Implementar sistema de monitoramento:

```python
class LifecycleMonitor:
    """Monitor for lifecycle management."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_state_change(
        self,
        component_type: str,
        old_state: LifecycleState,
        new_state: LifecycleState,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record state change."""
        self._metrics.counter(
            "lifecycle_state_changes",
            1,
            component_type=component_type,
            old_state=old_state.value,
            new_state=new_state.value,
            success=str(success).lower(),
            **labels
        )
        
    async def record_operation(
        self,
        component_type: str,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record lifecycle operation."""
        self._metrics.counter(
            "lifecycle_operations",
            1,
            component_type=component_type,
            operation=operation,
            success=str(success).lower(),
            **labels
        )
```

4. Migrar implementações existentes:
   - Atualizar `core/client.py`
   - Atualizar `agents/providers/base.py`
   - Criar novos componentes conforme necessário

## Validação

```python
async def test_lifecycle_system():
    # Setup
    manager = LifecycleManager()
    monitor = LifecycleMonitor()
    
    # Create test component
    class TestComponent(LifecycleComponent):
        async def _initialize(self) -> None:
            pass
            
        async def _cleanup(self) -> None:
            pass
            
        async def _validate(self) -> List[str]:
            return []
            
    component = TestComponent()
    
    # Test registration
    await manager.register_component(component)
    
    # Test initialization
    await manager.initialize_all()
    assert component.metadata.state == LifecycleState.READY
    
    # Test validation
    errors = await manager.validate_all()
    assert not errors[component.metadata.component_id]
    
    # Test cleanup
    await manager.cleanup_all()
    assert component.metadata.state == LifecycleState.STOPPED
    
    # Test monitoring
    await monitor.record_state_change(
        "TestComponent",
        LifecycleState.NEW,
        LifecycleState.READY
    )
    await monitor.record_operation(
        "TestComponent",
        "initialize",
        True
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_lifecycle_system():
    # Restore legacy implementations
    shutil.copy("core/client_legacy.py", "core/client.py")
    shutil.copy("agents/providers/base_legacy.py", "agents/providers/base.py")
    
    # Cleanup new implementations
    os.remove("core/lifecycle/base.py")
    os.remove("core/lifecycle/manager.py")
    os.remove("core/lifecycle/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de lifecycle
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para inicialização
   - Latência < 20ms para limpeza
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de lifecycle
- [ ] Implementação do gerenciamento unificado
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
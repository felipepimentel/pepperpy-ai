# R074: Consolidação do Sistema de Cache

## Descrição

Unificar e padronizar o sistema de cache em todo o framework, estabelecendo uma interface consistente para caching de dados e resultados de operações. O sistema atual possui diferentes implementações de cache espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R065: Consolidação dos Sistemas de Armazenamento
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, o cache está distribuído em vários módulos:

1. Em `memory/cache.py`:
```python
class MemoryCache:
    """Simple memory cache."""
    
    def __init__(self):
        self._cache = {}
        
    def get(self, key: str) -> Any:
        """Get value from cache."""
        return self._cache.get(key)
        
    def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[int] = None
    ) -> None:
        """Set value in cache."""
        self._cache[key] = value
```

2. Em `agents/cache.py`:
```python
class ResultCache:
    """Cache for operation results."""
    
    def __init__(self, redis_url: str):
        self._redis = Redis.from_url(redis_url)
        
    async def get_result(
        self,
        operation_id: str
    ) -> Optional[Dict[str, Any]]:
        """Get cached result."""
        data = await self._redis.get(f"result:{operation_id}")
        return json.loads(data) if data else None
```

## Plano de Implementação

1. Criar sistema base de cache:

```python
from typing import Any, Dict, Generic, Optional, TypeVar, Union
from datetime import datetime, timedelta
import json
import hashlib
import pickle

T = TypeVar("T")

class CacheKey:
    """Cache key with metadata."""
    
    def __init__(
        self,
        namespace: str,
        key: str,
        version: Optional[str] = None
    ):
        self.namespace = namespace
        self.key = key
        self.version = version
        
    def __str__(self) -> str:
        """Get string representation."""
        parts = [self.namespace, self.key]
        if self.version:
            parts.append(self.version)
        return ":".join(parts)
        
    @classmethod
    def from_str(cls, key: str) -> "CacheKey":
        """Create from string."""
        parts = key.split(":")
        return cls(
            namespace=parts[0],
            key=parts[1],
            version=parts[2] if len(parts) > 2 else None
        )

class CacheEntry(Generic[T]):
    """Cache entry with metadata."""
    
    def __init__(
        self,
        value: T,
        created_at: datetime,
        expires_at: Optional[datetime] = None
    ):
        self.value = value
        self.created_at = created_at
        self.expires_at = expires_at
        
    def is_expired(self) -> bool:
        """Check if entry is expired."""
        return (
            self.expires_at is not None
            and datetime.now() > self.expires_at
        )
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "value": pickle.dumps(self.value),
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CacheEntry[Any]":
        """Create from dictionary."""
        return cls(
            value=pickle.loads(data["value"]),
            created_at=datetime.fromisoformat(data["created_at"]),
            expires_at=datetime.fromisoformat(data["expires_at"]) if data["expires_at"] else None
        )
```

2. Implementar sistema de gerenciamento de cache:

```python
class CacheManager:
    """Manager for cache operations."""
    
    def __init__(self):
        self._stores: Dict[str, Any] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_store(
        self,
        name: str,
        store: Any
    ) -> None:
        """Register a cache store."""
        self._stores[name] = store
        
    async def get(
        self,
        key: Union[str, CacheKey],
        store: str = "default"
    ) -> Optional[Any]:
        """Get value from cache."""
        if isinstance(key, str):
            key = CacheKey.from_str(key)
            
        if store not in self._stores:
            raise ValueError(f"No cache store registered for: {store}")
            
        try:
            start = time.perf_counter()
            entry = await self._stores[store].get(str(key))
            duration = time.perf_counter() - start
            
            if entry:
                entry = CacheEntry.from_dict(entry)
                if entry.is_expired():
                    await self.delete(key, store)
                    return None
                    
                self._metrics.counter(
                    "cache_hits",
                    1,
                    store=store,
                    namespace=key.namespace
                )
                
                self._metrics.histogram(
                    "cache_get_duration",
                    duration,
                    store=store,
                    namespace=key.namespace
                )
                
                return entry.value
                
            self._metrics.counter(
                "cache_misses",
                1,
                store=store,
                namespace=key.namespace
            )
            
            return None
            
        except Exception as e:
            self._metrics.counter(
                "cache_errors",
                1,
                store=store,
                namespace=key.namespace,
                operation="get"
            )
            
            self._logger.error(
                "Cache get failed",
                extra={
                    "key": str(key),
                    "store": store,
                    "error": str(e)
                }
            )
            
            raise
            
    async def set(
        self,
        key: Union[str, CacheKey],
        value: Any,
        ttl: Optional[Union[int, timedelta]] = None,
        store: str = "default"
    ) -> None:
        """Set value in cache."""
        if isinstance(key, str):
            key = CacheKey.from_str(key)
            
        if store not in self._stores:
            raise ValueError(f"No cache store registered for: {store}")
            
        try:
            expires_at = None
            if ttl is not None:
                if isinstance(ttl, int):
                    ttl = timedelta(seconds=ttl)
                expires_at = datetime.now() + ttl
                
            entry = CacheEntry(
                value=value,
                created_at=datetime.now(),
                expires_at=expires_at
            )
            
            start = time.perf_counter()
            await self._stores[store].set(
                str(key),
                entry.to_dict(),
                ttl.total_seconds() if ttl else None
            )
            duration = time.perf_counter() - start
            
            self._metrics.counter(
                "cache_sets",
                1,
                store=store,
                namespace=key.namespace
            )
            
            self._metrics.histogram(
                "cache_set_duration",
                duration,
                store=store,
                namespace=key.namespace
            )
            
        except Exception as e:
            self._metrics.counter(
                "cache_errors",
                1,
                store=store,
                namespace=key.namespace,
                operation="set"
            )
            
            self._logger.error(
                "Cache set failed",
                extra={
                    "key": str(key),
                    "store": store,
                    "error": str(e)
                }
            )
            
            raise
            
    async def delete(
        self,
        key: Union[str, CacheKey],
        store: str = "default"
    ) -> None:
        """Delete value from cache."""
        if isinstance(key, str):
            key = CacheKey.from_str(key)
            
        if store not in self._stores:
            raise ValueError(f"No cache store registered for: {store}")
            
        try:
            start = time.perf_counter()
            await self._stores[store].delete(str(key))
            duration = time.perf_counter() - start
            
            self._metrics.counter(
                "cache_deletes",
                1,
                store=store,
                namespace=key.namespace
            )
            
            self._metrics.histogram(
                "cache_delete_duration",
                duration,
                store=store,
                namespace=key.namespace
            )
            
        except Exception as e:
            self._metrics.counter(
                "cache_errors",
                1,
                store=store,
                namespace=key.namespace,
                operation="delete"
            )
            
            self._logger.error(
                "Cache delete failed",
                extra={
                    "key": str(key),
                    "store": store,
                    "error": str(e)
                }
            )
            
            raise
```

3. Implementar stores específicos:

```python
class MemoryStore:
    """In-memory cache store."""
    
    def __init__(self):
        self._store: Dict[str, Dict[str, Any]] = {}
        
    async def get(self, key: str) -> Optional[Dict[str, Any]]:
        """Get value from store."""
        return self._store.get(key)
        
    async def set(
        self,
        key: str,
        value: Dict[str, Any],
        ttl: Optional[float] = None
    ) -> None:
        """Set value in store."""
        self._store[key] = value
        
    async def delete(self, key: str) -> None:
        """Delete value from store."""
        self._store.pop(key, None)

class RedisStore:
    """Redis cache store."""
    
    def __init__(self, url: str):
        self._redis = Redis.from_url(url)
        
    async def get(self, key: str) -> Optional[Dict[str, Any]]:
        """Get value from store."""
        data = await self._redis.get(key)
        return json.loads(data) if data else None
        
    async def set(
        self,
        key: str,
        value: Dict[str, Any],
        ttl: Optional[float] = None
    ) -> None:
        """Set value in store."""
        await self._redis.set(
            key,
            json.dumps(value),
            ex=int(ttl) if ttl else None
        )
        
    async def delete(self, key: str) -> None:
        """Delete value from store."""
        await self._redis.delete(key)
```

4. Implementar sistema de monitoramento:

```python
class CacheMonitor:
    """Monitor for cache operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        store: str,
        namespace: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record cache operation."""
        self._metrics.counter(
            "cache_operations",
            1,
            operation=operation,
            store=store,
            namespace=namespace,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "cache_duration",
                duration,
                operation=operation,
                store=store,
                namespace=namespace,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter caches para nova interface
   - Atualizar chamadas de cache
   - Implementar políticas de invalidação

## Validação

```python
async def test_cache_system():
    # Setup
    manager = CacheManager()
    monitor = CacheMonitor()
    
    # Register stores
    memory_store = MemoryStore()
    redis_store = RedisStore("redis://localhost")
    
    manager.register_store("memory", memory_store)
    manager.register_store("redis", redis_store)
    
    # Test memory cache
    key = CacheKey("test", "key1", "v1")
    value = {"data": "test"}
    
    await manager.set(key, value, ttl=60, store="memory")
    result = await manager.get(key, store="memory")
    
    assert result == value
    
    # Test Redis cache
    key = CacheKey("test", "key2", "v1")
    value = {"data": "test"}
    
    await manager.set(key, value, ttl=60, store="redis")
    result = await manager.get(key, store="redis")
    
    assert result == value
    
    # Test expiration
    key = CacheKey("test", "key3", "v1")
    value = {"data": "test"}
    
    await manager.set(key, value, ttl=1, store="memory")
    await asyncio.sleep(2)
    result = await manager.get(key, store="memory")
    
    assert result is None
    
    # Test deletion
    key = CacheKey("test", "key4", "v1")
    value = {"data": "test"}
    
    await manager.set(key, value, store="memory")
    await manager.delete(key, store="memory")
    result = await manager.get(key, store="memory")
    
    assert result is None
    
    # Test monitoring
    await monitor.record_operation(
        "get",
        "memory",
        "test",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_cache_system():
    # Restore legacy implementations
    shutil.copy("memory/cache_legacy.py", "memory/cache.py")
    shutil.copy("agents/cache_legacy.py", "agents/cache.py")
    
    # Cleanup new implementations
    os.remove("core/cache/base.py")
    os.remove("core/cache/manager.py")
    os.remove("core/cache/stores.py")
    os.remove("core/cache/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de cache
   - Interface consistente
   - Políticas unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de memória
   - Documentação completa

3. **Performance**:
   - Latência < 1ms para operações em memória
   - Latência < 10ms para operações em Redis
   - Hit rate > 80%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de cache
- [ ] Implementação do gerenciamento de cache
- [ ] Implementação dos stores específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R075: Padronização do Sistema de Retry

## Descrição

Unificar e padronizar o sistema de retry em todo o framework, criando uma abordagem consistente para tratamento de retentativas em operações falhas, com backoff exponencial e políticas configuráveis. O sistema atual possui diferentes implementações de retry espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R068: Consolidação do Sistema de Processamento Assíncrono
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, o retry está distribuído em vários módulos:

1. Em `core/retry.py`:
```python
async def retry_operation(
    operation: Callable,
    max_retries: int = 3,
    delay: float = 1.0
) -> Any:
    """Retry operation with fixed delay."""
    for attempt in range(max_retries):
        try:
            return await operation()
        except Exception as e:
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(delay)
```

2. Em `agents/executor.py`:
```python
async def execute_with_retry(
    self,
    task: Task,
    backoff_factor: float = 2.0
) -> Result:
    """Execute task with exponential backoff."""
    delay = 1.0
    for attempt in range(3):
        try:
            return await self.execute(task)
        except Exception as e:
            if attempt == 2:
                raise
            await asyncio.sleep(delay)
            delay *= backoff_factor
```

## Plano de Implementação

1. Criar sistema base de retry:

```python
from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import asyncio
import random

T = TypeVar("T")

class RetryStrategy(Enum):
    """Retry strategy types."""
    
    FIXED = "fixed"
    LINEAR = "linear"
    EXPONENTIAL = "exponential"
    FIBONACCI = "fibonacci"

@dataclass
class RetryConfig:
    """Configuration for retry operations."""
    
    max_retries: int = 3
    initial_delay: float = 1.0
    max_delay: float = 60.0
    strategy: RetryStrategy = RetryStrategy.EXPONENTIAL
    jitter: bool = True
    backoff_factor: float = 2.0
    
    def calculate_delay(self, attempt: int) -> float:
        """Calculate delay for attempt."""
        if self.strategy == RetryStrategy.FIXED:
            delay = self.initial_delay
        elif self.strategy == RetryStrategy.LINEAR:
            delay = self.initial_delay * (attempt + 1)
        elif self.strategy == RetryStrategy.EXPONENTIAL:
            delay = self.initial_delay * (self.backoff_factor ** attempt)
        else:  # FIBONACCI
            delay = self._fibonacci_delay(attempt)
            
        if self.jitter:
            delay *= (1 + random.random())
            
        return min(delay, self.max_delay)
        
    def _fibonacci_delay(self, attempt: int) -> float:
        """Calculate Fibonacci delay."""
        a, b = 1, 1
        for _ in range(attempt):
            a, b = b, a + b
        return self.initial_delay * a

class RetryableError(Exception):
    """Base class for retryable errors."""
    pass

class RetryContext:
    """Context for retry operation."""
    
    def __init__(
        self,
        config: RetryConfig,
        operation: str,
        start_time: datetime
    ):
        self.config = config
        self.operation = operation
        self.start_time = start_time
        self.attempts = 0
        self.errors: List[Exception] = []
        
    @property
    def duration(self) -> timedelta:
        """Get operation duration."""
        return datetime.now() - self.start_time
        
    def record_attempt(self, error: Optional[Exception] = None) -> None:
        """Record retry attempt."""
        self.attempts += 1
        if error:
            self.errors.append(error)
```

2. Implementar sistema de gerenciamento de retry:

```python
class RetryManager:
    """Manager for retry operations."""
    
    def __init__(self):
        self._configs: Dict[str, RetryConfig] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_config(
        self,
        name: str,
        config: RetryConfig
    ) -> None:
        """Register retry configuration."""
        self._configs[name] = config
        
    async def execute(
        self,
        operation: Callable[[], T],
        config_name: str = "default",
        operation_name: str = "unknown"
    ) -> T:
        """Execute operation with retry."""
        if config_name not in self._configs:
            raise ValueError(f"No retry config registered for: {config_name}")
            
        config = self._configs[config_name]
        context = RetryContext(
            config=config,
            operation=operation_name,
            start_time=datetime.now()
        )
        
        while context.attempts <= config.max_retries:
            try:
                start = time.perf_counter()
                result = await operation()
                duration = time.perf_counter() - start
                
                self._metrics.counter(
                    "retry_operations",
                    1,
                    operation=operation_name,
                    config=config_name,
                    attempt=context.attempts,
                    success="true"
                )
                
                self._metrics.histogram(
                    "retry_duration",
                    duration,
                    operation=operation_name,
                    config=config_name,
                    attempt=context.attempts
                )
                
                return result
                
            except RetryableError as e:
                context.record_attempt(e)
                
                if context.attempts == config.max_retries:
                    self._metrics.counter(
                        "retry_operations",
                        1,
                        operation=operation_name,
                        config=config_name,
                        attempt=context.attempts,
                        success="false"
                    )
                    
                    self._logger.error(
                        "Retry operation failed",
                        extra={
                            "operation": operation_name,
                            "config": config_name,
                            "attempts": context.attempts,
                            "duration": context.duration.total_seconds(),
                            "error": str(e)
                        }
                    )
                    
                    raise
                    
                delay = config.calculate_delay(context.attempts)
                await asyncio.sleep(delay)
                
            except Exception as e:
                self._metrics.counter(
                    "retry_operations",
                    1,
                    operation=operation_name,
                    config=config_name,
                    attempt=context.attempts,
                    success="false"
                )
                
                self._logger.error(
                    "Non-retryable error",
                    extra={
                        "operation": operation_name,
                        "config": config_name,
                        "attempts": context.attempts,
                        "duration": context.duration.total_seconds(),
                        "error": str(e)
                    }
                )
                
                raise
```

3. Implementar decoradores e helpers:

```python
from functools import wraps

def retryable(
    config_name: str = "default",
    operation_name: Optional[str] = None
) -> Callable:
    """Decorator for retryable operations."""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args: Any, **kwargs: Any) -> Any:
            manager = RetryManager.get_instance()
            return await manager.execute(
                lambda: func(*args, **kwargs),
                config_name=config_name,
                operation_name=operation_name or func.__name__
            )
        return wrapper
    return decorator

class RetryContextManager:
    """Context manager for retry operations."""
    
    def __init__(
        self,
        config_name: str = "default",
        operation_name: Optional[str] = None
    ):
        self.config_name = config_name
        self.operation_name = operation_name
        self.manager = RetryManager.get_instance()
        
    async def __aenter__(self) -> "RetryContextManager":
        """Enter retry context."""
        return self
        
    async def __aexit__(
        self,
        exc_type: Optional[Type[Exception]],
        exc_val: Optional[Exception],
        exc_tb: Any
    ) -> bool:
        """Exit retry context."""
        if exc_val and isinstance(exc_val, RetryableError):
            try:
                await self.manager.execute(
                    lambda: raise_(exc_val),
                    config_name=self.config_name,
                    operation_name=self.operation_name
                )
            except Exception:
                return False
            return True
        return False
```

4. Implementar sistema de monitoramento:

```python
class RetryMonitor:
    """Monitor for retry operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        config: str,
        attempt: int,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record retry operation."""
        self._metrics.counter(
            "retry_operations",
            1,
            operation=operation,
            config=config,
            attempt=attempt,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "retry_duration",
                duration,
                operation=operation,
                config=config,
                attempt=attempt,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter retries para nova interface
   - Atualizar chamadas de retry
   - Implementar políticas específicas

## Validação

```python
async def test_retry_system():
    # Setup
    manager = RetryManager()
    monitor = RetryMonitor()
    
    # Register configs
    default_config = RetryConfig()
    aggressive_config = RetryConfig(
        max_retries=5,
        initial_delay=0.1,
        strategy=RetryStrategy.EXPONENTIAL,
        backoff_factor=3.0
    )
    
    manager.register_config("default", default_config)
    manager.register_config("aggressive", aggressive_config)
    
    # Test successful operation
    counter = 0
    
    async def success_operation() -> int:
        nonlocal counter
        counter += 1
        return counter
        
    result = await manager.execute(
        success_operation,
        config_name="default",
        operation_name="test_success"
    )
    
    assert result == 1
    assert counter == 1
    
    # Test retryable operation
    failures = 0
    
    async def retry_operation() -> str:
        nonlocal failures
        failures += 1
        if failures <= 2:
            raise RetryableError("Temporary failure")
        return "success"
        
    result = await manager.execute(
        retry_operation,
        config_name="default",
        operation_name="test_retry"
    )
    
    assert result == "success"
    assert failures == 3
    
    # Test decorator
    @retryable(config_name="aggressive")
    async def decorated_operation(succeed_after: int) -> str:
        nonlocal counter
        counter += 1
        if counter <= succeed_after:
            raise RetryableError("Not yet")
        return "success"
        
    counter = 0
    result = await decorated_operation(3)
    
    assert result == "success"
    assert counter == 4
    
    # Test context manager
    async with RetryContextManager(
        config_name="default",
        operation_name="test_context"
    ):
        raise RetryableError("Retry this")
        
    # Test monitoring
    await monitor.record_operation(
        "test",
        "default",
        1,
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_retry_system():
    # Restore legacy implementations
    shutil.copy("core/retry_legacy.py", "core/retry.py")
    shutil.copy("agents/retry_legacy.py", "agents/retry.py")
    
    # Cleanup new implementations
    os.remove("core/retry/base.py")
    os.remove("core/retry/manager.py")
    os.remove("core/retry/decorators.py")
    os.remove("core/retry/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de retry
   - Interface consistente
   - Políticas unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas não tratadas
   - Documentação completa

3. **Performance**:
   - Overhead < 1ms por tentativa
   - Backoff eficiente
   - Taxa de sucesso > 95%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de retry
- [ ] Implementação do gerenciamento de retry
- [ ] Implementação dos decoradores e helpers
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
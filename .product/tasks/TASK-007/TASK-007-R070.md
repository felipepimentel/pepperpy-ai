# R070: Consolidação do Sistema de Compatibilidade

## Descrição

Unificar e padronizar o sistema de compatibilidade em todo o framework, criando uma abordagem consistente para lidar com versões legadas e migrações automáticas. O sistema atual possui diferentes implementações de compatibilidade espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, o código de compatibilidade está distribuído em vários módulos:

1. Em `memory/compat.py`:
```python
class BaseMemory(Generic[K, V]):
    """Legacy base memory interface."""
    
    async def list(
        self,
        type: str | None = None,
        scope: str | None = None,
        pattern: str | None = None,
    ) -> AsyncGenerator[MemoryEntry[V], None]:
        """List memory entries."""
        try:
            store = self._check_store()
            memory_query = NewMemoryQuery(
                query=pattern or "",
                index_type=MemoryIndex.SEMANTIC,
                filters=(
                    {}
                    if not type and not scope
                    else {
                        **({"type": _convert_type(type)} if type else {}),
                        **({"scope": _convert_scope(scope)} if scope else {}),
                    }
                ),
            )
            
            async for result in store.retrieve(memory_query):
                yield _convert_to_old_entry(cast(NewMemoryEntry[V], result.entry))
                
        except Exception as e:
            raise RuntimeError(f"Failed to list memory entries: {e}") from e
```

## Plano de Implementação

1. Criar sistema base de compatibilidade:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

T = TypeVar("T")
V = TypeVar("V")

class VersionInfo:
    """Version information."""
    
    def __init__(self, version: str):
        """Initialize version info."""
        self.version = version
        parts = version.split(".")
        self.major = int(parts[0])
        self.minor = int(parts[1])
        self.patch = int(parts[2])
        
    def __lt__(self, other: "VersionInfo") -> bool:
        """Compare versions."""
        return (
            self.major < other.major
            or (
                self.major == other.major
                and self.minor < other.minor
            )
            or (
                self.major == other.major
                and self.minor == other.minor
                and self.patch < other.patch
            )
        )

class Migration(ABC, Generic[T]):
    """Base class for migrations."""
    
    @property
    @abstractmethod
    def source_version(self) -> str:
        """Source version."""
        pass
        
    @property
    @abstractmethod
    def target_version(self) -> str:
        """Target version."""
        pass
        
    @abstractmethod
    async def migrate_forward(self, data: T) -> T:
        """Migrate data forward."""
        pass
        
    @abstractmethod
    async def migrate_backward(self, data: T) -> T:
        """Migrate data backward."""
        pass
```

2. Implementar sistema de gerenciamento de migrações:

```python
class MigrationManager:
    """Manager for data migrations."""
    
    def __init__(self):
        self._migrations: Dict[str, Dict[str, Migration]] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_migration(
        self,
        data_type: str,
        migration: Migration
    ) -> None:
        """Register a migration."""
        if data_type not in self._migrations:
            self._migrations[data_type] = {}
            
        key = f"{migration.source_version}->{migration.target_version}"
        self._migrations[data_type][key] = migration
        
    async def migrate(
        self,
        data_type: str,
        data: Any,
        source_version: str,
        target_version: str
    ) -> Any:
        """Migrate data between versions."""
        if data_type not in self._migrations:
            raise ValueError(f"No migrations for type: {data_type}")
            
        source = VersionInfo(source_version)
        target = VersionInfo(target_version)
        
        try:
            # Determine migration path
            path = self._find_migration_path(
                data_type,
                source_version,
                target_version
            )
            
            if not path:
                raise ValueError(
                    f"No migration path from {source_version} to {target_version}"
                )
                
            # Apply migrations
            result = data
            for migration in path:
                if source < target:
                    result = await migration.migrate_forward(result)
                else:
                    result = await migration.migrate_backward(result)
                    
            self._metrics.counter(
                "migrations",
                1,
                data_type=data_type,
                source=source_version,
                target=target_version,
                success="true"
            )
            
            return result
            
        except Exception as e:
            self._metrics.counter(
                "migrations",
                1,
                data_type=data_type,
                source=source_version,
                target=target_version,
                success="false"
            )
            
            self._logger.error(
                "Migration failed",
                extra={
                    "data_type": data_type,
                    "source": source_version,
                    "target": target_version,
                    "error": str(e)
                }
            )
            
            raise
            
    def _find_migration_path(
        self,
        data_type: str,
        source: str,
        target: str
    ) -> List[Migration]:
        """Find path between versions."""
        # Implementation using graph search
        pass
```

3. Implementar migrações específicas:

```python
class MemoryEntryMigration_1_0_0_to_2_0_0(Migration[Dict[str, Any]]):
    """Migration for memory entries from 1.0.0 to 2.0.0."""
    
    @property
    def source_version(self) -> str:
        return "1.0.0"
        
    @property
    def target_version(self) -> str:
        return "2.0.0"
        
    async def migrate_forward(
        self,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Migrate data forward."""
        return {
            "key": data["key"],
            "value": data["value"],
            "metadata": {
                "type": data.get("type"),
                "scope": data.get("scope"),
                "created_at": data.get("timestamp"),
                "version": "2.0.0"
            }
        }
        
    async def migrate_backward(
        self,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Migrate data backward."""
        metadata = data.get("metadata", {})
        return {
            "key": data["key"],
            "value": data["value"],
            "type": metadata.get("type"),
            "scope": metadata.get("scope"),
            "timestamp": metadata.get("created_at"),
            "version": "1.0.0"
        }

class ConfigMigration_1_0_0_to_2_0_0(Migration[Dict[str, Any]]):
    """Migration for config from 1.0.0 to 2.0.0."""
    
    @property
    def source_version(self) -> str:
        return "1.0.0"
        
    @property
    def target_version(self) -> str:
        return "2.0.0"
        
    async def migrate_forward(
        self,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Migrate data forward."""
        return {
            "settings": data,
            "metadata": {
                "version": "2.0.0",
                "created_at": datetime.now().isoformat()
            }
        }
        
    async def migrate_backward(
        self,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Migrate data backward."""
        settings = data.get("settings", {})
        settings["version"] = "1.0.0"
        return settings
```

4. Implementar sistema de monitoramento:

```python
class CompatibilityMonitor:
    """Monitor for compatibility operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_migration(
        self,
        data_type: str,
        source: str,
        target: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record migration operation."""
        self._metrics.counter(
            "compatibility_operations",
            1,
            operation="migrate",
            data_type=data_type,
            source=source,
            target=target,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `memory/compat.py`
   - Criar migrações para outros módulos
   - Implementar sistema de descoberta de migrações

## Validação

```python
async def test_compatibility_system():
    # Setup
    manager = MigrationManager()
    monitor = CompatibilityMonitor()
    
    # Register migrations
    memory_migration = MemoryEntryMigration_1_0_0_to_2_0_0()
    config_migration = ConfigMigration_1_0_0_to_2_0_0()
    
    manager.register_migration("memory", memory_migration)
    manager.register_migration("config", config_migration)
    
    # Test memory migration
    old_entry = {
        "key": "test",
        "value": "data",
        "type": "test",
        "scope": "global",
        "timestamp": "2024-02-22T00:00:00",
        "version": "1.0.0"
    }
    
    new_entry = await manager.migrate(
        "memory",
        old_entry,
        "1.0.0",
        "2.0.0"
    )
    
    assert new_entry["metadata"]["version"] == "2.0.0"
    
    # Test config migration
    old_config = {
        "setting": "value",
        "version": "1.0.0"
    }
    
    new_config = await manager.migrate(
        "config",
        old_config,
        "1.0.0",
        "2.0.0"
    )
    
    assert new_config["metadata"]["version"] == "2.0.0"
    
    # Test monitoring
    await monitor.record_migration("memory", "1.0.0", "2.0.0", True)
    await monitor.record_migration("config", "1.0.0", "2.0.0", True)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_compatibility_system():
    # Restore legacy implementations
    shutil.copy("memory/compat_legacy.py", "memory/compat.py")
    
    # Cleanup new implementations
    os.remove("core/compat/base.py")
    os.remove("core/compat/manager.py")
    os.remove("core/compat/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de compatibilidade
   - Interface consistente
   - Migrações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de migração não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 100ms para migrações
   - Uso eficiente de recursos
   - Cache de migrações compiladas

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de compatibilidade
- [ ] Implementação do gerenciamento de migrações
- [ ] Implementação das migrações específicas
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
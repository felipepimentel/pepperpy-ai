# R048: Unificação do Sistema de Lifecycle Management

## Descrição

Unificar o sistema de gerenciamento de ciclo de vida para garantir consistência na inicialização, limpeza e transições de estado em todo o framework. O sistema atual apresenta diferentes implementações de gerenciamento de ciclo de vida em diferentes módulos, dificultando a manutenção e aumentando a complexidade.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R026: Sistema de Resource Management
- R045: Unificação do Sistema de Gerenciamento de Recursos

## Estado Atual

Atualmente, o gerenciamento de ciclo de vida está disperso em vários módulos com diferentes implementações:

1. Em `core/resources.py`:
```python
class Resource(ABC):
    async def initialize(self) -> None:
        if self._initialized:
            return
        try:
            await self._initialize()
            self._initialized = True
            if self.auto_cleanup and self.cleanup_interval:
                self._cleanup_task = asyncio.create_task(self._run_cleanup())
        except Exception as e:
            raise LifecycleError(f"Failed to initialize resource: {e}")
```

2. Em `core/client.py`:
```python
class PepperpyClient(PepperpyClientProtocol, Lifecycle):
    def _ensure_initialized(self) -> None:
        if not self._initialized:
            raise StateError("Client not initialized")

    async def remove_agent(self, agent_id: UUID) -> None:
        try:
            if hasattr(agent, "cleanup"):
                await agent.cleanup()
            del self._agents[agent_id]
```

3. Em `agents/factory.py`:
```python
class AgentFactory(BaseComponent):
    async def cleanup(self) -> None:
        try:
            self._agent_types.clear()
            self._logger.info("Agent factory cleaned up")
            self._state = ComponentState.UNREGISTERED
        except Exception as e:
            self._state = ComponentState.ERROR
            self._logger.error(f"Error during factory cleanup: {e}")
            raise
```

## Plano de Implementação

1. Criar uma interface unificada para lifecycle management:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from enum import Enum
import asyncio

class LifecycleState(Enum):
    UNINITIALIZED = "uninitialized"
    INITIALIZING = "initializing"
    READY = "ready"
    ERROR = "error"
    CLEANING_UP = "cleaning_up"
    TERMINATED = "terminated"

class LifecycleManager(ABC):
    @abstractmethod
    async def initialize(self, **kwargs: Any) -> None:
        """Initialize the component."""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up the component."""
        pass
    
    @abstractmethod
    def get_state(self) -> LifecycleState:
        """Get current lifecycle state."""
        pass
    
    @abstractmethod
    async def wait_ready(self, timeout: Optional[float] = None) -> None:
        """Wait for component to be ready."""
        pass
```

2. Implementar o gerenciador de ciclo de vida padrão:

```python
class StandardLifecycleManager(LifecycleManager):
    def __init__(self):
        self._state = LifecycleState.UNINITIALIZED
        self._state_lock = asyncio.Lock()
        self._ready_event = asyncio.Event()
        self._cleanup_tasks: List[asyncio.Task] = []
        self._error: Optional[Exception] = None
        
    async def initialize(self, **kwargs: Any) -> None:
        async with self._state_lock:
            if self._state != LifecycleState.UNINITIALIZED:
                raise LifecycleError(f"Cannot initialize from state {self._state}")
            
            try:
                self._state = LifecycleState.INITIALIZING
                await self._do_initialize(**kwargs)
                self._state = LifecycleState.READY
                self._ready_event.set()
            except Exception as e:
                self._error = e
                self._state = LifecycleState.ERROR
                raise LifecycleError(f"Initialization failed: {e}")
    
    async def cleanup(self) -> None:
        async with self._state_lock:
            if self._state == LifecycleState.TERMINATED:
                return
                
            try:
                self._state = LifecycleState.CLEANING_UP
                await self._do_cleanup()
                for task in self._cleanup_tasks:
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        pass
                self._state = LifecycleState.TERMINATED
            except Exception as e:
                self._error = e
                self._state = LifecycleState.ERROR
                raise LifecycleError(f"Cleanup failed: {e}")
```

3. Criar decoradores para gerenciamento automático de ciclo de vida:

```python
def requires_state(state: LifecycleState):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            if self.get_state() != state:
                raise LifecycleError(
                    f"Operation requires state {state}, but current state is {self.get_state()}"
                )
            return await func(self, *args, **kwargs)
        return wrapper
    return decorator

def managed_lifecycle(auto_cleanup: bool = True):
    def decorator(cls):
        original_init = cls.__init__
        
        def __init__(self, *args, **kwargs):
            self._lifecycle = StandardLifecycleManager()
            original_init(self, *args, **kwargs)
            
        async def __aenter__(self):
            await self._lifecycle.initialize()
            return self
            
        async def __aexit__(self, exc_type, exc_val, exc_tb):
            if auto_cleanup:
                await self._lifecycle.cleanup()
                
        cls.__init__ = __init__
        cls.__aenter__ = __aenter__
        cls.__aexit__ = __aexit__
        return cls
    return decorator
```

4. Implementar monitoramento de ciclo de vida:

```python
class LifecycleMetrics:
    def __init__(self):
        self.state_transitions = Counter(
            "pepperpy_lifecycle_state_transitions",
            "Number of lifecycle state transitions"
        )
        self.initialization_time = Histogram(
            "pepperpy_lifecycle_initialization_time",
            "Time taken for initialization"
        )
        self.cleanup_time = Histogram(
            "pepperpy_lifecycle_cleanup_time",
            "Time taken for cleanup"
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/resources.py`
   - Refatorar `core/client.py`
   - Modificar `agents/factory.py`

## Validação

```python
async def test_lifecycle_management():
    # Setup
    @managed_lifecycle()
    class TestComponent:
        def __init__(self):
            self.data = []
            
        @requires_state(LifecycleState.READY)
        async def process(self):
            self.data.append("processed")
    
    # Test lifecycle
    async with TestComponent() as component:
        assert component._lifecycle.get_state() == LifecycleState.READY
        await component.process()
        assert component.data == ["processed"]
    
    assert component._lifecycle.get_state() == LifecycleState.TERMINATED
    
    # Test error handling
    component = TestComponent()
    try:
        await component.process()
        assert False, "Should raise LifecycleError"
    except LifecycleError:
        pass
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_lifecycle_system():
    # Restore legacy implementations
    shutil.copy("core/lifecycle_legacy.py", "core/lifecycle.py")
    shutil.copy("core/resources_legacy.py", "core/resources.py")
    
    # Cleanup new implementations
    os.remove("core/lifecycle_manager.py")
    os.remove("core/lifecycle_decorators.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - 100% dos componentes usando o novo sistema de lifecycle
   - Zero implementações customizadas de lifecycle
   - Cobertura completa de estados e transições

2. **Confiabilidade**:
   - Zero vazamentos de recursos após cleanup
   - 100% de sucesso em transições de estado
   - Tempo médio de recuperação < 1s

3. **Desempenho**:
   - Tempo médio de inicialização < 100ms
   - Tempo médio de cleanup < 50ms
   - Overhead de gerenciamento < 1ms

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface LifecycleManager
- [ ] Implementação do StandardLifecycleManager
- [ ] Implementação dos decoradores de lifecycle
- [ ] Implementação do sistema de métricas
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
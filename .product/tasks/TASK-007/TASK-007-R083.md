# R083: Padronização do Sistema de Extensões

## Descrição

Unificar e padronizar o sistema de extensões em todo o framework, estabelecendo uma interface consistente para o desenvolvimento e gerenciamento de extensões. O sistema atual possui diferentes implementações de extensões espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R067: Padronização do Sistema de Composição
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, as extensões estão distribuídas em vários módulos:

1. Em `core/extensions.py`:
```python
class Extension(Generic[T]):
    """Base class for extensions."""
    
    def __init__(self, config: T):
        self._config = config
        
    @property
    def config(self) -> T:
        """Get extension config."""
        return self._config
        
    async def initialize(self) -> None:
        """Initialize extension."""
        pass
        
    async def cleanup(self) -> None:
        """Cleanup extension."""
        pass
```

2. Em `core/layers.py`:
```python
class LayerExtension(Extension[T]):
    """Extension for layer functionality."""
    
    def __init__(self, config: T):
        super().__init__(config)
        self._layer = None
        
    @property
    def layer(self) -> Optional[Layer]:
        """Get extension layer."""
        return self._layer
        
    def set_layer(self, layer: Layer) -> None:
        """Set extension layer."""
        self._layer = layer
```

## Plano de Implementação

1. Criar sistema base de extensões:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union, Callable
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging

T = TypeVar("T")

class ExtensionType(Enum):
    """Extension types."""
    
    CORE = "core"
    LAYER = "layer"
    CAPABILITY = "capability"
    CUSTOM = "custom"

@dataclass
class ExtensionMetadata:
    """Metadata for extensions."""
    
    name: str
    type: ExtensionType
    description: str
    version: str
    dependencies: List[str] = field(default_factory=list)
    labels: Dict[str, str] = field(default_factory=dict)

class Extension(ABC, Generic[T]):
    """Base class for extensions."""
    
    def __init__(
        self,
        metadata: ExtensionMetadata,
        config: T
    ):
        self._metadata = metadata
        self._config = config
        self._state = {}
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> ExtensionMetadata:
        """Get extension metadata."""
        return self._metadata
        
    @property
    def config(self) -> T:
        """Get extension config."""
        return self._config
        
    @property
    def state(self) -> Dict[str, Any]:
        """Get extension state."""
        return self._state
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize extension."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup extension."""
        pass
        
    async def validate(self) -> None:
        """Validate extension."""
        pass
        
    async def reload(self) -> None:
        """Reload extension."""
        await self.cleanup()
        await self.initialize()
```

2. Implementar sistema de gerenciamento de extensões:

```python
class ExtensionManager:
    """Manager for extensions."""
    
    def __init__(self):
        self._extensions: Dict[str, Extension[Any]] = {}
        self._logger = logging.getLogger(__name__)
        
    async def register(
        self,
        extension: Extension[Any]
    ) -> None:
        """Register extension."""
        try:
            name = extension.metadata.name
            
            if name in self._extensions:
                raise ValueError(f"Extension {name} already registered")
                
            await extension.validate()
            await extension.initialize()
            
            self._extensions[name] = extension
            
        except Exception as e:
            self._logger.error(
                "Failed to register extension",
                extra={
                    "name": extension.metadata.name,
                    "type": extension.metadata.type.value,
                    "error": str(e)
                }
            )
            raise
            
    async def unregister(
        self,
        name: str
    ) -> None:
        """Unregister extension."""
        try:
            if name not in self._extensions:
                raise ValueError(f"Extension {name} not found")
                
            extension = self._extensions[name]
            await extension.cleanup()
            
            del self._extensions[name]
            
        except Exception as e:
            self._logger.error(
                "Failed to unregister extension",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    def get_extension(
        self,
        name: str
    ) -> Optional[Extension[Any]]:
        """Get extension by name."""
        return self._extensions.get(name)
        
    def get_extensions_by_type(
        self,
        type: ExtensionType
    ) -> List[Extension[Any]]:
        """Get extensions by type."""
        return [
            ext for ext in self._extensions.values()
            if ext.metadata.type == type
        ]
        
    async def reload_extension(
        self,
        name: str
    ) -> None:
        """Reload extension."""
        try:
            if name not in self._extensions:
                raise ValueError(f"Extension {name} not found")
                
            extension = self._extensions[name]
            await extension.reload()
            
        except Exception as e:
            self._logger.error(
                "Failed to reload extension",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            raise
            
    async def cleanup(self) -> None:
        """Cleanup all extensions."""
        for name in list(self._extensions.keys()):
            await self.unregister(name)
```

3. Implementar tipos comuns de extensões:

```python
class LayerExtension(Extension[T]):
    """Extension for layer functionality."""
    
    def __init__(
        self,
        metadata: ExtensionMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._layer = None
        
    @property
    def layer(self) -> Optional[Layer]:
        """Get extension layer."""
        return self._layer
        
    def set_layer(self, layer: Layer) -> None:
        """Set extension layer."""
        self._layer = layer
        
    async def initialize(self) -> None:
        """Initialize layer extension."""
        if self._layer is None:
            raise ValueError("Layer not set")
            
        await self._initialize_layer()
        
    async def cleanup(self) -> None:
        """Cleanup layer extension."""
        if self._layer is not None:
            await self._cleanup_layer()
            
    @abstractmethod
    async def _initialize_layer(self) -> None:
        """Initialize layer functionality."""
        pass
        
    @abstractmethod
    async def _cleanup_layer(self) -> None:
        """Cleanup layer functionality."""
        pass

class CapabilityExtension(Extension[T]):
    """Extension for capability functionality."""
    
    def __init__(
        self,
        metadata: ExtensionMetadata,
        config: T
    ):
        super().__init__(metadata, config)
        self._capability = None
        
    @property
    def capability(self) -> Optional[Capability]:
        """Get extension capability."""
        return self._capability
        
    def set_capability(self, capability: Capability) -> None:
        """Set extension capability."""
        self._capability = capability
        
    async def initialize(self) -> None:
        """Initialize capability extension."""
        if self._capability is None:
            raise ValueError("Capability not set")
            
        await self._initialize_capability()
        
    async def cleanup(self) -> None:
        """Cleanup capability extension."""
        if self._capability is not None:
            await self._cleanup_capability()
            
    @abstractmethod
    async def _initialize_capability(self) -> None:
        """Initialize capability functionality."""
        pass
        
    @abstractmethod
    async def _cleanup_capability(self) -> None:
        """Cleanup capability functionality."""
        pass
```

4. Implementar sistema de monitoramento:

```python
class ExtensionMonitor:
    """Monitor for extension operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def record_operation(
        self,
        operation: str,
        extension_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record extension operation."""
        try:
            self._metrics.counter(
                "extension_operations",
                1,
                operation=operation,
                type=extension_type,
                success=str(success).lower(),
                **labels
            )
            
            if success:
                self._metrics.histogram(
                    "extension_duration",
                    duration,
                    operation=operation,
                    type=extension_type,
                    **labels
                )
                
        except Exception as e:
            self._logger.error(
                "Failed to record extension operation",
                extra={
                    "operation": operation,
                    "type": extension_type,
                    "success": success,
                    "duration": duration,
                    "labels": labels,
                    "error": str(e)
                }
            )
```

5. Migrar implementações existentes:
   - Converter extensões para nova interface
   - Atualizar gerenciamento de extensões
   - Implementar monitoramento específico

## Validação

```python
async def test_extension_system():
    # Setup
    manager = ExtensionManager()
    monitor = ExtensionMonitor()
    
    # Create layer extension
    layer_metadata = ExtensionMetadata(
        name="test_layer",
        type=ExtensionType.LAYER,
        description="Test layer extension",
        version="1.0.0",
        dependencies=["core"],
        labels={"env": "test"}
    )
    
    layer_config = LayerConfig(
        name="test",
        enabled=True
    )
    
    layer_extension = TestLayerExtension(
        layer_metadata,
        layer_config
    )
    
    # Create capability extension
    capability_metadata = ExtensionMetadata(
        name="test_capability",
        type=ExtensionType.CAPABILITY,
        description="Test capability extension",
        version="1.0.0",
        dependencies=["core"],
        labels={"env": "test"}
    )
    
    capability_config = CapabilityConfig(
        name="test",
        enabled=True
    )
    
    capability_extension = TestCapabilityExtension(
        capability_metadata,
        capability_config
    )
    
    # Register extensions
    await manager.register(layer_extension)
    await manager.register(capability_extension)
    
    # Test operations
    extensions = manager.get_extensions_by_type(ExtensionType.LAYER)
    assert len(extensions) == 1
    assert extensions[0].metadata.name == "test_layer"
    
    extensions = manager.get_extensions_by_type(ExtensionType.CAPABILITY)
    assert len(extensions) == 1
    assert extensions[0].metadata.name == "test_capability"
    
    # Test reload
    await manager.reload_extension("test_layer")
    
    # Test unregister
    await manager.unregister("test_capability")
    
    # Test monitoring
    await monitor.record_operation(
        "register",
        "layer",
        True,
        0.001,
        name="test_layer"
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_extension_system():
    # Restore legacy implementations
    shutil.copy("core/extensions_legacy.py", "core/extensions.py")
    shutil.copy("core/layers_legacy.py", "core/layers.py")
    
    # Cleanup new implementations
    os.remove("core/extensions/base.py")
    os.remove("core/extensions/manager.py")
    os.remove("core/extensions/types.py")
    os.remove("core/extensions/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de extensões
   - Interface consistente
   - Metadados unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas de extensão
   - Documentação completa

3. **Performance**:
   - Latência < 1ms por operação
   - Baixo consumo de memória
   - Carregamento eficiente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de extensões
- [ ] Implementação do gerenciamento de extensões
- [ ] Implementação dos tipos comuns
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
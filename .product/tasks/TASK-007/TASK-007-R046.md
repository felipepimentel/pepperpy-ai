# R046: Padronização do Sistema de Registro e Logging

## Descrição

Padronizar o sistema de registro e logging para garantir consistência na coleta de métricas, rastreamento e observabilidade em todo o framework. O sistema atual apresenta diferentes padrões de logging e registro em diferentes módulos, dificultando a observabilidade e o diagnóstico de problemas.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R025: Sistema de Dependency Injection

## Estado Atual

Atualmente, o sistema de logging está disperso com diferentes padrões e implementações:

1. Em `core/config/manager.py`:
```python
class ConfigurationManager(Generic[T]):
    def __init__(self, config_class: Type[T]) -> None:
        self._metrics = MetricsManager.get_instance()
        self._file_reads: Optional[Counter] = None
        self._file_read_errors: Optional[Counter] = None
        self._validation_errors: Optional[Counter] = None
        logger.debug("Initialized configuration manager with class %s", 
                    config_class.__name__)
```

2. Em `agents/factory.py`:
```python
class AgentFactory(BaseComponent):
    async def cleanup(self) -> None:
        try:
            self._agent_types.clear()
            self._logger.info("Agent factory cleaned up")
            self._state = ComponentState.UNREGISTERED
        except Exception as e:
            self._state = ComponentState.ERROR
            self._logger.error(f"Error during factory cleanup: {e}")
            raise
```

3. Em `security/scanner.py`:
```python
class CodeVisitor(ast.NodeVisitor):
    def visit_Call(self, node: ast.Call) -> None:
        if isinstance(node.func, ast.Name):
            if node.func.id in self.config.banned_functions:
                self.issues.append(f"Use of banned function: {node.func.id}")
```

## Plano de Implementação

1. Criar uma interface unificada para logging:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from enum import Enum
import structlog
from opentelemetry import trace

class LogLevel(Enum):
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

class Logger(ABC):
    @abstractmethod
    def log(self, 
            level: LogLevel, 
            message: str, 
            **context: Any) -> None:
        """Log a message with context."""
        pass
    
    @abstractmethod
    def start_span(self, 
                  name: str, 
                  **attributes: Any) -> trace.Span:
        """Start a new tracing span."""
        pass
    
    @abstractmethod
    def record_metric(self, 
                     name: str, 
                     value: float, 
                     **labels: Any) -> None:
        """Record a metric value."""
        pass
```

2. Implementar o logger padrão:

```python
class StandardLogger(Logger):
    def __init__(self, 
                 name: str,
                 tracer: Optional[trace.Tracer] = None,
                 metrics: Optional[MetricsManager] = None):
        self._logger = structlog.get_logger(name)
        self._tracer = tracer or trace.get_tracer(name)
        self._metrics = metrics or MetricsManager.get_instance()
        
    def log(self, 
            level: LogLevel, 
            message: str, 
            **context: Any) -> None:
        log_method = getattr(self._logger, level.value)
        log_method(message, **context)
        
    def start_span(self, 
                  name: str, 
                  **attributes: Any) -> trace.Span:
        return self._tracer.start_span(name, attributes=attributes)
        
    def record_metric(self, 
                     name: str, 
                     value: float, 
                     **labels: Any) -> None:
        self._metrics.record(name, value, labels)
```

3. Criar decoradores para logging automático:

```python
def logged_operation(operation_name: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            logger = self.get_logger()
            with logger.start_span(operation_name) as span:
                try:
                    result = await func(self, *args, **kwargs)
                    span.set_attribute("status", "success")
                    return result
                except Exception as e:
                    span.set_attribute("status", "error")
                    span.set_attribute("error.type", e.__class__.__name__)
                    span.set_attribute("error.message", str(e))
                    logger.log(LogLevel.ERROR, 
                             f"{operation_name} failed",
                             error=str(e),
                             traceback=traceback.format_exc())
                    raise
        return wrapper
    return decorator
```

4. Implementar configuração estruturada de logging:

```python
class LoggingConfig:
    def __init__(self):
        self.formatters = {
            "json": {
                "format": "%(timestamp)s %(level)s %(name)s %(message)s",
                "datefmt": "%Y-%m-%d %H:%M:%S",
                "class": "pythonjsonlogger.jsonlogger.JsonFormatter"
            }
        }
        
        self.handlers = {
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "json",
                "stream": "ext://sys.stdout"
            }
        }
        
        self.root = {
            "level": "INFO",
            "handlers": ["console"]
        }
```

5. Migrar implementações existentes:
   - Atualizar `core/config/manager.py`
   - Refatorar `agents/factory.py`
   - Modificar `security/scanner.py`

## Validação

```python
async def test_logging_system():
    # Setup
    logger = StandardLogger("test")
    
    # Test basic logging
    logger.log(LogLevel.INFO, "Test message", context="test")
    
    # Test span creation
    with logger.start_span("test_operation") as span:
        span.set_attribute("test", "value")
        
    # Test metrics
    logger.record_metric("test_metric", 1.0, label="test")
    
    # Test decorator
    @logged_operation("test_func")
    async def test_func():
        return "success"
    
    result = await test_func()
    assert result == "success"
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_logging_system():
    # Restore legacy implementations
    shutil.copy("core/logging_legacy.py", "core/logging.py")
    shutil.copy("core/metrics_legacy.py", "core/metrics.py")
    
    # Cleanup new implementations
    os.remove("core/standard_logger.py")
    os.remove("core/logging_config.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - 100% dos módulos usando o novo sistema de logging
   - Zero implementações customizadas de logging
   - Formato consistente de logs em JSON

2. **Observabilidade**:
   - Tempo médio de detecção de problemas reduzido em 50%
   - 100% das operações críticas com rastreamento
   - Cobertura de métricas > 90%

3. **Desempenho**:
   - Overhead de logging < 5ms por operação
   - Latência de coleta de métricas < 10ms
   - Uso de memória do sistema de logging < 50MB

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface Logger
- [ ] Implementação do StandardLogger
- [ ] Implementação dos decoradores de logging
- [ ] Implementação da configuração estruturada
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R079: Padronização do Sistema de Contexto

## Descrição

Unificar e padronizar o sistema de contexto em todo o framework, criando uma abordagem consistente para gerenciamento e propagação de informações de contexto entre componentes. O sistema atual possui diferentes implementações de contexto espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R067: Padronização do Sistema de Composição
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, o contexto está distribuído em vários módulos:

1. Em `core/context.py`:
```python
class ExecutionContext:
    """Simple execution context."""
    
    def __init__(self):
        self._data = {}
        
    def set(self, key: str, value: Any) -> None:
        """Set context value."""
        self._data[key] = value
        
    def get(self, key: str) -> Any:
        """Get context value."""
        return self._data.get(key)
```

2. Em `agents/context.py`:
```python
class AgentContext:
    """Context for agent execution."""
    
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        self.start_time = time.time()
        self.metadata = {}
        
    def add_metadata(self, key: str, value: Any) -> None:
        """Add metadata to context."""
        self.metadata[key] = value
```

## Plano de Implementação

1. Criar sistema base de contexto:

```python
from typing import Any, Dict, Generic, Optional, Type, TypeVar, Union
from contextlib import asynccontextmanager
from dataclasses import dataclass, field
from datetime import datetime
import asyncio
import uuid

T = TypeVar("T")

@dataclass
class ContextMetadata:
    """Metadata for context."""
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = field(default_factory=datetime.now)
    parent_id: Optional[str] = None
    trace_id: Optional[str] = None
    labels: Dict[str, str] = field(default_factory=dict)

class Context:
    """Base context class."""
    
    def __init__(
        self,
        metadata: Optional[ContextMetadata] = None
    ):
        self._metadata = metadata or ContextMetadata()
        self._data: Dict[str, Any] = {}
        self._children: Dict[str, "Context"] = {}
        
    @property
    def metadata(self) -> ContextMetadata:
        """Get context metadata."""
        return self._metadata
        
    def set(self, key: str, value: Any) -> None:
        """Set context value."""
        self._data[key] = value
        
    def get(self, key: str, default: Any = None) -> Any:
        """Get context value."""
        return self._data.get(key, default)
        
    def child(self, **labels: str) -> "Context":
        """Create child context."""
        metadata = ContextMetadata(
            parent_id=self.metadata.id,
            trace_id=self.metadata.trace_id,
            labels=labels
        )
        context = Context(metadata)
        self._children[metadata.id] = context
        return context
        
    def merge(self, other: "Context") -> None:
        """Merge another context."""
        self._data.update(other._data)
        self._children.update(other._children)

class ContextStack:
    """Stack for nested contexts."""
    
    def __init__(self):
        self._stack: List[Context] = []
        
    def push(self, context: Context) -> None:
        """Push context to stack."""
        self._stack.append(context)
        
    def pop(self) -> Context:
        """Pop context from stack."""
        return self._stack.pop()
        
    @property
    def current(self) -> Optional[Context]:
        """Get current context."""
        return self._stack[-1] if self._stack else None
```

2. Implementar sistema de gerenciamento de contexto:

```python
class ContextManager:
    """Manager for contexts."""
    
    def __init__(self):
        self._stack = ContextStack()
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    @property
    def current(self) -> Optional[Context]:
        """Get current context."""
        return self._stack.current
        
    @asynccontextmanager
    async def context(
        self,
        **labels: str
    ) -> AsyncGenerator[Context, None]:
        """Create and manage context."""
        parent = self.current
        context = (
            parent.child(**labels)
            if parent
            else Context(
                ContextMetadata(labels=labels)
            )
        )
        
        try:
            start = time.perf_counter()
            self._stack.push(context)
            
            self._metrics.counter(
                "context_operations",
                1,
                operation="create",
                success="true"
            )
            
            yield context
            
        except Exception as e:
            self._metrics.counter(
                "context_operations",
                1,
                operation="create",
                success="false"
            )
            
            self._logger.error(
                "Context creation failed",
                extra={
                    "error": str(e)
                }
            )
            
            raise
            
        finally:
            duration = time.perf_counter() - start
            self._stack.pop()
            
            self._metrics.histogram(
                "context_duration",
                duration,
                **context.metadata.labels
            )
            
    def get(self, key: str, default: Any = None) -> Any:
        """Get value from current context."""
        if not self.current:
            return default
        return self.current.get(key, default)
        
    def set(self, key: str, value: Any) -> None:
        """Set value in current context."""
        if not self.current:
            raise RuntimeError("No active context")
        self.current.set(key, value)
```

3. Implementar contextos específicos:

```python
@dataclass
class AgentContext(Context):
    """Context for agent execution."""
    
    agent_id: str
    model: str
    temperature: float = 0.7
    max_tokens: int = 1000
    
    def __post_init__(self) -> None:
        super().__init__()
        self.set("agent_id", self.agent_id)
        self.set("model", self.model)
        self.set("temperature", self.temperature)
        self.set("max_tokens", self.max_tokens)

@dataclass
class ProcessorContext(Context):
    """Context for processor execution."""
    
    processor_id: str
    batch_size: int = 100
    timeout: float = 30.0
    
    def __post_init__(self) -> None:
        super().__init__()
        self.set("processor_id", self.processor_id)
        self.set("batch_size", self.batch_size)
        self.set("timeout", self.timeout)

@dataclass
class RequestContext(Context):
    """Context for request handling."""
    
    request_id: str
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    
    def __post_init__(self) -> None:
        super().__init__()
        self.set("request_id", self.request_id)
        if self.user_id:
            self.set("user_id", self.user_id)
        if self.session_id:
            self.set("session_id", self.session_id)
```

4. Implementar sistema de monitoramento:

```python
class ContextMonitor:
    """Monitor for context operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        context_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record context operation."""
        self._metrics.counter(
            "context_operations",
            1,
            operation=operation,
            type=context_type,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "context_duration",
                duration,
                operation=operation,
                type=context_type,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter contextos para nova interface
   - Atualizar uso de contextos
   - Implementar propagação automática

## Validação

```python
async def test_context_system():
    # Setup
    manager = ContextManager()
    monitor = ContextMonitor()
    
    # Test basic context
    async with manager.context(type="test") as ctx:
        ctx.set("key", "value")
        assert ctx.get("key") == "value"
        
        # Test nested context
        async with manager.context(type="nested") as nested:
            nested.set("nested_key", "nested_value")
            assert nested.get("nested_key") == "nested_value"
            assert nested.metadata.parent_id == ctx.metadata.id
            
    # Test agent context
    agent_ctx = AgentContext(
        agent_id="test_agent",
        model="gpt-4"
    )
    
    assert agent_ctx.get("agent_id") == "test_agent"
    assert agent_ctx.get("model") == "gpt-4"
    
    # Test processor context
    processor_ctx = ProcessorContext(
        processor_id="test_processor",
        batch_size=200
    )
    
    assert processor_ctx.get("processor_id") == "test_processor"
    assert processor_ctx.get("batch_size") == 200
    
    # Test request context
    request_ctx = RequestContext(
        request_id="test_request",
        user_id="test_user"
    )
    
    assert request_ctx.get("request_id") == "test_request"
    assert request_ctx.get("user_id") == "test_user"
    
    # Test monitoring
    await monitor.record_operation(
        "create",
        "agent",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_context_system():
    # Restore legacy implementations
    shutil.copy("core/context_legacy.py", "core/context.py")
    shutil.copy("agents/context_legacy.py", "agents/context.py")
    
    # Cleanup new implementations
    os.remove("core/context/base.py")
    os.remove("core/context/manager.py")
    os.remove("core/context/contexts.py")
    os.remove("core/context/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de contexto
   - Interface consistente
   - Propagação automática

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de contexto
   - Documentação completa

3. **Performance**:
   - Overhead < 0.1ms por operação
   - Uso eficiente de memória
   - Limpeza garantida

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de contexto
- [ ] Implementação do gerenciamento de contexto
- [ ] Implementação dos contextos específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
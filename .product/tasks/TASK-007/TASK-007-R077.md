# R077: Padronização do Sistema de Plugins

## Descrição

Unificar e padronizar o sistema de plugins em todo o framework, criando uma abordagem consistente para extensões através de pontos de extensão bem definidos. O sistema atual possui diferentes abordagens para extensibilidade espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R066: Unificação do Sistema de Carregamento Dinâmico
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, a extensibilidade está distribuída em vários módulos:

1. Em `core/plugins.py`:
```python
def load_plugin(path: str) -> Any:
    """Load plugin from path."""
    module = importlib.import_module(path)
    return module.plugin
```

2. Em `agents/registry.py`:
```python
class ProviderRegistry:
    """Registry for agent providers."""
    
    def __init__(self):
        self._providers = {}
        
    def register(self, name: str, provider: Type[Provider]) -> None:
        """Register provider."""
        self._providers[name] = provider
```

## Plano de Implementação

1. Criar sistema base de plugins:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
import importlib
import inspect
import pkgutil

T = TypeVar("T", bound="Plugin")

class PluginType(Enum):
    """Plugin types."""
    
    PROVIDER = "provider"
    PROCESSOR = "processor"
    STORAGE = "storage"
    MONITOR = "monitor"

@dataclass
class PluginMetadata:
    """Metadata for plugins."""
    
    name: str
    version: str
    description: str
    author: str
    dependencies: List[str]
    plugin_type: PluginType
    entry_point: str

class Plugin(ABC):
    """Base class for plugins."""
    
    @property
    @abstractmethod
    def metadata(self) -> PluginMetadata:
        """Get plugin metadata."""
        pass
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize plugin."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup plugin."""
        pass

class PluginError(Exception):
    """Base class for plugin errors."""
    pass

class PluginNotFoundError(PluginError):
    """Error when plugin is not found."""
    pass

class PluginLoadError(PluginError):
    """Error when plugin fails to load."""
    pass

class PluginDependencyError(PluginError):
    """Error when plugin dependencies are not met."""
    pass
```

2. Implementar sistema de gerenciamento de plugins:

```python
class PluginManager:
    """Manager for plugins."""
    
    def __init__(self):
        self._plugins: Dict[str, Plugin] = {}
        self._metadata: Dict[str, PluginMetadata] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_plugin(
        self,
        plugin: Plugin
    ) -> None:
        """Register a plugin."""
        metadata = plugin.metadata
        if metadata.name in self._plugins:
            raise PluginError(f"Plugin already registered: {metadata.name}")
            
        self._plugins[metadata.name] = plugin
        self._metadata[metadata.name] = metadata
        
    async def load_plugin(
        self,
        path: str
    ) -> Plugin:
        """Load plugin from path."""
        try:
            start = time.perf_counter()
            module = importlib.import_module(path)
            
            # Find plugin class
            plugin_class = None
            for name, obj in inspect.getmembers(module):
                if (
                    inspect.isclass(obj)
                    and issubclass(obj, Plugin)
                    and obj != Plugin
                ):
                    plugin_class = obj
                    break
                    
            if not plugin_class:
                raise PluginNotFoundError(
                    f"No plugin class found in: {path}"
                )
                
            # Create plugin instance
            plugin = plugin_class()
            await plugin.initialize()
            
            duration = time.perf_counter() - start
            
            self._metrics.counter(
                "plugin_loads",
                1,
                path=path,
                success="true"
            )
            
            self._metrics.histogram(
                "plugin_load_duration",
                duration,
                path=path
            )
            
            return plugin
            
        except Exception as e:
            self._metrics.counter(
                "plugin_loads",
                1,
                path=path,
                success="false"
            )
            
            self._logger.error(
                "Failed to load plugin",
                extra={
                    "path": path,
                    "error": str(e)
                }
            )
            
            raise PluginLoadError(f"Failed to load plugin: {e}") from e
            
    async def discover_plugins(
        self,
        package: str
    ) -> List[str]:
        """Discover plugins in package."""
        try:
            paths = []
            for finder, name, _ in pkgutil.iter_modules([package]):
                if name.startswith("plugin_"):
                    paths.append(f"{package}.{name}")
                    
            self._metrics.counter(
                "plugin_discoveries",
                len(paths),
                package=package,
                success="true"
            )
            
            return paths
            
        except Exception as e:
            self._metrics.counter(
                "plugin_discoveries",
                1,
                package=package,
                success="false"
            )
            
            self._logger.error(
                "Failed to discover plugins",
                extra={
                    "package": package,
                    "error": str(e)
                }
            )
            
            raise PluginError(f"Failed to discover plugins: {e}") from e
            
    def get_plugin(
        self,
        name: str
    ) -> Plugin:
        """Get plugin by name."""
        if name not in self._plugins:
            raise PluginNotFoundError(f"Plugin not found: {name}")
        return self._plugins[name]
        
    def get_plugins_by_type(
        self,
        plugin_type: PluginType
    ) -> List[Plugin]:
        """Get plugins by type."""
        return [
            plugin
            for plugin in self._plugins.values()
            if plugin.metadata.plugin_type == plugin_type
        ]
        
    async def cleanup(self) -> None:
        """Cleanup all plugins."""
        for plugin in self._plugins.values():
            try:
                await plugin.cleanup()
            except Exception as e:
                self._logger.error(
                    "Failed to cleanup plugin",
                    extra={
                        "plugin": plugin.metadata.name,
                        "error": str(e)
                    }
                )
```

3. Implementar decoradores e helpers:

```python
def plugin(
    name: str,
    version: str,
    description: str,
    author: str,
    plugin_type: PluginType,
    dependencies: Optional[List[str]] = None
) -> Callable:
    """Decorator for plugin classes."""
    def decorator(cls: Type[Plugin]) -> Type[Plugin]:
        metadata = PluginMetadata(
            name=name,
            version=version,
            description=description,
            author=author,
            dependencies=dependencies or [],
            plugin_type=plugin_type,
            entry_point=f"{cls.__module__}.{cls.__name__}"
        )
        
        # Add metadata to class
        setattr(cls, "_metadata", metadata)
        
        # Add metadata property
        def get_metadata(self: Plugin) -> PluginMetadata:
            return self._metadata
            
        setattr(cls, "metadata", property(get_metadata))
        
        return cls
    return decorator

class PluginContextManager:
    """Context manager for plugins."""
    
    def __init__(self, plugin: Plugin):
        self.plugin = plugin
        
    async def __aenter__(self) -> Plugin:
        """Enter plugin context."""
        await self.plugin.initialize()
        return self.plugin
        
    async def __aexit__(self, *args: Any) -> None:
        """Exit plugin context."""
        await self.plugin.cleanup()
```

4. Implementar sistema de monitoramento:

```python
class PluginMonitor:
    """Monitor for plugin operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        plugin: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record plugin operation."""
        self._metrics.counter(
            "plugin_operations",
            1,
            operation=operation,
            plugin=plugin,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "plugin_duration",
                duration,
                operation=operation,
                plugin=plugin,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter extensões para plugins
   - Atualizar pontos de extensão
   - Implementar descoberta automática

## Validação

```python
async def test_plugin_system():
    # Setup
    manager = PluginManager()
    monitor = PluginMonitor()
    
    # Test plugin decorator
    @plugin(
        name="test_plugin",
        version="1.0.0",
        description="Test plugin",
        author="Test Author",
        plugin_type=PluginType.PROVIDER
    )
    class TestPlugin(Plugin):
        async def initialize(self) -> None:
            pass
            
        async def cleanup(self) -> None:
            pass
            
    # Test plugin loading
    plugin = TestPlugin()
    manager.register_plugin(plugin)
    
    loaded = manager.get_plugin("test_plugin")
    assert loaded.metadata.name == "test_plugin"
    
    # Test plugin discovery
    paths = await manager.discover_plugins("plugins")
    assert len(paths) > 0
    
    # Test plugin types
    providers = manager.get_plugins_by_type(PluginType.PROVIDER)
    assert len(providers) == 1
    
    # Test context manager
    async with PluginContextManager(plugin):
        pass
        
    # Test monitoring
    await monitor.record_operation(
        "load",
        "test_plugin",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_plugin_system():
    # Restore legacy implementations
    shutil.copy("core/plugins_legacy.py", "core/plugins.py")
    shutil.copy("agents/registry_legacy.py", "agents/registry.py")
    
    # Cleanup new implementations
    os.remove("core/plugins/base.py")
    os.remove("core/plugins/manager.py")
    os.remove("core/plugins/decorators.py")
    os.remove("core/plugins/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de plugins
   - Interface consistente
   - Pontos de extensão unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falhas de carregamento
   - Documentação completa

3. **Performance**:
   - Latência < 100ms para carregamento
   - Descoberta eficiente
   - Isolamento de falhas

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de plugins
- [ ] Implementação do gerenciamento de plugins
- [ ] Implementação dos decoradores e helpers
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
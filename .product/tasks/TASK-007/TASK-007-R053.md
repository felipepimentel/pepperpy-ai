# R053: Consolidação do Sistema de Tratamento de Erros

## Descrição

Consolidar o sistema de tratamento de erros para garantir consistência no tratamento e recuperação de erros em todo o framework. O sistema atual apresenta diferentes padrões de tratamento de erros em diferentes módulos, dificultando o diagnóstico e a recuperação de falhas.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Unificação do Tratamento de Erros

## Estado Atual

Atualmente, o tratamento de erros está disperso em diferentes módulos:

1. Em `core/errors.py`:
```python
class DuplicateError(PepperpyError):
    def __init__(
        self,
        message: str,
        details: Optional[Dict[str, Any]] = None,
    ) -> None:
        error_details = {"error_code": "ERR014", **(details or {})}
        super().__init__(
            message,
            code="ERR014",
            details=error_details,
        )

def get_error_class(code: str) -> Type[PepperpyError]:
    error_classes = {
        "ERR000": PepperpyError,
        "ERR001": ConfigError,
        "ERR002": ValidationError,
        # ...
    }
    if code not in error_classes:
        raise ValueError(f"Unknown error code: {code}")
    return error_classes[code]
```

2. Em diferentes módulos, erros são tratados de forma inconsistente:
```python
# Em alguns lugares
raise ConfigurationError(f"Invalid path: {path}")

# Em outros
raise ValidationError("path", str(path), "Path does not exist")

# E ainda em outros
raise RuntimeError(f"Failed to load: {e}")
```

## Plano de Implementação

1. Criar uma hierarquia unificada de erros:

```python
from abc import ABC
from typing import Any, Dict, Optional, Type
from enum import Enum
from dataclasses import dataclass

class ErrorLevel(Enum):
    CRITICAL = "critical"
    ERROR = "error"
    WARNING = "warning"

class ErrorCategory(Enum):
    CONFIGURATION = "configuration"
    VALIDATION = "validation"
    RUNTIME = "runtime"
    SECURITY = "security"
    RESOURCE = "resource"
    STATE = "state"
    NETWORK = "network"
    DATABASE = "database"

@dataclass
class ErrorContext:
    code: str
    category: ErrorCategory
    level: ErrorLevel
    details: Optional[Dict[str, Any]] = None
    recovery_hint: Optional[str] = None
    source: Optional[str] = None
    traceback: Optional[str] = None

class PepperpyError(Exception):
    """Base class for all framework errors."""
    
    def __init__(
        self,
        message: str,
        context: ErrorContext
    ) -> None:
        super().__init__(message)
        self.message = message
        self.context = context
        
    def __str__(self) -> str:
        return f"[{self.context.code}] {self.message}"
        
    def to_dict(self) -> Dict[str, Any]:
        return {
            "code": self.context.code,
            "category": self.context.category.value,
            "level": self.context.level.value,
            "message": self.message,
            "details": self.context.details,
            "recovery_hint": self.context.recovery_hint,
            "source": self.context.source,
            "traceback": self.context.traceback
        }
```

2. Implementar erros específicos:

```python
class ConfigurationError(PepperpyError):
    """Erro de configuração."""
    
    def __init__(
        self,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        recovery_hint: Optional[str] = None
    ) -> None:
        context = ErrorContext(
            code="ERR001",
            category=ErrorCategory.CONFIGURATION,
            level=ErrorLevel.ERROR,
            details=details,
            recovery_hint=recovery_hint,
            source=self.__class__.__module__
        )
        super().__init__(message, context)

class ValidationError(PepperpyError):
    """Erro de validação."""
    
    def __init__(
        self,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        recovery_hint: Optional[str] = None
    ) -> None:
        context = ErrorContext(
            code="ERR002",
            category=ErrorCategory.VALIDATION,
            level=ErrorLevel.ERROR,
            details=details,
            recovery_hint=recovery_hint,
            source=self.__class__.__module__
        )
        super().__init__(message, context)

class SecurityError(PepperpyError):
    """Erro de segurança."""
    
    def __init__(
        self,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        recovery_hint: Optional[str] = None
    ) -> None:
        context = ErrorContext(
            code="ERR003",
            category=ErrorCategory.SECURITY,
            level=ErrorLevel.CRITICAL,
            details=details,
            recovery_hint=recovery_hint,
            source=self.__class__.__module__
        )
        super().__init__(message, context)
```

3. Implementar gerenciador de erros:

```python
class ErrorManager:
    """Gerenciador central de erros."""
    
    def __init__(self):
        self._error_handlers: Dict[ErrorCategory, List[Callable]] = {}
        self._metrics = MetricsManager.get_instance()
        
    def register_handler(
        self,
        category: ErrorCategory,
        handler: Callable[[PepperpyError], None]
    ) -> None:
        """Registrar handler para categoria de erro."""
        if category not in self._error_handlers:
            self._error_handlers[category] = []
        self._error_handlers[category].append(handler)
        
    async def handle_error(self, error: PepperpyError) -> None:
        """Tratar erro usando handlers registrados."""
        try:
            # Record metrics
            self._metrics.counter(
                f"pepperpy_errors_{error.context.category.value}",
                1,
                level=error.context.level.value
            )
            
            # Call handlers
            handlers = self._error_handlers.get(error.context.category, [])
            for handler in handlers:
                try:
                    if inspect.iscoroutinefunction(handler):
                        await handler(error)
                    else:
                        handler(error)
                except Exception as e:
                    logger.error(
                        f"Error handler failed: {e}",
                        extra={"error": error.to_dict()}
                    )
                    
        except Exception as e:
            logger.error(
                f"Failed to handle error: {e}",
                extra={"error": error.to_dict()}
            )
```

4. Implementar decoradores para tratamento de erros:

```python
def handle_errors(
    *categories: ErrorCategory,
    recovery_action: Optional[Callable] = None
):
    """Decorador para tratamento automático de erros."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                if inspect.iscoroutinefunction(func):
                    return await func(*args, **kwargs)
                return func(*args, **kwargs)
            except PepperpyError as e:
                if e.context.category in categories:
                    await error_manager.handle_error(e)
                    if recovery_action:
                        return await recovery_action(e)
                raise
            except Exception as e:
                error = PepperpyError(
                    str(e),
                    ErrorContext(
                        code="ERR000",
                        category=ErrorCategory.RUNTIME,
                        level=ErrorLevel.ERROR,
                        details={"original_error": str(e)},
                        source=func.__module__,
                        traceback=traceback.format_exc()
                    )
                )
                await error_manager.handle_error(error)
                raise
        return wrapper
    return decorator
```

5. Migrar implementações existentes:
   - Atualizar `core/errors.py`
   - Refatorar tratamento de erros em todos os módulos
   - Implementar handlers específicos para cada categoria

## Validação

```python
async def test_error_handling():
    # Setup
    manager = ErrorManager()
    handled_errors = []
    
    def error_handler(error: PepperpyError) -> None:
        handled_errors.append(error)
    
    manager.register_handler(ErrorCategory.VALIDATION, error_handler)
    
    # Test error handling
    @handle_errors(ErrorCategory.VALIDATION)
    async def validate_data(data: Dict[str, Any]) -> None:
        if "required_field" not in data:
            raise ValidationError(
                "Missing required field",
                details={"field": "required_field"}
            )
    
    try:
        await validate_data({})
        assert False, "Should raise ValidationError"
    except ValidationError as e:
        assert e.context.code == "ERR002"
        assert len(handled_errors) == 1
        assert handled_errors[0].context.category == ErrorCategory.VALIDATION
        
    # Test error conversion
    @handle_errors(ErrorCategory.RUNTIME)
    async def risky_operation() -> None:
        raise ValueError("Something went wrong")
        
    try:
        await risky_operation()
        assert False, "Should raise PepperpyError"
    except PepperpyError as e:
        assert e.context.code == "ERR000"
        assert e.context.category == ErrorCategory.RUNTIME
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_error_handling():
    # Restore legacy implementations
    shutil.copy("core/errors_legacy.py", "core/errors.py")
    
    # Cleanup new implementations
    os.remove("core/error_manager.py")
    os.remove("core/error_decorators.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - 100% dos erros usando o novo sistema
   - Zero tratamentos de erro customizados
   - Cobertura completa de categorias

2. **Qualidade**:
   - 100% dos erros com contexto completo
   - Zero erros não tratados
   - Documentação completa

3. **Observabilidade**:
   - Tempo médio de diagnóstico reduzido em 50%
   - 100% dos erros com métricas
   - Taxa de recuperação > 90%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da hierarquia de erros
- [ ] Implementação dos erros específicos
- [ ] Implementação do ErrorManager
- [ ] Implementação dos decoradores
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
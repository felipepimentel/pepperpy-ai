# R067: Padronização do Sistema de Composição

## Descrição

Unificar e padronizar o sistema de composição em todo o framework, estabelecendo uma interface consistente para composição de componentes e gerenciamento de dependências. O sistema atual possui diferentes abordagens para composição espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, a composição está distribuída em vários módulos:

1. Em `memory/stores/composite.py`:
```python
class CompositeMemoryStore(BaseMemoryStore[Dict[str, Any]]):
    """Composite memory store implementation."""
    
    def __init__(self, stores: List[BaseMemoryStore]):
        self._stores = stores
        
    async def retrieve(
        self,
        query: MemoryQuery
    ) -> AsyncIterator[MemoryResult[Dict[str, Any]]]:
        """Retrieve entries from memory."""
        seen_keys = set()
        for store in self._stores:
            try:
                async for result in store.retrieve(query):
                    if result.key not in seen_keys:
                        seen_keys.add(result.key)
                        yield result
            except Exception as e:
                logger.error(
                    "Failed to retrieve from store",
                    extra={"error": str(e)}
                )
```

2. Em `core/layers.py`:
```python
class Layer(ABC):
    """Base class for architectural layers."""
    
    def __init__(self, name: str) -> None:
        self.name = name
        self._extension_points: Dict[str, ExtensionPoint] = {}
        self._initialized = False
        
    async def initialize(self) -> None:
        """Initialize layer and its extension points."""
        if self._initialized:
            return
            
        try:
            # Initialize extension points
            extension_points = await self._get_extension_points()
            for point_name, point_type in extension_points.items():
                self._extension_points[point_name] = ExtensionPoint(
                    f"{self.name}.{point_name}",
                    point_type
                )
                
            self._initialized = True
            
        except Exception as e:
            logger.error(f"Failed to initialize layer {self.name}: {e}")
            raise
```

## Plano de Implementação

1. Criar sistema base de composição:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar
from dataclasses import dataclass
from datetime import datetime

T = TypeVar("T")
C = TypeVar("C", bound="Component")

@dataclass
class ComponentMetadata:
    """Metadata for components."""
    id: str
    name: str
    version: str
    created_at: datetime
    dependencies: List[str]
    capabilities: List[str]
    metadata: Dict[str, Any]

class Component(ABC, Generic[T]):
    """Base class for composable components."""
    
    def __init__(self) -> None:
        """Initialize component."""
        self._metadata = ComponentMetadata(
            id=str(uuid.uuid4()),
            name=self.__class__.__name__,
            version="1.0.0",
            created_at=datetime.now(),
            dependencies=[],
            capabilities=[],
            metadata={}
        )
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> ComponentMetadata:
        """Get component metadata."""
        return self._metadata
        
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize component."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up component resources."""
        pass
        
    @abstractmethod
    async def validate(self) -> List[str]:
        """Validate component state."""
        pass

class CompositeComponent(Component[T]):
    """Base class for composite components."""
    
    def __init__(self) -> None:
        """Initialize composite."""
        super().__init__()
        self._components: Dict[str, Component] = {}
        
    async def add_component(
        self,
        name: str,
        component: Component
    ) -> None:
        """Add a component."""
        if name in self._components:
            raise ValueError(f"Component already exists: {name}")
            
        self._components[name] = component
        self._metadata.dependencies.extend(component.metadata.dependencies)
        self._metadata.capabilities.extend(component.metadata.capabilities)
        
    async def remove_component(
        self,
        name: str
    ) -> None:
        """Remove a component."""
        if name not in self._components:
            raise ValueError(f"Component not found: {name}")
            
        component = self._components[name]
        await component.cleanup()
        del self._components[name]
        
    async def get_component(
        self,
        name: str
    ) -> Component:
        """Get a component."""
        if name not in self._components:
            raise ValueError(f"Component not found: {name}")
            
        return self._components[name]
        
    async def initialize(self) -> None:
        """Initialize all components."""
        for component in self._components.values():
            try:
                await component.initialize()
            except Exception as e:
                self._logger.error(
                    "Failed to initialize component",
                    extra={
                        "component": component.metadata.name,
                        "error": str(e)
                    }
                )
                raise
                
    async def cleanup(self) -> None:
        """Clean up all components."""
        for component in self._components.values():
            try:
                await component.cleanup()
            except Exception as e:
                self._logger.error(
                    "Failed to clean up component",
                    extra={
                        "component": component.metadata.name,
                        "error": str(e)
                    }
                )
                
    async def validate(self) -> List[str]:
        """Validate all components."""
        errors = []
        
        for component in self._components.values():
            try:
                component_errors = await component.validate()
                errors.extend(component_errors)
            except Exception as e:
                errors.append(
                    f"Failed to validate component {component.metadata.name}: {e}"
                )
                
        return errors
```

2. Implementar sistema de gerenciamento unificado:

```python
class CompositionManager:
    """Manager for component composition."""
    
    def __init__(self):
        self._composites: Dict[str, CompositeComponent] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def create_composite(
        self,
        name: str,
        composite_type: Type[C]
    ) -> C:
        """Create a composite component."""
        if name in self._composites:
            raise ValueError(f"Composite already exists: {name}")
            
        composite = composite_type()
        self._composites[name] = composite
        
        return composite
        
    async def add_component(
        self,
        composite_name: str,
        component_name: str,
        component: Component
    ) -> None:
        """Add a component to a composite."""
        if composite_name not in self._composites:
            raise ValueError(f"Composite not found: {composite_name}")
            
        composite = self._composites[composite_name]
        
        try:
            await composite.add_component(component_name, component)
            
            self._metrics.counter(
                "composition_operations",
                1,
                operation="add_component",
                composite=composite_name,
                success="true"
            )
            
        except Exception as e:
            self._metrics.counter(
                "composition_operations",
                1,
                operation="add_component",
                composite=composite_name,
                success="false"
            )
            
            self._logger.error(
                "Failed to add component",
                extra={
                    "composite": composite_name,
                    "component": component_name,
                    "error": str(e)
                }
            )
            
            raise
            
    async def remove_component(
        self,
        composite_name: str,
        component_name: str
    ) -> None:
        """Remove a component from a composite."""
        if composite_name not in self._composites:
            raise ValueError(f"Composite not found: {composite_name}")
            
        composite = self._composites[composite_name]
        
        try:
            await composite.remove_component(component_name)
            
            self._metrics.counter(
                "composition_operations",
                1,
                operation="remove_component",
                composite=composite_name,
                success="true"
            )
            
        except Exception as e:
            self._metrics.counter(
                "composition_operations",
                1,
                operation="remove_component",
                composite=composite_name,
                success="false"
            )
            
            self._logger.error(
                "Failed to remove component",
                extra={
                    "composite": composite_name,
                    "component": component_name,
                    "error": str(e)
                }
            )
            
            raise
            
    async def get_composite(
        self,
        name: str
    ) -> CompositeComponent:
        """Get a composite component."""
        if name not in self._composites:
            raise ValueError(f"Composite not found: {name}")
            
        return self._composites[name]
        
    async def initialize_all(self) -> None:
        """Initialize all composites."""
        for composite in self._composites.values():
            try:
                await composite.initialize()
            except Exception as e:
                self._logger.error(
                    "Failed to initialize composite",
                    extra={
                        "composite": composite.metadata.name,
                        "error": str(e)
                    }
                )
                raise
                
    async def cleanup_all(self) -> None:
        """Clean up all composites."""
        for composite in self._composites.values():
            try:
                await composite.cleanup()
            except Exception as e:
                self._logger.error(
                    "Failed to clean up composite",
                    extra={
                        "composite": composite.metadata.name,
                        "error": str(e)
                    }
                )
```

3. Implementar composites específicos:

```python
class MemoryComposite(CompositeComponent[Dict[str, Any]]):
    """Composite memory store implementation."""
    
    async def retrieve(
        self,
        query: MemoryQuery
    ) -> AsyncIterator[MemoryResult[Dict[str, Any]]]:
        """Retrieve entries from all stores."""
        seen_keys = set()
        
        for component in self._components.values():
            if not isinstance(component, BaseMemoryStore):
                continue
                
            try:
                async for result in component.retrieve(query):
                    if result.key not in seen_keys:
                        seen_keys.add(result.key)
                        yield result
                        
            except Exception as e:
                self._logger.error(
                    "Failed to retrieve from store",
                    extra={
                        "store": component.metadata.name,
                        "error": str(e)
                    }
                )

class ProcessorComposite(CompositeComponent[str]):
    """Composite processor implementation."""
    
    async def process(
        self,
        content: str
    ) -> str:
        """Process content through all processors."""
        result = content
        
        for component in self._components.values():
            if not isinstance(component, BaseProcessor):
                continue
                
            try:
                result = await component.process(result)
            except Exception as e:
                self._logger.error(
                    "Failed to process content",
                    extra={
                        "processor": component.metadata.name,
                        "error": str(e)
                    }
                )
                raise
                
        return result
```

4. Implementar sistema de monitoramento:

```python
class CompositionMonitor:
    """Monitor for component composition."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        composite: str,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record composition operation."""
        self._metrics.counter(
            "composition_operations",
            1,
            composite=composite,
            operation=operation,
            success=str(success).lower(),
            **labels
        )
        
    async def record_components(
        self,
        composite: str,
        count: int,
        **labels: str
    ) -> None:
        """Record component count."""
        self._metrics.gauge(
            "composition_components",
            count,
            composite=composite,
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `memory/stores/composite.py`
   - Atualizar `core/layers.py`
   - Criar novos composites conforme necessário

## Validação

```python
async def test_composition_system():
    # Setup
    manager = CompositionManager()
    monitor = CompositionMonitor()
    
    # Create composite
    memory = await manager.create_composite(
        "memory",
        MemoryComposite
    )
    
    # Add components
    local_store = LocalMemoryStore()
    redis_store = RedisMemoryStore()
    
    await manager.add_component("memory", "local", local_store)
    await manager.add_component("memory", "redis", redis_store)
    
    # Test initialization
    await manager.initialize_all()
    
    # Test retrieval
    query = MemoryQuery(pattern="test*")
    results = []
    
    async for result in memory.retrieve(query):
        results.append(result)
        
    assert len(results) > 0
    
    # Test cleanup
    await manager.cleanup_all()
    
    # Test monitoring
    await monitor.record_operation("memory", "add_component", True)
    await monitor.record_components("memory", 2)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_composition_system():
    # Restore legacy implementations
    shutil.copy("memory/stores/composite_legacy.py", "memory/stores/composite.py")
    shutil.copy("core/layers_legacy.py", "core/layers.py")
    
    # Cleanup new implementations
    os.remove("core/composition/base.py")
    os.remove("core/composition/manager.py")
    os.remove("core/composition/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de composição
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para operações de composição
   - Latência < 100ms para inicialização
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de composição
- [ ] Implementação do gerenciamento unificado
- [ ] Implementação dos composites específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
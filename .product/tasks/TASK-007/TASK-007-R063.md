# R063: Consolidação do Sistema de Eventos

## Descrição

Unificar e padronizar o sistema de eventos em todo o framework, estabelecendo uma interface consistente para publicação, assinatura e manipulação de eventos. O sistema atual possui diferentes implementações de manipulação de eventos espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, o sistema de eventos está distribuído em vários módulos:

1. Em `events/dispatcher.py`:
```python
class EventDispatcher:
    """Dispatch events to subscribers."""
    
    def __init__(self):
        self._subscribers = {}
        
    def subscribe(
        self,
        event_type: str,
        handler: Callable[[Event], Awaitable[None]]
    ) -> None:
        """Subscribe to an event."""
        if event_type not in self._subscribers:
            self._subscribers[event_type] = []
        self._subscribers[event_type].append(handler)
        
    def unsubscribe(
        self,
        event_type: str,
        handler: Callable[[Event], Awaitable[None]]
    ) -> None:
        """Unsubscribe from an event."""
        if event_type in self._subscribers:
            self._subscribers[event_type].remove(handler)
            
    async def dispatch(
        self,
        event: Event
    ) -> None:
        """Dispatch an event."""
        if event.type in self._subscribers:
            for handler in self._subscribers[event.type]:
                await handler(event)
```

2. Em `core/events.py`:
```python
class EventBus:
    """Event bus for system events."""
    
    def __init__(self):
        self._handlers = {}
        
    def register_handler(
        self,
        event_type: str,
        handler: EventHandler
    ) -> None:
        """Register an event handler."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
        
    async def emit(
        self,
        event: Event
    ) -> None:
        """Emit an event."""
        if event.type in self._handlers:
            for handler in self._handlers[event.type]:
                await handler.handle(event)
```

## Plano de Implementação

1. Criar sistema base de eventos:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar
from dataclasses import dataclass
from datetime import datetime
from uuid import UUID, uuid4

T = TypeVar("T")

@dataclass
class EventMetadata:
    """Metadata for events."""
    id: UUID
    timestamp: datetime
    source: str
    correlation_id: Optional[UUID]
    causation_id: Optional[UUID]
    tags: Dict[str, str]

@dataclass
class Event(Generic[T]):
    """Base class for events."""
    type: str
    data: T
    metadata: EventMetadata

class EventHandler(ABC, Generic[T]):
    """Base class for event handlers."""
    
    @abstractmethod
    async def handle(
        self,
        event: Event[T]
    ) -> None:
        """Handle an event."""
        pass
    
    @abstractmethod
    async def validate(
        self,
        event: Event[T]
    ) -> List[str]:
        """Validate event."""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up handler resources."""
        pass
```

2. Implementar sistema de eventos unificado:

```python
class UnifiedEventSystem:
    """Unified event system."""
    
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_handler(
        self,
        event_type: str,
        handler: EventHandler
    ) -> None:
        """Register an event handler."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
        
    def unregister_handler(
        self,
        event_type: str,
        handler: EventHandler
    ) -> None:
        """Unregister an event handler."""
        if event_type in self._handlers:
            self._handlers[event_type].remove(handler)
            
    async def emit(
        self,
        event_type: str,
        data: Any,
        correlation_id: Optional[UUID] = None,
        causation_id: Optional[UUID] = None,
        tags: Optional[Dict[str, str]] = None
    ) -> None:
        """Emit an event."""
        metadata = EventMetadata(
            id=uuid4(),
            timestamp=datetime.now(),
            source=self.__class__.__name__,
            correlation_id=correlation_id,
            causation_id=causation_id,
            tags=tags or {}
        )
        
        event = Event(
            type=event_type,
            data=data,
            metadata=metadata
        )
        
        try:
            await self._emit_event(event)
            
            self._metrics.counter(
                "event_emissions",
                1,
                event_type=event_type,
                success="true"
            )
            
        except Exception as e:
            self._metrics.counter(
                "event_emissions",
                1,
                event_type=event_type,
                success="false"
            )
            
            self._logger.error(
                "Event emission failed",
                extra={
                    "event_type": event_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def _emit_event(
        self,
        event: Event
    ) -> None:
        """Emit event to handlers."""
        if event.type in self._handlers:
            for handler in self._handlers[event.type]:
                try:
                    # Validate event
                    errors = await handler.validate(event)
                    if errors:
                        self._logger.warning(
                            "Event validation failed",
                            extra={
                                "event_type": event.type,
                                "errors": errors
                            }
                        )
                        continue
                        
                    # Handle event
                    await handler.handle(event)
                    
                except Exception as e:
                    self._logger.error(
                        "Event handling failed",
                        extra={
                            "event_type": event.type,
                            "handler": handler.__class__.__name__,
                            "error": str(e)
                        }
                    )
                    
    async def cleanup(self) -> None:
        """Clean up all handlers."""
        for handlers in self._handlers.values():
            for handler in handlers:
                try:
                    await handler.cleanup()
                except Exception as e:
                    self._logger.error(
                        "Handler cleanup failed",
                        extra={"error": str(e)}
                    )
```

3. Implementar handlers específicos:

```python
class LoggingEventHandler(EventHandler[Dict[str, Any]]):
    """Handler for logging events."""
    
    def __init__(self):
        self._logger = logging.getLogger(__name__)
        self._metrics = MetricsManager.get_instance()
        
    async def handle(
        self,
        event: Event[Dict[str, Any]]
    ) -> None:
        """Handle logging event."""
        self._logger.info(
            "Event received",
            extra={
                "event_type": event.type,
                "event_data": event.data,
                "event_metadata": asdict(event.metadata)
            }
        )
        
    async def validate(
        self,
        event: Event[Dict[str, Any]]
    ) -> List[str]:
        """Validate logging event."""
        errors = []
        
        if not isinstance(event.data, dict):
            errors.append("Event data must be a dictionary")
            
        return errors
        
    async def cleanup(self) -> None:
        """Clean up handler resources."""
        pass

class MetricsEventHandler(EventHandler[Dict[str, Any]]):
    """Handler for metrics events."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def handle(
        self,
        event: Event[Dict[str, Any]]
    ) -> None:
        """Handle metrics event."""
        metric_name = event.data.get("name")
        metric_value = event.data.get("value")
        metric_type = event.data.get("type", "counter")
        labels = event.data.get("labels", {})
        
        if metric_type == "counter":
            self._metrics.counter(metric_name, metric_value, **labels)
        elif metric_type == "gauge":
            self._metrics.gauge(metric_name, metric_value, **labels)
        elif metric_type == "histogram":
            self._metrics.histogram(metric_name, metric_value, **labels)
            
    async def validate(
        self,
        event: Event[Dict[str, Any]]
    ) -> List[str]:
        """Validate metrics event."""
        errors = []
        
        data = event.data
        if not isinstance(data, dict):
            errors.append("Event data must be a dictionary")
            return errors
            
        if "name" not in data:
            errors.append("Missing metric name")
            
        if "value" not in data:
            errors.append("Missing metric value")
            
        if data.get("type") not in ["counter", "gauge", "histogram"]:
            errors.append("Invalid metric type")
            
        return errors
        
    async def cleanup(self) -> None:
        """Clean up handler resources."""
        pass
```

4. Implementar sistema de monitoramento:

```python
class EventMonitor:
    """Monitor for event system."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_emission(
        self,
        event_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record event emission."""
        self._metrics.counter(
            "event_operations",
            1,
            operation="emit",
            event_type=event_type,
            success=str(success).lower(),
            **labels
        )
        
    async def record_handling(
        self,
        event_type: str,
        handler: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record event handling."""
        self._metrics.counter(
            "event_operations",
            1,
            operation="handle",
            event_type=event_type,
            handler=handler,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `events/dispatcher.py`
   - Atualizar `core/events.py`
   - Criar novos handlers conforme necessário

## Validação

```python
async def test_event_system():
    # Setup
    event_system = UnifiedEventSystem()
    monitor = EventMonitor()
    
    # Register handlers
    logging_handler = LoggingEventHandler()
    metrics_handler = MetricsEventHandler()
    
    event_system.register_handler("logging", logging_handler)
    event_system.register_handler("metrics", metrics_handler)
    
    # Test logging event
    await event_system.emit(
        "logging",
        {
            "message": "Test event",
            "level": "info"
        },
        tags={"source": "test"}
    )
    
    # Test metrics event
    await event_system.emit(
        "metrics",
        {
            "name": "test_metric",
            "value": 1.0,
            "type": "counter",
            "labels": {"test": "true"}
        }
    )
    
    # Test monitoring
    await monitor.record_emission("logging", True)
    await monitor.record_handling("metrics", "MetricsEventHandler", True)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_event_system():
    # Restore legacy implementations
    shutil.copy("events/dispatcher_legacy.py", "events/dispatcher.py")
    shutil.copy("core/events_legacy.py", "core/events.py")
    
    # Cleanup new implementations
    os.remove("core/events/unified.py")
    os.remove("core/events/handlers.py")
    os.remove("core/events/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de eventos
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero eventos perdidos
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para emissão
   - Latência < 100ms para processamento
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de eventos
- [ ] Implementação do sistema unificado
- [ ] Implementação dos handlers específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
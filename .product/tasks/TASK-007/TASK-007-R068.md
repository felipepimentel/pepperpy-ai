# R068: Consolidação do Sistema de Processamento Assíncrono

## Descrição

Unificar e padronizar o sistema de processamento assíncrono em todo o framework, estabelecendo uma interface consistente para gerenciamento de tarefas, tratamento de erros e monitoramento de progresso. O sistema atual possui diferentes abordagens para processamento assíncrono espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Consolidação do Sistema de Gerenciamento de Erros

## Estado Atual

Atualmente, o processamento assíncrono está distribuído em vários módulos:

1. Em `core/async/worker.py`:
```python
class AsyncWorker:
    """Async worker implementation."""
    
    def __init__(self):
        self._queue: asyncio.Queue = asyncio.Queue()
        self._running = False
        self._tasks: List[asyncio.Task] = []
        
    async def start(self):
        """Start worker."""
        self._running = True
        self._tasks = [
            asyncio.create_task(self._process())
            for _ in range(self._num_workers)
        ]
        
    async def stop(self):
        """Stop worker."""
        self._running = False
        await self._queue.join()
        for task in self._tasks:
            task.cancel()
            
    async def _process(self):
        """Process tasks from queue."""
        while self._running:
            try:
                task = await self._queue.get()
                await task()
            except Exception as e:
                logger.error(f"Task failed: {e}")
            finally:
                self._queue.task_done()
```

2. Em `agents/executor.py`:
```python
class AgentExecutor:
    """Agent execution manager."""
    
    def __init__(self):
        self._tasks: Dict[str, asyncio.Task] = {}
        self._results: Dict[str, Any] = {}
        self._errors: Dict[str, Exception] = {}
        
    async def execute(
        self,
        agent_id: str,
        task: Callable[..., Awaitable[Any]]
    ) -> str:
        """Execute agent task."""
        task_id = str(uuid.uuid4())
        
        async def wrapped_task():
            try:
                result = await task()
                self._results[task_id] = result
            except Exception as e:
                self._errors[task_id] = e
                raise
                
        self._tasks[task_id] = asyncio.create_task(wrapped_task())
        return task_id
        
    async def get_result(
        self,
        task_id: str,
        timeout: Optional[float] = None
    ) -> Any:
        """Get task result."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")
            
        try:
            await asyncio.wait_for(
                self._tasks[task_id],
                timeout=timeout
            )
        except asyncio.TimeoutError:
            raise TimeoutError(f"Task timed out: {task_id}")
            
        if task_id in self._errors:
            raise self._errors[task_id]
            
        return self._results[task_id]
```

## Plano de Implementação

1. Criar sistema base de processamento assíncrono:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

T = TypeVar("T")

class TaskStatus(Enum):
    """Task status enum."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

@dataclass
class TaskMetadata:
    """Task metadata."""
    id: str
    name: str
    created_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    status: TaskStatus
    progress: float
    total_steps: int
    current_step: int
    labels: Dict[str, str]

class Task(Generic[T]):
    """Base class for async tasks."""
    
    def __init__(
        self,
        name: str,
        total_steps: int = 1,
        **labels: str
    ) -> None:
        """Initialize task."""
        self.id = str(uuid.uuid4())
        self._metadata = TaskMetadata(
            id=self.id,
            name=name,
            created_at=datetime.now(),
            started_at=None,
            completed_at=None,
            status=TaskStatus.PENDING,
            progress=0.0,
            total_steps=total_steps,
            current_step=0,
            labels=labels
        )
        self._result: Optional[T] = None
        self._error: Optional[Exception] = None
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    @property
    def metadata(self) -> TaskMetadata:
        """Get task metadata."""
        return self._metadata
        
    @property
    def result(self) -> Optional[T]:
        """Get task result."""
        return self._result
        
    @property
    def error(self) -> Optional[Exception]:
        """Get task error."""
        return self._error
        
    async def run(self) -> T:
        """Run task."""
        self._metadata.started_at = datetime.now()
        self._metadata.status = TaskStatus.RUNNING
        
        try:
            self._result = await self._execute()
            self._metadata.status = TaskStatus.COMPLETED
            return self._result
            
        except Exception as e:
            self._error = e
            self._metadata.status = TaskStatus.FAILED
            raise
            
        finally:
            self._metadata.completed_at = datetime.now()
            
    async def cancel(self) -> None:
        """Cancel task."""
        self._metadata.status = TaskStatus.CANCELLED
        self._metadata.completed_at = datetime.now()
        
    def update_progress(
        self,
        step: int,
        progress: Optional[float] = None
    ) -> None:
        """Update task progress."""
        self._metadata.current_step = step
        if progress is not None:
            self._metadata.progress = progress
        else:
            self._metadata.progress = (
                step / self._metadata.total_steps
            )
            
    @abstractmethod
    async def _execute(self) -> T:
        """Execute task implementation."""
        pass
```

2. Implementar sistema de gerenciamento de tarefas:

```python
class TaskManager:
    """Manager for async tasks."""
    
    def __init__(
        self,
        max_concurrent: int = 10
    ) -> None:
        """Initialize manager."""
        self._tasks: Dict[str, Task] = {}
        self._queue: asyncio.Queue[Task] = asyncio.Queue()
        self._workers: List[asyncio.Task] = []
        self._max_concurrent = max_concurrent
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def start(self) -> None:
        """Start task manager."""
        self._workers = [
            asyncio.create_task(self._process_tasks())
            for _ in range(self._max_concurrent)
        ]
        
    async def stop(self) -> None:
        """Stop task manager."""
        await self._queue.join()
        for worker in self._workers:
            worker.cancel()
            
    async def submit(
        self,
        task: Task[T]
    ) -> str:
        """Submit task for execution."""
        self._tasks[task.id] = task
        await self._queue.put(task)
        
        self._metrics.counter(
            "task_operations",
            1,
            operation="submit",
            status=task.metadata.status.value
        )
        
        return task.id
        
    async def get_task(
        self,
        task_id: str
    ) -> Task:
        """Get task by ID."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")
            
        return self._tasks[task_id]
        
    async def cancel_task(
        self,
        task_id: str
    ) -> None:
        """Cancel task by ID."""
        task = await self.get_task(task_id)
        await task.cancel()
        
        self._metrics.counter(
            "task_operations",
            1,
            operation="cancel",
            status=task.metadata.status.value
        )
        
    async def get_result(
        self,
        task_id: str,
        timeout: Optional[float] = None
    ) -> Any:
        """Get task result."""
        task = await self.get_task(task_id)
        
        if task.metadata.status == TaskStatus.COMPLETED:
            return task.result
            
        if task.metadata.status == TaskStatus.FAILED:
            raise task.error
            
        if task.metadata.status == TaskStatus.CANCELLED:
            raise CancelledError(f"Task cancelled: {task_id}")
            
        if timeout is not None:
            await asyncio.sleep(timeout)
            if task.metadata.status == TaskStatus.RUNNING:
                raise TimeoutError(f"Task timed out: {task_id}")
                
        return None
        
    async def _process_tasks(self) -> None:
        """Process tasks from queue."""
        while True:
            try:
                task = await self._queue.get()
                
                try:
                    await task.run()
                except Exception as e:
                    self._logger.error(
                        "Task failed",
                        extra={
                            "task_id": task.id,
                            "error": str(e)
                        }
                    )
                finally:
                    self._queue.task_done()
                    
            except asyncio.CancelledError:
                break
```

3. Implementar tarefas específicas:

```python
class AgentTask(Task[Dict[str, Any]]):
    """Task for agent execution."""
    
    def __init__(
        self,
        agent_id: str,
        action: Callable[..., Awaitable[Any]],
        **kwargs: Any
    ) -> None:
        """Initialize task."""
        super().__init__(
            name=f"agent_{agent_id}",
            labels={"agent_id": agent_id}
        )
        self._action = action
        self._kwargs = kwargs
        
    async def _execute(self) -> Dict[str, Any]:
        """Execute agent action."""
        return await self._action(**self._kwargs)

class ProcessorTask(Task[str]):
    """Task for content processing."""
    
    def __init__(
        self,
        content: str,
        processors: List[BaseProcessor]
    ) -> None:
        """Initialize task."""
        super().__init__(
            name="content_processing",
            total_steps=len(processors)
        )
        self._content = content
        self._processors = processors
        
    async def _execute(self) -> str:
        """Process content through processors."""
        result = self._content
        
        for i, processor in enumerate(self._processors):
            try:
                result = await processor.process(result)
                self.update_progress(i + 1)
            except Exception as e:
                self._logger.error(
                    "Processor failed",
                    extra={
                        "processor": processor.__class__.__name__,
                        "error": str(e)
                    }
                )
                raise
                
        return result
```

4. Implementar sistema de monitoramento:

```python
class TaskMonitor:
    """Monitor for async tasks."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_task_status(
        self,
        task: Task,
        **labels: str
    ) -> None:
        """Record task status."""
        self._metrics.counter(
            "task_status",
            1,
            task_id=task.id,
            name=task.metadata.name,
            status=task.metadata.status.value,
            **labels
        )
        
    async def record_task_duration(
        self,
        task: Task,
        **labels: str
    ) -> None:
        """Record task duration."""
        if (
            task.metadata.started_at is not None
            and task.metadata.completed_at is not None
        ):
            duration = (
                task.metadata.completed_at -
                task.metadata.started_at
            ).total_seconds()
            
            self._metrics.histogram(
                "task_duration",
                duration,
                task_id=task.id,
                name=task.metadata.name,
                status=task.metadata.status.value,
                **labels
            )
            
    async def record_task_progress(
        self,
        task: Task,
        **labels: str
    ) -> None:
        """Record task progress."""
        self._metrics.gauge(
            "task_progress",
            task.metadata.progress,
            task_id=task.id,
            name=task.metadata.name,
            status=task.metadata.status.value,
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/async/worker.py`
   - Atualizar `agents/executor.py`
   - Criar novas tarefas conforme necessário

## Validação

```python
async def test_task_system():
    # Setup
    manager = TaskManager(max_concurrent=2)
    monitor = TaskMonitor()
    
    await manager.start()
    
    # Create tasks
    processor_task = ProcessorTask(
        content="test content",
        processors=[
            TextProcessor(),
            MarkdownProcessor()
        ]
    )
    
    agent_task = AgentTask(
        agent_id="test_agent",
        action=lambda: {"status": "success"}
    )
    
    # Submit tasks
    processor_id = await manager.submit(processor_task)
    agent_id = await manager.submit(agent_task)
    
    # Monitor progress
    await monitor.record_task_status(processor_task)
    await monitor.record_task_progress(processor_task)
    
    # Get results
    processor_result = await manager.get_result(processor_id)
    agent_result = await manager.get_result(agent_id)
    
    assert isinstance(processor_result, str)
    assert isinstance(agent_result, dict)
    
    # Record metrics
    await monitor.record_task_duration(processor_task)
    await monitor.record_task_duration(agent_task)
    
    # Cleanup
    await manager.stop()
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_task_system():
    # Restore legacy implementations
    shutil.copy("core/async/worker_legacy.py", "core/async/worker.py")
    shutil.copy("agents/executor_legacy.py", "agents/executor.py")
    
    # Cleanup new implementations
    os.remove("core/async/task.py")
    os.remove("core/async/manager.py")
    os.remove("core/async/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código assíncrono
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 100ms para submissão de tarefas
   - Throughput > 1000 tarefas/segundo
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de tarefas
- [ ] Implementação do gerenciamento de tarefas
- [ ] Implementação das tarefas específicas
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R081: Consolidação do Sistema de Métricas

## Descrição

Unificar e padronizar o sistema de métricas em todo o framework, estabelecendo uma interface consistente para coleta e agregação de métricas de performance e negócio. O sistema atual possui diferentes implementações de métricas espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R072: Padronização do Sistema de Auditoria
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, as métricas estão distribuídas em vários módulos:

1. Em `core/metrics.py`:
```python
class MetricsCollector:
    """Simple metrics collector."""
    
    def __init__(self):
        self._metrics = {}
        
    def record(
        self,
        name: str,
        value: float,
        **labels: str
    ) -> None:
        """Record metric value."""
        key = f"{name}:{','.join(f'{k}={v}' for k, v in labels.items())}"
        self._metrics[key] = value
```

2. Em `agents/metrics.py`:
```python
class AgentMetrics:
    """Metrics for agent operations."""
    
    def __init__(self):
        self._counters = {}
        self._histograms = {}
        
    def increment(
        self,
        name: str,
        value: float = 1.0
    ) -> None:
        """Increment counter."""
        self._counters[name] = self._counters.get(name, 0) + value
        
    def observe(
        self,
        name: str,
        value: float
    ) -> None:
        """Observe histogram value."""
        if name not in self._histograms:
            self._histograms[name] = []
        self._histograms[name].append(value)
```

## Plano de Implementação

1. Criar sistema base de métricas:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import statistics
import time

T = TypeVar("T")

class MetricType(Enum):
    """Metric types."""
    
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    SUMMARY = "summary"

@dataclass
class MetricMetadata:
    """Metadata for metrics."""
    
    name: str
    type: MetricType
    description: str
    unit: str
    labels: Dict[str, str] = field(default_factory=dict)

class Metric(ABC):
    """Base class for metrics."""
    
    def __init__(
        self,
        metadata: MetricMetadata
    ):
        self._metadata = metadata
        self._created_at = datetime.now()
        
    @property
    def metadata(self) -> MetricMetadata:
        """Get metric metadata."""
        return self._metadata
        
    @abstractmethod
    def update(self, value: float) -> None:
        """Update metric value."""
        pass
        
    @abstractmethod
    def reset(self) -> None:
        """Reset metric value."""
        pass
        
    @abstractmethod
    def get_value(self) -> Any:
        """Get metric value."""
        pass

class Counter(Metric):
    """Counter metric."""
    
    def __init__(
        self,
        metadata: MetricMetadata
    ):
        super().__init__(metadata)
        self._value = 0.0
        
    def update(self, value: float) -> None:
        """Update counter value."""
        if value < 0:
            raise ValueError("Counter value must be non-negative")
        self._value += value
        
    def reset(self) -> None:
        """Reset counter value."""
        self._value = 0.0
        
    def get_value(self) -> float:
        """Get counter value."""
        return self._value

class Gauge(Metric):
    """Gauge metric."""
    
    def __init__(
        self,
        metadata: MetricMetadata
    ):
        super().__init__(metadata)
        self._value = 0.0
        
    def update(self, value: float) -> None:
        """Update gauge value."""
        self._value = value
        
    def reset(self) -> None:
        """Reset gauge value."""
        self._value = 0.0
        
    def get_value(self) -> float:
        """Get gauge value."""
        return self._value

class Histogram(Metric):
    """Histogram metric."""
    
    def __init__(
        self,
        metadata: MetricMetadata,
        buckets: Optional[List[float]] = None
    ):
        super().__init__(metadata)
        self._buckets = sorted(buckets or [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10])
        self._values: List[float] = []
        self._count = 0
        self._sum = 0.0
        
    def update(self, value: float) -> None:
        """Update histogram value."""
        self._values.append(value)
        self._count += 1
        self._sum += value
        
    def reset(self) -> None:
        """Reset histogram value."""
        self._values.clear()
        self._count = 0
        self._sum = 0.0
        
    def get_value(self) -> Dict[str, float]:
        """Get histogram value."""
        if not self._values:
            return {
                "count": 0,
                "sum": 0.0,
                "avg": 0.0,
                "min": 0.0,
                "max": 0.0,
                "buckets": {str(b): 0 for b in self._buckets}
            }
            
        buckets = {str(b): 0 for b in self._buckets}
        for value in self._values:
            for bucket in self._buckets:
                if value <= bucket:
                    buckets[str(bucket)] += 1
                    
        return {
            "count": self._count,
            "sum": self._sum,
            "avg": self._sum / self._count,
            "min": min(self._values),
            "max": max(self._values),
            "buckets": buckets
        }

class Summary(Metric):
    """Summary metric."""
    
    def __init__(
        self,
        metadata: MetricMetadata,
        quantiles: Optional[List[float]] = None
    ):
        super().__init__(metadata)
        self._quantiles = sorted(quantiles or [0.5, 0.9, 0.95, 0.99])
        self._values: List[float] = []
        self._count = 0
        self._sum = 0.0
        
    def update(self, value: float) -> None:
        """Update summary value."""
        self._values.append(value)
        self._count += 1
        self._sum += value
        
    def reset(self) -> None:
        """Reset summary value."""
        self._values.clear()
        self._count = 0
        self._sum = 0.0
        
    def get_value(self) -> Dict[str, float]:
        """Get summary value."""
        if not self._values:
            return {
                "count": 0,
                "sum": 0.0,
                "avg": 0.0,
                "min": 0.0,
                "max": 0.0,
                "quantiles": {str(q): 0.0 for q in self._quantiles}
            }
            
        sorted_values = sorted(self._values)
        quantiles = {
            str(q): sorted_values[int(q * len(sorted_values))]
            for q in self._quantiles
        }
            
        return {
            "count": self._count,
            "sum": self._sum,
            "avg": self._sum / self._count,
            "min": min(self._values),
            "max": max(self._values),
            "quantiles": quantiles
        }
```

2. Implementar sistema de gerenciamento de métricas:

```python
class MetricsManager:
    """Manager for metrics."""
    
    def __init__(self):
        self._metrics: Dict[str, Dict[str, Metric]] = {}
        self._logger = logging.getLogger(__name__)
        
    def register_metric(
        self,
        metric: Metric
    ) -> None:
        """Register a metric."""
        name = metric.metadata.name
        labels = ",".join(
            f"{k}={v}"
            for k, v in metric.metadata.labels.items()
        )
        key = f"{name}:{labels}"
        
        if metric.metadata.type.value not in self._metrics:
            self._metrics[metric.metadata.type.value] = {}
            
        self._metrics[metric.metadata.type.value][key] = metric
        
    def counter(
        self,
        name: str,
        value: float = 1.0,
        description: str = "",
        unit: str = "",
        **labels: str
    ) -> None:
        """Record counter value."""
        try:
            metric = self._get_or_create_metric(
                name=name,
                type=MetricType.COUNTER,
                description=description,
                unit=unit,
                labels=labels
            )
            metric.update(value)
            
        except Exception as e:
            self._logger.error(
                "Failed to record counter",
                extra={
                    "name": name,
                    "value": value,
                    "labels": labels,
                    "error": str(e)
                }
            )
            
    def gauge(
        self,
        name: str,
        value: float,
        description: str = "",
        unit: str = "",
        **labels: str
    ) -> None:
        """Record gauge value."""
        try:
            metric = self._get_or_create_metric(
                name=name,
                type=MetricType.GAUGE,
                description=description,
                unit=unit,
                labels=labels
            )
            metric.update(value)
            
        except Exception as e:
            self._logger.error(
                "Failed to record gauge",
                extra={
                    "name": name,
                    "value": value,
                    "labels": labels,
                    "error": str(e)
                }
            )
            
    def histogram(
        self,
        name: str,
        value: float,
        description: str = "",
        unit: str = "",
        buckets: Optional[List[float]] = None,
        **labels: str
    ) -> None:
        """Record histogram value."""
        try:
            metric = self._get_or_create_metric(
                name=name,
                type=MetricType.HISTOGRAM,
                description=description,
                unit=unit,
                labels=labels,
                buckets=buckets
            )
            metric.update(value)
            
        except Exception as e:
            self._logger.error(
                "Failed to record histogram",
                extra={
                    "name": name,
                    "value": value,
                    "labels": labels,
                    "error": str(e)
                }
            )
            
    def summary(
        self,
        name: str,
        value: float,
        description: str = "",
        unit: str = "",
        quantiles: Optional[List[float]] = None,
        **labels: str
    ) -> None:
        """Record summary value."""
        try:
            metric = self._get_or_create_metric(
                name=name,
                type=MetricType.SUMMARY,
                description=description,
                unit=unit,
                labels=labels,
                quantiles=quantiles
            )
            metric.update(value)
            
        except Exception as e:
            self._logger.error(
                "Failed to record summary",
                extra={
                    "name": name,
                    "value": value,
                    "labels": labels,
                    "error": str(e)
                }
            )
            
    def get_metrics(self) -> Dict[str, Dict[str, Any]]:
        """Get all metrics."""
        result = {}
        for type_name, metrics in self._metrics.items():
            result[type_name] = {
                key: metric.get_value()
                for key, metric in metrics.items()
            }
        return result
        
    def reset(self) -> None:
        """Reset all metrics."""
        for metrics in self._metrics.values():
            for metric in metrics.values():
                metric.reset()
                
    def _get_or_create_metric(
        self,
        name: str,
        type: MetricType,
        description: str,
        unit: str,
        labels: Dict[str, str],
        **kwargs: Any
    ) -> Metric:
        """Get or create metric."""
        labels_key = ",".join(
            f"{k}={v}"
            for k, v in labels.items()
        )
        key = f"{name}:{labels_key}"
        
        if type.value not in self._metrics:
            self._metrics[type.value] = {}
            
        if key not in self._metrics[type.value]:
            metadata = MetricMetadata(
                name=name,
                type=type,
                description=description,
                unit=unit,
                labels=labels
            )
            
            if type == MetricType.COUNTER:
                metric = Counter(metadata)
            elif type == MetricType.GAUGE:
                metric = Gauge(metadata)
            elif type == MetricType.HISTOGRAM:
                metric = Histogram(
                    metadata,
                    buckets=kwargs.get("buckets")
                )
            else:  # SUMMARY
                metric = Summary(
                    metadata,
                    quantiles=kwargs.get("quantiles")
                )
                
            self._metrics[type.value][key] = metric
            
        return self._metrics[type.value][key]
```

3. Implementar exportadores de métricas:

```python
class MetricsExporter(ABC):
    """Base class for metrics exporters."""
    
    @abstractmethod
    async def export(
        self,
        metrics: Dict[str, Dict[str, Any]]
    ) -> None:
        """Export metrics."""
        pass

class PrometheusExporter(MetricsExporter):
    """Prometheus metrics exporter."""
    
    def __init__(self, path: str = "/metrics"):
        self._path = path
        
    async def export(
        self,
        metrics: Dict[str, Dict[str, Any]]
    ) -> None:
        """Export metrics in Prometheus format."""
        lines = []
        
        for type_name, type_metrics in metrics.items():
            for key, value in type_metrics.items():
                name, labels = key.split(":", 1)
                
                if type_name == "counter":
                    lines.append(
                        f"{name}{{{labels}}} {value}"
                    )
                elif type_name == "gauge":
                    lines.append(
                        f"{name}{{{labels}}} {value}"
                    )
                elif type_name == "histogram":
                    for bucket, count in value["buckets"].items():
                        lines.append(
                            f"{name}_bucket{{{labels},le=\"{bucket}\"}} {count}"
                        )
                    lines.append(
                        f"{name}_count{{{labels}}} {value['count']}"
                    )
                    lines.append(
                        f"{name}_sum{{{labels}}} {value['sum']}"
                    )
                else:  # summary
                    for q, v in value["quantiles"].items():
                        lines.append(
                            f"{name}{{{labels},quantile=\"{q}\"}} {v}"
                        )
                    lines.append(
                        f"{name}_count{{{labels}}} {value['count']}"
                    )
                    lines.append(
                        f"{name}_sum{{{labels}}} {value['sum']}"
                    )
                    
        return "\n".join(lines)

class JsonExporter(MetricsExporter):
    """JSON metrics exporter."""
    
    async def export(
        self,
        metrics: Dict[str, Dict[str, Any]]
    ) -> None:
        """Export metrics in JSON format."""
        return json.dumps(metrics)
```

4. Implementar sistema de monitoramento:

```python
class MetricsMonitor:
    """Monitor for metrics operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        operation: str,
        metric_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record metrics operation."""
        self._metrics.counter(
            "metrics_operations",
            1,
            operation=operation,
            type=metric_type,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "metrics_duration",
                duration,
                operation=operation,
                type=metric_type,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter métricas para nova interface
   - Atualizar coleta de métricas
   - Implementar exportação automática

## Validação

```python
async def test_metrics_system():
    # Setup
    manager = MetricsManager()
    monitor = MetricsMonitor()
    
    # Test counter
    manager.counter(
        "requests_total",
        1,
        description="Total requests",
        unit="requests",
        endpoint="/api/v1/users"
    )
    
    # Test gauge
    manager.gauge(
        "memory_usage",
        1024,
        description="Memory usage",
        unit="bytes",
        type="heap"
    )
    
    # Test histogram
    manager.histogram(
        "request_duration",
        0.1,
        description="Request duration",
        unit="seconds",
        buckets=[0.1, 0.5, 1.0],
        endpoint="/api/v1/users"
    )
    
    # Test summary
    manager.summary(
        "response_size",
        256,
        description="Response size",
        unit="bytes",
        quantiles=[0.5, 0.9, 0.99],
        endpoint="/api/v1/users"
    )
    
    # Test export
    prometheus = PrometheusExporter()
    json_exporter = JsonExporter()
    
    metrics = manager.get_metrics()
    prometheus_output = await prometheus.export(metrics)
    json_output = await json_exporter.export(metrics)
    
    assert "requests_total" in prometheus_output
    assert "memory_usage" in prometheus_output
    assert "request_duration" in prometheus_output
    assert "response_size" in prometheus_output
    
    # Test monitoring
    await monitor.record_operation(
        "export",
        "prometheus",
        True,
        0.001
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_metrics_system():
    # Restore legacy implementations
    shutil.copy("core/metrics_legacy.py", "core/metrics.py")
    shutil.copy("agents/metrics_legacy.py", "agents/metrics.py")
    
    # Cleanup new implementations
    os.remove("core/metrics/base.py")
    os.remove("core/metrics/manager.py")
    os.remove("core/metrics/exporters.py")
    os.remove("core/metrics/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de métricas
   - Interface consistente
   - Exportação unificada

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero perda de métricas
   - Documentação completa

3. **Performance**:
   - Latência < 0.1ms por operação
   - Uso eficiente de memória
   - Exportação eficiente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de métricas
- [ ] Implementação do gerenciamento de métricas
- [ ] Implementação dos exportadores
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
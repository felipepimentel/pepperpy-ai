---
title: Consolida√ß√£o do Sistema de Providers Core
task: TASK-007
code: R044
status: üìã To Do
created: 2024-02-22
updated: 2024-02-22
started: null
completed: null
---

# Requirement
Unificar as implementa√ß√µes duplicadas do sistema de providers entre core/providers/base.py e providers/base.py, estabelecendo uma √∫nica implementa√ß√£o consistente e eficiente.

# Dependencies
- R002 (Consolida√ß√£o de Providers e Services)

## Current State
```python
# Duplica√ß√£o entre core/providers/base.py e providers/base.py:

# Em core/providers/base.py
class ProviderNotFoundError(ProviderError):
    """Error raised when provider is not found."""
    pass

# Em providers/base.py
class ProviderRegistry:
    """Provider registration and management."""
    def __init__(self) -> None:
        self._providers: Dict[str, Type[BaseProvider[Any]]] = {}
        self._instances: Dict[str, BaseProvider[Any]] = {}
        self._lock = asyncio.Lock()

# Duplica√ß√£o de l√≥gica de registro e gerenciamento em v√°rios locais
```

## Implementation
```python
# 1. Criar novo m√≥dulo unificado em core/providers/unified.py
from typing import Any, Dict, Generic, Optional, Type, TypeVar
from abc import ABC, abstractmethod
import asyncio

T = TypeVar("T")

class ProviderError(Exception):
    """Base error for provider-related issues."""
    def __init__(
        self,
        message: str,
        provider_type: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.message = message
        self.provider_type = provider_type
        self.details = details or {}
        super().__init__(message)

class ProviderNotFoundError(ProviderError):
    """Error raised when provider is not found."""
    pass

class BaseProvider(Generic[T], ABC):
    """Base class for all providers."""
    
    def __init__(self) -> None:
        self._initialized = False
        self._metrics: Optional[MetricsCollector] = None
    
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize provider."""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up provider resources."""
        pass
    
    @property
    def initialized(self) -> bool:
        """Check if provider is initialized."""
        return self._initialized
    
    def set_metrics(self, metrics: MetricsCollector) -> None:
        """Set metrics collector."""
        self._metrics = metrics

class UnifiedProviderRegistry:
    """Unified provider registration and management."""
    
    def __init__(self) -> None:
        self._providers: Dict[str, Dict[str, Type[BaseProvider[Any]]]] = {}
        self._instances: Dict[str, Dict[str, BaseProvider[Any]]] = {}
        self._lock = asyncio.Lock()
        self._metrics = MetricsCollector()
    
    async def register_provider(
        self,
        capability: str,
        provider_type: str,
        provider_class: Type[BaseProvider[T]],
    ) -> None:
        """Register a provider type.

        Args:
            capability: Capability identifier
            provider_type: Provider type identifier
            provider_class: Provider class to register

        Raises:
            ProviderError: If provider is already registered
        """
        async with self._lock:
            if capability not in self._providers:
                self._providers[capability] = {}
                self._instances[capability] = {}
            
            if provider_type in self._providers[capability]:
                raise ProviderError(
                    f"Provider already registered: {capability}.{provider_type}",
                    provider_type=provider_type,
                )
            
            self._providers[capability][provider_type] = provider_class
            self._metrics.track_provider_registered(capability, provider_type)
    
    async def get_provider(
        self,
        capability: str,
        provider_type: str,
        **kwargs: Any,
    ) -> BaseProvider[T]:
        """Get or create provider instance.

        Args:
            capability: Capability identifier
            provider_type: Provider type identifier
            **kwargs: Provider initialization arguments

        Returns:
            Provider instance

        Raises:
            ProviderNotFoundError: If provider is not found
            ProviderError: If provider initialization fails
        """
        async with self._lock:
            # Check if provider exists
            if (
                capability not in self._providers
                or provider_type not in self._providers[capability]
            ):
                raise ProviderNotFoundError(
                    f"Provider not found: {capability}.{provider_type}",
                    provider_type=provider_type,
                )
            
            # Get or create instance
            if (
                capability in self._instances
                and provider_type in self._instances[capability]
            ):
                return self._instances[capability][provider_type]
            
            try:
                # Create new instance
                provider_class = self._providers[capability][provider_type]
                provider = provider_class(**kwargs)
                
                # Initialize provider
                await provider.initialize()
                provider.set_metrics(self._metrics)
                
                # Store instance
                if capability not in self._instances:
                    self._instances[capability] = {}
                self._instances[capability][provider_type] = provider
                
                self._metrics.track_provider_initialized(capability, provider_type)
                return provider
                
            except Exception as e:
                self._metrics.track_provider_error(capability, provider_type)
                raise ProviderError(
                    f"Failed to initialize provider: {e}",
                    provider_type=provider_type,
                    details={"error": str(e)},
                ) from e
    
    async def cleanup(self) -> None:
        """Clean up all provider instances."""
        async with self._lock:
            for capability, providers in self._instances.items():
                for provider_type, provider in providers.items():
                    try:
                        await provider.cleanup()
                        self._metrics.track_provider_cleanup(
                            capability,
                            provider_type,
                        )
                    except Exception as e:
                        self._metrics.track_provider_error(
                            capability,
                            provider_type,
                        )
                        # Log error but continue cleanup
                        logger.error(
                            "Failed to cleanup provider",
                            extra={
                                "capability": capability,
                                "provider_type": provider_type,
                                "error": str(e),
                            },
                        )
            
            self._instances.clear()

# 2. Remover arquivos antigos ap√≥s migra√ß√£o:
# - core/providers/base.py
# - providers/base.py

# 3. Atualizar todos os imports para usar o novo sistema:
from pepperpy.core.providers.unified import (
    BaseProvider,
    UnifiedProviderRegistry,
    ProviderError,
)
```

## Validation
```python
def test_unified_provider_system():
    """Test unified provider system."""
    # Test provider registration
    registry = UnifiedProviderRegistry()
    await registry.register_provider(
        "test",
        "dummy",
        DummyProvider,
    )
    
    # Test provider instantiation
    provider = await registry.get_provider("test", "dummy")
    assert isinstance(provider, DummyProvider)
    assert provider.initialized
    
    # Test duplicate registration
    with pytest.raises(ProviderError):
        await registry.register_provider(
            "test",
            "dummy",
            DummyProvider,
        )
    
    # Test cleanup
    await registry.cleanup()
    assert not provider.initialized
```

## Rollback Plan
1. Manter backup dos arquivos originais
2. Script de revers√£o para restaurar arquivos originais:
   ```bash
   cp core/providers/base.py.bak core/providers/base.py
   cp providers/base.py.bak providers/base.py
   rm core/providers/unified.py
   ```
3. Reverter todos os imports para usar as implementa√ß√µes antigas

## Success Metrics
- [ ] Zero duplica√ß√£o de c√≥digo de providers
- [ ] Todos os providers usando o novo sistema unificado
- [ ] Melhor gerenciamento de ciclo de vida
- [ ] M√©tricas completas de providers
- [ ] Performance igual ou melhor que implementa√ß√£o anterior
- [ ] Documenta√ß√£o completa do novo sistema

# Progress Updates

## 2024-02-22
- Status: üìã To Do
- Progress: Requirement criado e documentado 
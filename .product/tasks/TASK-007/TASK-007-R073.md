# R073: Padronização do Sistema de Configuração

## Descrição

Unificar e padronizar o sistema de configuração em todo o framework, criando uma abordagem consistente para gerenciamento de configurações, variáveis de ambiente e perfis de execução. O sistema atual possui diferentes abordagens para configuração espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces
- R071: Unificação do Sistema de Validação de Schemas

## Estado Atual

Atualmente, a configuração está distribuída em vários módulos:

1. Em `core/config.py`:
```python
def load_config(path: str) -> Dict[str, Any]:
    """Load configuration from file."""
    with open(path) as f:
        return yaml.safe_load(f)
```

2. Em `agents/config.py`:
```python
class AgentConfig:
    """Agent configuration."""
    
    def __init__(self, **kwargs):
        self.model = kwargs.get("model")
        self.temperature = kwargs.get("temperature", 0.7)
        self.max_tokens = kwargs.get("max_tokens", 1000)
```

## Plano de Implementação

1. Criar sistema base de configuração:

```python
from typing import Any, Dict, Optional, Type, TypeVar, Union
from pydantic import BaseModel, Field, validator
from pathlib import Path
import os
import yaml

T = TypeVar("T", bound="BaseConfig")

class BaseConfig(BaseModel):
    """Base configuration class."""
    
    env: str = Field(default="development")
    debug: bool = Field(default=False)
    
    @classmethod
    def from_env(cls: Type[T]) -> T:
        """Load from environment variables."""
        env_data = {}
        for field in cls.__fields__:
            env_key = f"PEPPERPY_{field.upper()}"
            if env_key in os.environ:
                env_data[field] = os.environ[env_key]
        return cls(**env_data)
        
    @classmethod
    def from_file(cls: Type[T], path: Union[str, Path]) -> T:
        """Load from configuration file."""
        with open(path) as f:
            data = yaml.safe_load(f)
        return cls(**data)
        
    def merge(self, other: "BaseConfig") -> "BaseConfig":
        """Merge with another configuration."""
        data = self.dict()
        data.update(other.dict(exclude_unset=True))
        return self.__class__(**data)
```

2. Implementar sistema de gerenciamento de configuração:

```python
class ConfigManager:
    """Manager for configurations."""
    
    def __init__(self):
        self._configs: Dict[str, BaseConfig] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_config(
        self,
        name: str,
        config: BaseConfig
    ) -> None:
        """Register a configuration."""
        self._configs[name] = config
        
    def get_config(
        self,
        name: str
    ) -> BaseConfig:
        """Get configuration by name."""
        if name not in self._configs:
            raise ValueError(f"No configuration registered for: {name}")
            
        return self._configs[name]
        
    def load_from_env(
        self,
        name: str,
        config_class: Type[BaseConfig]
    ) -> BaseConfig:
        """Load configuration from environment."""
        try:
            config = config_class.from_env()
            self.register_config(name, config)
            
            self._metrics.counter(
                "config_loads",
                1,
                source="env",
                name=name,
                success="true"
            )
            
            return config
            
        except Exception as e:
            self._metrics.counter(
                "config_loads",
                1,
                source="env",
                name=name,
                success="false"
            )
            
            self._logger.error(
                "Failed to load config from env",
                extra={
                    "name": name,
                    "error": str(e)
                }
            )
            
            raise
            
    def load_from_file(
        self,
        name: str,
        config_class: Type[BaseConfig],
        path: Union[str, Path]
    ) -> BaseConfig:
        """Load configuration from file."""
        try:
            config = config_class.from_file(path)
            self.register_config(name, config)
            
            self._metrics.counter(
                "config_loads",
                1,
                source="file",
                name=name,
                success="true"
            )
            
            return config
            
        except Exception as e:
            self._metrics.counter(
                "config_loads",
                1,
                source="file",
                name=name,
                success="false"
            )
            
            self._logger.error(
                "Failed to load config from file",
                extra={
                    "name": name,
                    "path": str(path),
                    "error": str(e)
                }
            )
            
            raise
```

3. Implementar configurações específicas:

```python
class AgentConfig(BaseConfig):
    """Configuration for agents."""
    
    model: str = Field(...)
    temperature: float = Field(default=0.7)
    max_tokens: int = Field(default=1000)
    
    @validator("temperature")
    def validate_temperature(cls, v: float) -> float:
        """Validate temperature."""
        if not 0 <= v <= 1:
            raise ValueError("Temperature must be between 0 and 1")
        return v

class MemoryConfig(BaseConfig):
    """Configuration for memory stores."""
    
    store_type: str = Field(...)
    ttl: Optional[int] = None
    max_size: Optional[int] = None
    
    @validator("ttl", "max_size")
    def validate_positive(cls, v: Optional[int]) -> Optional[int]:
        """Validate positive integers."""
        if v is not None and v <= 0:
            raise ValueError("Value must be positive")
        return v

class ProcessorConfig(BaseConfig):
    """Configuration for processors."""
    
    batch_size: int = Field(default=100)
    timeout: float = Field(default=30.0)
    retry_count: int = Field(default=3)
```

4. Implementar sistema de monitoramento:

```python
class ConfigMonitor:
    """Monitor for configuration operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        name: str,
        source: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record configuration operation."""
        self._metrics.counter(
            "config_operations",
            1,
            name=name,
            source=source,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar implementações existentes:
   - Converter configurações para Pydantic models
   - Atualizar carregamento de configurações
   - Implementar validações específicas

## Validação

```python
async def test_config_system():
    # Setup
    manager = ConfigManager()
    monitor = ConfigMonitor()
    
    # Test agent config
    agent_data = {
        "model": "gpt-4",
        "temperature": 0.8,
        "env": "test"
    }
    
    with open("/tmp/agent.yml", "w") as f:
        yaml.dump(agent_data, f)
        
    agent_config = await manager.load_from_file(
        "agent",
        AgentConfig,
        "/tmp/agent.yml"
    )
    
    assert agent_config.model == "gpt-4"
    assert agent_config.temperature == 0.8
    
    # Test memory config
    os.environ["PEPPERPY_STORE_TYPE"] = "redis"
    os.environ["PEPPERPY_TTL"] = "3600"
    
    memory_config = await manager.load_from_env(
        "memory",
        MemoryConfig
    )
    
    assert memory_config.store_type == "redis"
    assert memory_config.ttl == 3600
    
    # Test processor config
    processor_config = ProcessorConfig(
        batch_size=200,
        timeout=60.0
    )
    
    manager.register_config("processor", processor_config)
    assert manager.get_config("processor").batch_size == 200
    
    # Test monitoring
    await monitor.record_operation("agent", "file", True)
    await monitor.record_operation("memory", "env", True)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_config_system():
    # Restore legacy implementations
    shutil.copy("core/config_legacy.py", "core/config.py")
    shutil.copy("agents/config_legacy.py", "agents/config.py")
    
    # Cleanup new implementations
    os.remove("core/config/base.py")
    os.remove("core/config/manager.py")
    os.remove("core/config/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de configuração
   - Interface consistente
   - Validações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de configuração não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 10ms para carregamento
   - Cache de configurações
   - Validação eficiente

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de configuração
- [ ] Implementação do gerenciamento de configurações
- [ ] Implementação das configurações específicas
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
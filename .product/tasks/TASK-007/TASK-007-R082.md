# R082: Padronização do Sistema de Eventos

## Descrição

Unificar e padronizar o sistema de eventos em todo o framework, estabelecendo uma interface consistente para comunicação assíncrona entre componentes. O sistema atual possui diferentes implementações de eventos espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R068: Consolidação do Sistema de Processamento Assíncrono
- R073: Padronização do Sistema de Configuração

## Estado Atual

Atualmente, os eventos estão distribuídos em vários módulos:

1. Em `core/events.py`:
```python
class EventEmitter:
    """Simple event emitter."""
    
    def __init__(self):
        self._handlers = {}
        
    def on(
        self,
        event: str,
        handler: Callable[..., Any]
    ) -> None:
        """Register event handler."""
        if event not in self._handlers:
            self._handlers[event] = []
        self._handlers[event].append(handler)
        
    def emit(
        self,
        event: str,
        *args: Any,
        **kwargs: Any
    ) -> None:
        """Emit event."""
        if event in self._handlers:
            for handler in self._handlers[event]:
                handler(*args, **kwargs)
```

2. Em `agents/events.py`:
```python
class AgentEventBus:
    """Event bus for agent operations."""
    
    def __init__(self):
        self._subscribers = {}
        
    async def subscribe(
        self,
        topic: str,
        callback: Callable[..., Awaitable[None]]
    ) -> None:
        """Subscribe to topic."""
        if topic not in self._subscribers:
            self._subscribers[topic] = []
        self._subscribers[topic].append(callback)
        
    async def publish(
        self,
        topic: str,
        data: Any
    ) -> None:
        """Publish to topic."""
        if topic in self._subscribers:
            for callback in self._subscribers[topic]:
                await callback(data)
```

## Plano de Implementação

1. Criar sistema base de eventos:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union, Callable, Awaitable
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import asyncio
import json
import logging

T = TypeVar("T")

class EventType(Enum):
    """Event types."""
    
    SYSTEM = "system"
    AGENT = "agent"
    USER = "user"
    CUSTOM = "custom"

@dataclass
class EventMetadata:
    """Metadata for events."""
    
    name: str
    type: EventType
    description: str
    schema: Dict[str, Any]
    labels: Dict[str, str] = field(default_factory=dict)

@dataclass
class Event:
    """Base class for events."""
    
    metadata: EventMetadata
    data: Any
    timestamp: datetime = field(default_factory=datetime.now)
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

class EventHandler(ABC):
    """Base class for event handlers."""
    
    @abstractmethod
    async def handle(
        self,
        event: Event
    ) -> None:
        """Handle event."""
        pass

class EventFilter(ABC):
    """Base class for event filters."""
    
    @abstractmethod
    def matches(
        self,
        event: Event
    ) -> bool:
        """Check if event matches filter."""
        pass

class TypeFilter(EventFilter):
    """Filter events by type."""
    
    def __init__(self, type: EventType):
        self._type = type
        
    def matches(
        self,
        event: Event
    ) -> bool:
        """Check if event matches type."""
        return event.metadata.type == self._type

class LabelFilter(EventFilter):
    """Filter events by labels."""
    
    def __init__(self, labels: Dict[str, str]):
        self._labels = labels
        
    def matches(
        self,
        event: Event
    ) -> bool:
        """Check if event matches labels."""
        return all(
            event.metadata.labels.get(k) == v
            for k, v in self._labels.items()
        )

class CompositeFilter(EventFilter):
    """Composite filter combining multiple filters."""
    
    def __init__(
        self,
        filters: List[EventFilter],
        operator: str = "and"
    ):
        self._filters = filters
        self._operator = operator
        
    def matches(
        self,
        event: Event
    ) -> bool:
        """Check if event matches all filters."""
        if self._operator == "and":
            return all(
                f.matches(event)
                for f in self._filters
            )
        else:  # or
            return any(
                f.matches(event)
                for f in self._filters
            )
```

2. Implementar sistema de gerenciamento de eventos:

```python
class EventBus:
    """Event bus for managing events."""
    
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
        self._filters: Dict[str, List[EventFilter]] = {}
        self._logger = logging.getLogger(__name__)
        
    def register_handler(
        self,
        handler: EventHandler,
        filters: Optional[List[EventFilter]] = None
    ) -> str:
        """Register event handler."""
        handler_id = str(uuid.uuid4())
        self._handlers[handler_id] = handler
        
        if filters:
            self._filters[handler_id] = filters
            
        return handler_id
        
    def unregister_handler(
        self,
        handler_id: str
    ) -> None:
        """Unregister event handler."""
        if handler_id in self._handlers:
            del self._handlers[handler_id]
            
        if handler_id in self._filters:
            del self._filters[handler_id]
            
    async def emit(
        self,
        event: Event
    ) -> None:
        """Emit event to all matching handlers."""
        try:
            tasks = []
            
            for handler_id, handler in self._handlers.items():
                if self._matches_filters(handler_id, event):
                    tasks.append(
                        asyncio.create_task(
                            handler.handle(event)
                        )
                    )
                    
            if tasks:
                await asyncio.gather(*tasks)
                
        except Exception as e:
            self._logger.error(
                "Failed to emit event",
                extra={
                    "event_id": event.id,
                    "event_type": event.metadata.type.value,
                    "error": str(e)
                }
            )
            
    def _matches_filters(
        self,
        handler_id: str,
        event: Event
    ) -> bool:
        """Check if event matches handler filters."""
        if handler_id not in self._filters:
            return True
            
        return all(
            f.matches(event)
            for f in self._filters[handler_id]
        )
```

3. Implementar handlers comuns:

```python
class LoggingHandler(EventHandler):
    """Handler that logs events."""
    
    def __init__(self, logger: Optional[logging.Logger] = None):
        self._logger = logger or logging.getLogger(__name__)
        
    async def handle(
        self,
        event: Event
    ) -> None:
        """Log event."""
        self._logger.info(
            "Event received",
            extra={
                "event_id": event.id,
                "event_type": event.metadata.type.value,
                "event_name": event.metadata.name,
                "event_data": event.data
            }
        )

class MetricsHandler(EventHandler):
    """Handler that records metrics."""
    
    def __init__(self, metrics: MetricsManager):
        self._metrics = metrics
        
    async def handle(
        self,
        event: Event
    ) -> None:
        """Record event metrics."""
        self._metrics.counter(
            "events_total",
            1,
            type=event.metadata.type.value,
            name=event.metadata.name,
            **event.metadata.labels
        )

class WebhookHandler(EventHandler):
    """Handler that sends events to webhook."""
    
    def __init__(
        self,
        url: str,
        headers: Optional[Dict[str, str]] = None
    ):
        self._url = url
        self._headers = headers or {}
        self._client = httpx.AsyncClient()
        
    async def handle(
        self,
        event: Event
    ) -> None:
        """Send event to webhook."""
        await self._client.post(
            self._url,
            headers=self._headers,
            json={
                "id": event.id,
                "type": event.metadata.type.value,
                "name": event.metadata.name,
                "data": event.data,
                "timestamp": event.timestamp.isoformat(),
                "labels": event.metadata.labels
            }
        )
```

4. Implementar sistema de monitoramento:

```python
class EventMonitor:
    """Monitor for event operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def record_operation(
        self,
        operation: str,
        event_type: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record event operation."""
        try:
            self._metrics.counter(
                "event_operations",
                1,
                operation=operation,
                type=event_type,
                success=str(success).lower(),
                **labels
            )
            
            if success:
                self._metrics.histogram(
                    "event_duration",
                    duration,
                    operation=operation,
                    type=event_type,
                    **labels
                )
                
        except Exception as e:
            self._logger.error(
                "Failed to record event operation",
                extra={
                    "operation": operation,
                    "type": event_type,
                    "success": success,
                    "duration": duration,
                    "labels": labels,
                    "error": str(e)
                }
            )
```

5. Migrar implementações existentes:
   - Converter eventos para nova interface
   - Atualizar emissão de eventos
   - Implementar handlers específicos

## Validação

```python
async def test_event_system():
    # Setup
    bus = EventBus()
    monitor = EventMonitor()
    metrics = MetricsManager()
    
    # Create handlers
    logging_handler = LoggingHandler()
    metrics_handler = MetricsHandler(metrics)
    webhook_handler = WebhookHandler("http://localhost:8000/webhook")
    
    # Register handlers with filters
    bus.register_handler(
        logging_handler,
        filters=[
            TypeFilter(EventType.SYSTEM)
        ]
    )
    
    bus.register_handler(
        metrics_handler,
        filters=[
            LabelFilter({"service": "api"})
        ]
    )
    
    bus.register_handler(
        webhook_handler,
        filters=[
            CompositeFilter([
                TypeFilter(EventType.USER),
                LabelFilter({"priority": "high"})
            ])
        ]
    )
    
    # Create and emit event
    event = Event(
        metadata=EventMetadata(
            name="user.login",
            type=EventType.USER,
            description="User login event",
            schema={
                "type": "object",
                "properties": {
                    "user_id": {"type": "string"},
                    "timestamp": {"type": "string"}
                }
            },
            labels={
                "service": "api",
                "priority": "high"
            }
        ),
        data={
            "user_id": "123",
            "timestamp": "2024-02-22T12:00:00Z"
        }
    )
    
    await bus.emit(event)
    
    # Test monitoring
    await monitor.record_operation(
        "emit",
        "user",
        True,
        0.001,
        service="api"
    )
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_event_system():
    # Restore legacy implementations
    shutil.copy("core/events_legacy.py", "core/events.py")
    shutil.copy("agents/events_legacy.py", "agents/events.py")
    
    # Cleanup new implementations
    os.remove("core/events/base.py")
    os.remove("core/events/bus.py")
    os.remove("core/events/handlers.py")
    os.remove("core/events/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de eventos
   - Interface consistente
   - Handlers unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero perda de eventos
   - Documentação completa

3. **Performance**:
   - Latência < 1ms por evento
   - Processamento paralelo eficiente
   - Baixo consumo de memória

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de eventos
- [ ] Implementação do gerenciamento de eventos
- [ ] Implementação dos handlers comuns
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R047: Consolidação do Sistema de Validação

## Descrição

Consolidar o sistema de validação para garantir consistência nas validações de configuração, estado e entrada em todo o framework. O sistema atual apresenta validações dispersas e inconsistentes em diferentes módulos, dificultando a manutenção e aumentando a probabilidade de erros.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Unificação do Tratamento de Erros

## Estado Atual

Atualmente, as validações estão dispersas em vários módulos com diferentes implementações:

1. Em `core/registry.py`:
```python
class Registry(Generic[T]):
    def _validate_component_type(self, component_type: str, component_class: type[T]) -> None:
        if not component_type:
            raise RegistryError("Component type cannot be empty")
        if not isinstance(component_type, str):
            raise RegistryError("Component type must be a string")
        if component_type in self._items:
            raise RegistryError(f"Component type already registered: {component_type}")
```

2. Em `agents/providers/factory.py`:
```python
class ProviderFactory(BaseComponent):
    def validate(self) -> None:
        super().validate()
        if not isinstance(self._provider_types, dict):
            raise ConfigurationError("Provider types must be a dictionary")
```

3. Em `core/config/manager.py`:
```python
class ConfigurationManager(Generic[T]):
    def _load_from_file(self, config_path: Path) -> Dict[str, Any]:
        try:
            config_data = config_path.read_text()
            return self._config_class.parse_raw(config_data).dict()
        except ValidationError as e:
            raise ConfigurationError(
                f"Invalid configuration format: {e}",
                details={"path": str(config_path), "errors": e.errors()},
                recovery_hint="Check configuration file format and required fields",
            )
```

## Plano de Implementação

1. Criar uma interface unificada para validação:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Type, TypeVar
from dataclasses import dataclass
from enum import Enum

T = TypeVar("T")

class ValidationLevel(Enum):
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"

@dataclass
class ValidationResult:
    level: ValidationLevel
    message: str
    details: Optional[Dict[str, Any]] = None
    recovery_hint: Optional[str] = None

class Validator(ABC):
    @abstractmethod
    def validate(self, value: Any) -> List[ValidationResult]:
        """Validate a value and return validation results."""
        pass

    @abstractmethod
    def validate_type(self, value: Any, expected_type: Type[T]) -> List[ValidationResult]:
        """Validate value type."""
        pass

    @abstractmethod
    def validate_state(self, component: Any) -> List[ValidationResult]:
        """Validate component state."""
        pass
```

2. Implementar validadores padrão:

```python
class StandardValidator(Validator):
    def validate_type(self, value: Any, expected_type: Type[T]) -> List[ValidationResult]:
        if not isinstance(value, expected_type):
            return [ValidationResult(
                level=ValidationLevel.ERROR,
                message=f"Invalid type: expected {expected_type.__name__}, got {type(value).__name__}",
                details={"value": str(value), "expected_type": expected_type.__name__},
                recovery_hint=f"Ensure value is of type {expected_type.__name__}"
            )]
        return []

    def validate_state(self, component: Any) -> List[ValidationResult]:
        results = []
        
        # Check initialization
        if hasattr(component, "_initialized"):
            if not component._initialized:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    message="Component not initialized",
                    recovery_hint="Call initialize() before using the component"
                ))
        
        # Check required attributes
        for attr in getattr(component, "__required_attrs__", []):
            if not hasattr(component, attr):
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    message=f"Missing required attribute: {attr}",
                    recovery_hint=f"Ensure {attr} is set before using the component"
                ))
        
        return results
```

3. Criar decoradores para validação automática:

```python
def validate_input(validator: Optional[Validator] = None):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            # Get validator
            val = validator or getattr(self, "validator", StandardValidator())
            
            # Validate arguments
            for arg_name, arg_value in kwargs.items():
                if arg_name in func.__annotations__:
                    expected_type = func.__annotations__[arg_name]
                    results = val.validate_type(arg_value, expected_type)
                    if results:
                        raise ValidationError(
                            f"Invalid argument {arg_name}",
                            details={"results": results}
                        )
            
            return await func(self, *args, **kwargs)
        return wrapper
    return decorator

def validate_state(validator: Optional[Validator] = None):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            # Get validator
            val = validator or getattr(self, "validator", StandardValidator())
            
            # Validate component state
            results = val.validate_state(self)
            if results:
                raise ValidationError(
                    "Invalid component state",
                    details={"results": results}
                )
            
            return await func(self, *args, **kwargs)
        return wrapper
    return decorator
```

4. Implementar validação de configuração:

```python
class ConfigValidator(Validator):
    def __init__(self, schema: Dict[str, Any]):
        self.schema = schema
        
    def validate(self, config: Dict[str, Any]) -> List[ValidationResult]:
        results = []
        
        # Validate required fields
        for field, field_schema in self.schema.items():
            if field_schema.get("required", False) and field not in config:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    message=f"Missing required field: {field}",
                    recovery_hint=f"Add {field} to configuration"
                ))
            
            # Validate field type
            if field in config:
                field_type = field_schema.get("type")
                if field_type:
                    type_results = self.validate_type(config[field], field_type)
                    results.extend(type_results)
        
        return results
```

5. Migrar implementações existentes:
   - Atualizar `core/registry.py`
   - Refatorar `agents/providers/factory.py`
   - Modificar `core/config/manager.py`

## Validação

```python
async def test_validation_system():
    # Setup
    validator = StandardValidator()
    
    # Test type validation
    results = validator.validate_type("test", int)
    assert len(results) == 1
    assert results[0].level == ValidationLevel.ERROR
    
    # Test state validation
    class TestComponent:
        _initialized = False
        __required_attrs__ = ["config"]
    
    results = validator.validate_state(TestComponent())
    assert len(results) == 2  # Not initialized and missing config
    
    # Test config validation
    config_validator = ConfigValidator({
        "name": {"type": str, "required": True},
        "value": {"type": int, "required": False}
    })
    
    results = config_validator.validate({"name": "test", "value": 42})
    assert len(results) == 0
    
    # Test decorators
    class TestService:
        @validate_input()
        async def process(self, value: int) -> None:
            pass
    
    service = TestService()
    try:
        await service.process(value="invalid")
        assert False, "Should raise ValidationError"
    except ValidationError:
        pass
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_validation_system():
    # Restore legacy implementations
    shutil.copy("core/validation_legacy.py", "core/validation.py")
    
    # Cleanup new implementations
    os.remove("core/validators")
    os.remove("core/validation_decorators.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - 100% dos módulos usando o novo sistema de validação
   - Zero implementações customizadas de validação
   - Cobertura completa de tipos e estados

2. **Qualidade**:
   - Redução de 80% em erros de validação
   - 100% de cobertura de testes para validações
   - Zero falsos positivos/negativos

3. **Desempenho**:
   - Overhead de validação < 1ms por operação
   - Uso de memória do sistema de validação < 10MB
   - Cache hit rate > 90% para validações frequentes

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface Validator
- [ ] Implementação do StandardValidator
- [ ] Implementação dos decoradores de validação
- [ ] Implementação do ConfigValidator
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
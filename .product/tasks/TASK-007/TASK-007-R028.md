# Unifica√ß√£o do Sistema de Tratamento de Erros

**Task ID**: TASK-007
**Requirement**: R028
**Status**: üìã To Do
**Created**: 2024-02-22
**Updated**: 2024-02-22

## Description

Implementar um sistema unificado de tratamento de erros que padronize a hierarquia, recupera√ß√£o e relat√≥rio de erros em todo o sistema. O sistema deve fornecer uma maneira consistente de lidar com erros, facilitando o diagn√≥stico e a recupera√ß√£o de falhas.

## Dependencies

- R024 (Consolida√ß√£o do Sistema de Observabilidade)
- R027 (Padroniza√ß√£o do Sistema de Gerenciamento de Estado)

## Current State

```python
# Erros dispersos em v√°rios m√≥dulos:
- core/errors.py
- core/exceptions.py
- providers/errors.py
- hub/errors.py
# Falta de hierarquia clara
# Recupera√ß√£o inconsistente
# Aus√™ncia de padroniza√ß√£o
# Dificuldade no diagn√≥stico
```

## Implementation Plan

1. Criar estrutura base do sistema de erros:
```
errors/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ base.py
‚îú‚îÄ‚îÄ types.py
‚îú‚îÄ‚îÄ codes.py
‚îú‚îÄ‚îÄ hierarchy/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ tree.py
‚îú‚îÄ‚îÄ handling/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ handlers.py
‚îú‚îÄ‚îÄ recovery/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ strategies.py
‚îî‚îÄ‚îÄ reporting/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ base.py
    ‚îî‚îÄ‚îÄ formatters.py
```

2. Implementar hierarquia de erros:
```python
from typing import Dict, Optional, Any
from dataclasses import dataclass
from datetime import datetime

class PepperpyError(Exception):
    """Base error for all Pepperpy errors."""
    def __init__(
        self,
        message: str,
        code: str = None,
        details: Dict[str, Any] = None,
        recovery_hint: str = None
    ):
        self.message = message
        self.code = code
        self.details = details or {}
        self.recovery_hint = recovery_hint
        self.timestamp = datetime.now()
        super().__init__(message)

class ValidationError(PepperpyError):
    """Error raised when validation fails."""
    pass

class ResourceError(PepperpyError):
    """Error raised for resource-related issues."""
    pass

class ConfigurationError(PepperpyError):
    """Error raised for configuration issues."""
    pass

class StateError(PepperpyError):
    """Error raised for invalid state transitions."""
    pass
```

3. Implementar sistema de handlers:
```python
from abc import ABC, abstractmethod
from typing import Type, List

class ErrorHandler(ABC):
    @abstractmethod
    def can_handle(self, error: Exception) -> bool:
        pass
        
    @abstractmethod
    def handle(self, error: Exception) -> bool:
        pass

class ErrorHandlerRegistry:
    def __init__(self):
        self.handlers: Dict[Type[Exception], List[ErrorHandler]] = {}
        
    def register(self, error_type: Type[Exception], handler: ErrorHandler):
        if error_type not in self.handlers:
            self.handlers[error_type] = []
        self.handlers[error_type].append(handler)
        
    def handle(self, error: Exception) -> bool:
        error_type = type(error)
        if error_type in self.handlers:
            for handler in self.handlers[error_type]:
                if handler.can_handle(error):
                    return handler.handle(error)
        return False
```

4. Implementar estrat√©gias de recupera√ß√£o:
```python
class RecoveryStrategy(ABC):
    @abstractmethod
    def can_recover(self, error: Exception) -> bool:
        pass
        
    @abstractmethod
    def recover(self, error: Exception) -> bool:
        pass

class RetryStrategy(RecoveryStrategy):
    def __init__(self, max_retries: int = 3, delay: float = 1.0):
        self.max_retries = max_retries
        self.delay = delay
        
    def can_recover(self, error: Exception) -> bool:
        return isinstance(error, (ResourceError, StateError))
        
    def recover(self, error: Exception) -> bool:
        for attempt in range(self.max_retries):
            try:
                # Implementar l√≥gica de retry
                return True
            except Exception:
                time.sleep(self.delay)
        return False
```

5. Implementar sistema de relat√≥rios:
```python
@dataclass
class ErrorReport:
    error: PepperpyError
    context: Dict[str, Any]
    stack_trace: str
    timestamp: datetime
    handled: bool
    recovery_attempted: bool
    recovery_successful: Optional[bool]

class ErrorReporter:
    def __init__(self):
        self.formatters: List[ErrorFormatter] = []
        
    def add_formatter(self, formatter: ErrorFormatter):
        self.formatters.append(formatter)
        
    def report(self, error: PepperpyError) -> ErrorReport:
        report = ErrorReport(
            error=error,
            context=self._get_context(),
            stack_trace=traceback.format_exc(),
            timestamp=datetime.now(),
            handled=False,
            recovery_attempted=False,
            recovery_successful=None
        )
        
        for formatter in self.formatters:
            formatter.format(report)
            
        return report
```

## Validation

```python
def test_error_system():
    # Verificar hierarquia
    from pepperpy.errors import PepperpyError, ValidationError
    try:
        raise ValidationError("test error")
    except PepperpyError as e:
        assert isinstance(e, ValidationError)
        assert e.code is not None
    
    # Verificar handlers
    from pepperpy.errors.handling import ErrorHandlerRegistry
    registry = ErrorHandlerRegistry()
    handler = TestErrorHandler()
    registry.register(ValidationError, handler)
    assert registry.handle(ValidationError("test")) is True
    
    # Verificar recupera√ß√£o
    from pepperpy.errors.recovery import RetryStrategy
    strategy = RetryStrategy(max_retries=3)
    assert strategy.can_recover(ResourceError("test")) is True
    assert strategy.recover(ResourceError("test")) is True
    
    # Verificar relat√≥rios
    from pepperpy.errors.reporting import ErrorReporter
    reporter = ErrorReporter()
    report = reporter.report(ValidationError("test"))
    assert report.error.message == "test"
    assert report.timestamp is not None
```

## Rollback Plan

1. Backup do estado atual:
   - Mapear hierarquia de erros
   - Documentar handlers existentes
   - Backup de logs de erro

2. Procedimento de rollback:
   ```python
   def rollback():
       # Desativar novo sistema
       disable_unified_errors()
       
       # Restaurar handlers antigos
       restore_legacy_error_handlers()
       
       # Restaurar hierarquia antiga
       restore_legacy_error_hierarchy()
   ```

3. Valida√ß√£o p√≥s-rollback:
   - Verificar tratamento de erros
   - Validar logs de erro
   - Confirmar recupera√ß√£o

## Success Metrics

1. Padroniza√ß√£o:
   - 100% dos erros usando nova hierarquia
   - Todos os erros com c√≥digos √∫nicos
   - Recovery hints em todos os erros
   - Contexto completo em relat√≥rios

2. Efici√™ncia:
   - Tempo de handling < 10ms
   - Taxa de recupera√ß√£o > 80%
   - Zero erros n√£o tratados
   - Diagn√≥stico preciso

3. Qualidade:
   - 100% de cobertura de testes
   - Zero regress√µes
   - Documenta√ß√£o completa
   - Guias de troubleshooting

## Progress Updates

- [x] 2024-02-22: Requirement criado e documentado
- [ ] Implementa√ß√£o da estrutura base
- [ ] Hierarquia de erros
- [ ] Sistema de handlers
- [ ] Estrat√©gias de recupera√ß√£o
- [ ] Sistema de relat√≥rios
- [ ] Testes e valida√ß√£o
- [ ] Documenta√ß√£o final 
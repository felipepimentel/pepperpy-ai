# R066: Unificação do Sistema de Carregamento Dinâmico

## Descrição

Unificar e padronizar o sistema de carregamento dinâmico em todo o framework, estabelecendo uma interface consistente para carregamento de módulos e classes. O sistema atual possui diferentes implementações de carregamento dinâmico espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, o carregamento dinâmico está distribuído em vários módulos:

1. Em `core/registry.py`:
```python
class ProviderRegistry:
    """Registry for managing and loading capability providers."""
    
    def load_provider(
        self,
        capability: str,
        provider_type: str,
        base_class: Type[T]
    ) -> Type[T]:
        """Load a provider class dynamically."""
        try:
            # Load provider module
            module_path = f"pepperpy.{capability}.providers.{provider_type}"
            module = importlib.import_module(module_path)
            
            # Get provider class
            provider_class = getattr(module, f"{provider_type.title()}Provider")
            
            # Validate provider class
            if not issubclass(provider_class, base_class):
                raise ConfigError(
                    f"Provider class {provider_class.__name__} does not implement {base_class.__name__}"
                )
                
            return provider_class
            
        except (ImportError, AttributeError) as e:
            raise ConfigError(
                f"Failed to load provider {capability}.{provider_type}: {str(e)}"
            )
```

2. Em `core/config/base.py`:
```python
class Configuration:
    """Central configuration management."""
    
    def load_provider(
        self,
        capability: str,
        provider_type: str,
        provider_config: Dict[str, Any],
        base_class: Type[T]
    ) -> T:
        """Load and instantiate a provider."""
        try:
            # Load provider module
            module_path = f"pepperpy.{capability}.providers.{provider_type}"
            module = importlib.import_module(module_path)
            
            # Get provider class
            provider_class = getattr(module, f"{provider_type.title()}Provider")
            
            # Validate provider class
            if not issubclass(provider_class, base_class):
                raise ConfigurationError(
                    f"Provider class {provider_class.__name__} does not implement {base_class.__name__}"
                )
                
            # Instantiate provider
            return provider_class(**provider_config)
            
        except (ImportError, AttributeError) as e:
            raise ConfigurationError(
                f"Failed to load provider {capability}.{provider_type}: {str(e)}"
            )
```

## Plano de Implementação

1. Criar sistema base de carregamento dinâmico:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime
from importlib import import_module
from inspect import isclass
from pathlib import Path

T = TypeVar("T")

@dataclass
class LoaderMetadata:
    """Metadata for loaded items."""
    name: str
    module_path: str
    class_name: str
    base_class: Type[Any]
    created_at: datetime
    error: Optional[str]

class DynamicLoader(ABC, Generic[T]):
    """Base class for dynamic loaders."""
    
    def __init__(self) -> None:
        """Initialize loader."""
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    async def load_class(
        self,
        module_path: str,
        class_name: str,
        base_class: Type[T]
    ) -> Type[T]:
        """Load a class dynamically.
        
        Args:
            module_path: Full path to module
            class_name: Name of class to load
            base_class: Base class that loaded class must implement
            
        Returns:
            Loaded class
            
        Raises:
            LoaderError: If loading fails
        """
        try:
            # Load module
            module = import_module(module_path)
            
            # Get class
            if not hasattr(module, class_name):
                raise LoaderError(
                    f"Class {class_name} not found in module {module_path}"
                )
                
            loaded_class = getattr(module, class_name)
            
            # Validate class
            if not isclass(loaded_class):
                raise LoaderError(
                    f"{class_name} in module {module_path} is not a class"
                )
                
            if not issubclass(loaded_class, base_class):
                raise LoaderError(
                    f"Class {class_name} does not implement {base_class.__name__}"
                )
                
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_class",
                module=module_path,
                success="true"
            )
            
            return loaded_class
            
        except Exception as e:
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_class",
                module=module_path,
                success="false"
            )
            
            self._logger.error(
                "Failed to load class",
                extra={
                    "module": module_path,
                    "class": class_name,
                    "error": str(e)
                }
            )
            
            raise LoaderError(
                f"Failed to load class {class_name} from {module_path}: {str(e)}"
            )
            
    async def load_instance(
        self,
        module_path: str,
        class_name: str,
        base_class: Type[T],
        **kwargs: Any
    ) -> T:
        """Load and instantiate a class dynamically.
        
        Args:
            module_path: Full path to module
            class_name: Name of class to load
            base_class: Base class that loaded class must implement
            **kwargs: Arguments to pass to class constructor
            
        Returns:
            Class instance
            
        Raises:
            LoaderError: If loading or instantiation fails
        """
        try:
            # Load class
            loaded_class = await self.load_class(
                module_path,
                class_name,
                base_class
            )
            
            # Instantiate class
            instance = loaded_class(**kwargs)
            
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_instance",
                module=module_path,
                success="true"
            )
            
            return instance
            
        except Exception as e:
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_instance",
                module=module_path,
                success="false"
            )
            
            self._logger.error(
                "Failed to load instance",
                extra={
                    "module": module_path,
                    "class": class_name,
                    "error": str(e)
                }
            )
            
            raise LoaderError(
                f"Failed to load instance of {class_name} from {module_path}: {str(e)}"
            )
            
    @abstractmethod
    async def discover(
        self,
        package_path: Union[str, Path],
        base_class: Type[T]
    ) -> Dict[str, Type[T]]:
        """Discover and load classes from package.
        
        Args:
            package_path: Path to package root
            base_class: Base class that discovered classes must implement
            
        Returns:
            Dictionary mapping class names to classes
            
        Raises:
            LoaderError: If discovery fails
        """
        pass
```

2. Implementar sistema de gerenciamento unificado:

```python
class UnifiedLoader:
    """Unified dynamic loading system."""
    
    def __init__(self):
        self._loaders: Dict[str, DynamicLoader] = {}
        self._cache: Dict[str, Any] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_loader(
        self,
        name: str,
        loader: DynamicLoader
    ) -> None:
        """Register a loader."""
        self._loaders[name] = loader
        
    async def load_class(
        self,
        loader_name: str,
        module_path: str,
        class_name: str,
        base_class: Type[T]
    ) -> Type[T]:
        """Load a class using specified loader."""
        if loader_name not in self._loaders:
            raise ValueError(f"Loader not found: {loader_name}")
            
        loader = self._loaders[loader_name]
        
        # Check cache
        cache_key = f"{module_path}.{class_name}"
        if cache_key in self._cache:
            return self._cache[cache_key]
            
        try:
            # Load class
            loaded_class = await loader.load_class(
                module_path,
                class_name,
                base_class
            )
            
            # Update cache
            self._cache[cache_key] = loaded_class
            
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_class",
                loader=loader_name,
                success="true"
            )
            
            return loaded_class
            
        except Exception as e:
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_class",
                loader=loader_name,
                success="false"
            )
            
            self._logger.error(
                "Failed to load class",
                extra={
                    "loader": loader_name,
                    "module": module_path,
                    "class": class_name,
                    "error": str(e)
                }
            )
            
            raise
            
    async def load_instance(
        self,
        loader_name: str,
        module_path: str,
        class_name: str,
        base_class: Type[T],
        **kwargs: Any
    ) -> T:
        """Load and instantiate a class using specified loader."""
        if loader_name not in self._loaders:
            raise ValueError(f"Loader not found: {loader_name}")
            
        loader = self._loaders[loader_name]
        
        try:
            # Load instance
            instance = await loader.load_instance(
                module_path,
                class_name,
                base_class,
                **kwargs
            )
            
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_instance",
                loader=loader_name,
                success="true"
            )
            
            return instance
            
        except Exception as e:
            self._metrics.counter(
                "loader_operations",
                1,
                operation="load_instance",
                loader=loader_name,
                success="false"
            )
            
            self._logger.error(
                "Failed to load instance",
                extra={
                    "loader": loader_name,
                    "module": module_path,
                    "class": class_name,
                    "error": str(e)
                }
            )
            
            raise
            
    async def discover(
        self,
        loader_name: str,
        package_path: Union[str, Path],
        base_class: Type[T]
    ) -> Dict[str, Type[T]]:
        """Discover and load classes using specified loader."""
        if loader_name not in self._loaders:
            raise ValueError(f"Loader not found: {loader_name}")
            
        loader = self._loaders[loader_name]
        
        try:
            # Discover classes
            discovered = await loader.discover(package_path, base_class)
            
            # Update cache
            for name, cls in discovered.items():
                self._cache[name] = cls
                
            self._metrics.counter(
                "loader_operations",
                1,
                operation="discover",
                loader=loader_name,
                success="true"
            )
            
            return discovered
            
        except Exception as e:
            self._metrics.counter(
                "loader_operations",
                1,
                operation="discover",
                loader=loader_name,
                success="false"
            )
            
            self._logger.error(
                "Failed to discover classes",
                extra={
                    "loader": loader_name,
                    "package": str(package_path),
                    "error": str(e)
                }
            )
            
            raise
```

3. Implementar loaders específicos:

```python
class ProviderLoader(DynamicLoader[BaseProvider]):
    """Loader for provider classes."""
    
    async def discover(
        self,
        package_path: Union[str, Path],
        base_class: Type[BaseProvider]
    ) -> Dict[str, Type[BaseProvider]]:
        """Discover provider classes."""
        discovered = {}
        package_path = Path(package_path)
        
        # Scan provider directories
        for provider_dir in package_path.glob("*/providers"):
            if not provider_dir.is_dir():
                continue
                
            # Load provider modules
            for provider_file in provider_dir.glob("*.py"):
                if provider_file.stem == "__init__":
                    continue
                    
                try:
                    # Get module path
                    module_path = ".".join(
                        provider_file.relative_to(package_path.parent)
                        .with_suffix("")
                        .parts
                    )
                    
                    # Load module
                    module = import_module(module_path)
                    
                    # Find provider classes
                    for name, obj in module.__dict__.items():
                        if (
                            isclass(obj)
                            and issubclass(obj, base_class)
                            and obj != base_class
                        ):
                            discovered[name] = obj
                            
                except Exception as e:
                    self._logger.error(
                        "Failed to discover provider",
                        extra={
                            "module": module_path,
                            "error": str(e)
                        }
                    )
                    
        return discovered

class ComponentLoader(DynamicLoader[BaseComponent]):
    """Loader for component classes."""
    
    async def discover(
        self,
        package_path: Union[str, Path],
        base_class: Type[BaseComponent]
    ) -> Dict[str, Type[BaseComponent]]:
        """Discover component classes."""
        discovered = {}
        package_path = Path(package_path)
        
        # Scan component directories
        for component_file in package_path.rglob("*.py"):
            if component_file.stem == "__init__":
                continue
                
            try:
                # Get module path
                module_path = ".".join(
                    component_file.relative_to(package_path.parent)
                    .with_suffix("")
                    .parts
                )
                
                # Load module
                module = import_module(module_path)
                
                # Find component classes
                for name, obj in module.__dict__.items():
                    if (
                        isclass(obj)
                        and issubclass(obj, base_class)
                        and obj != base_class
                    ):
                        discovered[name] = obj
                        
            except Exception as e:
                self._logger.error(
                    "Failed to discover component",
                    extra={
                        "module": module_path,
                        "error": str(e)
                    }
                )
                
        return discovered
```

4. Implementar sistema de monitoramento:

```python
class LoaderMonitor:
    """Monitor for dynamic loading."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        loader: str,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record loader operation."""
        self._metrics.counter(
            "loader_operations",
            1,
            loader=loader,
            operation=operation,
            success=str(success).lower(),
            **labels
        )
        
    async def record_discovery(
        self,
        loader: str,
        discovered: int,
        **labels: str
    ) -> None:
        """Record discovery results."""
        self._metrics.gauge(
            "loader_discovered",
            discovered,
            loader=loader,
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `core/registry.py`
   - Atualizar `core/config/base.py`
   - Criar novos loaders conforme necessário

## Validação

```python
async def test_loader_system():
    # Setup
    loader = UnifiedLoader()
    monitor = LoaderMonitor()
    
    # Register loaders
    provider_loader = ProviderLoader()
    component_loader = ComponentLoader()
    
    loader.register_loader("provider", provider_loader)
    loader.register_loader("component", component_loader)
    
    # Test class loading
    provider_class = await loader.load_class(
        "provider",
        "pepperpy.memory.providers.local",
        "LocalProvider",
        BaseProvider
    )
    
    assert issubclass(provider_class, BaseProvider)
    
    # Test instance loading
    provider = await loader.load_instance(
        "provider",
        "pepperpy.memory.providers.local",
        "LocalProvider",
        BaseProvider,
        config={"path": "test"}
    )
    
    assert isinstance(provider, BaseProvider)
    
    # Test discovery
    discovered = await loader.discover(
        "provider",
        Path("pepperpy"),
        BaseProvider
    )
    
    assert "LocalProvider" in discovered
    assert issubclass(discovered["LocalProvider"], BaseProvider)
    
    # Test monitoring
    await monitor.record_operation("provider", "load_class", True)
    await monitor.record_discovery("provider", len(discovered))
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_loader_system():
    # Restore legacy implementations
    shutil.copy("core/registry_legacy.py", "core/registry.py")
    shutil.copy("core/config/base_legacy.py", "core/config/base.py")
    
    # Cleanup new implementations
    os.remove("core/loader/base.py")
    os.remove("core/loader/unified.py")
    os.remove("core/loader/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de carregamento
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de carregamento não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para carregamento de classe
   - Latência < 100ms para descoberta
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de carregamento
- [ ] Implementação do gerenciamento unificado
- [ ] Implementação dos loaders específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
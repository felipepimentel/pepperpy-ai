# R058: Consolidação do Sistema de Gerenciamento de Estado

## Descrição

Unificar o gerenciamento de estado dos componentes do framework, removendo implementações redundantes e inconsistentes. O sistema atual apresenta diferentes abordagens para gerenciamento de estado em vários módulos, dificultando a manutenção e a consistência do estado da aplicação.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R055: Consolidação do Sistema de Memória
- R057: Unificação do Sistema de Busca e Recuperação

## Estado Atual

Atualmente, o gerenciamento de estado está disperso em diferentes módulos com implementações inconsistentes:

1. Em `core/providers/base.py`:
```python
class Provider:
    def __init__(self):
        self._state = {}
        self._lock = asyncio.Lock()

    async def get_state(self, key: str) -> Any:
        async with self._lock:
            return self._state.get(key)

    async def set_state(self, key: str, value: Any) -> None:
        async with self._lock:
            self._state[key] = value
```

2. Em `core/lifecycle.py`:
```python
class LifecycleManager:
    def __init__(self):
        self._components = {}
        self._status = {}

    def get_status(self, component: str) -> str:
        return self._status.get(component, "unknown")

    def set_status(self, component: str, status: str) -> None:
        self._status[component] = status
```

## Plano de Implementação

1. Criar interface unificada para gerenciamento de estado:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

T = TypeVar("T")

class StateType(Enum):
    EPHEMERAL = "ephemeral"  # Estado temporário
    PERSISTENT = "persistent"  # Estado persistente
    SHARED = "shared"  # Estado compartilhado

@dataclass
class StateEntry(Generic[T]):
    key: str
    value: T
    type: StateType
    metadata: Optional[Dict[str, Any]] = None
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()
    version: int = 1

class StateManager(ABC, Generic[T]):
    @abstractmethod
    async def get(
        self,
        key: str,
        default: Optional[T] = None
    ) -> Optional[T]:
        """Get state value by key."""
        pass

    @abstractmethod
    async def set(
        self,
        key: str,
        value: T,
        type: StateType = StateType.EPHEMERAL,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """Set state value."""
        pass

    @abstractmethod
    async def delete(self, key: str) -> bool:
        """Delete state by key."""
        pass

    @abstractmethod
    async def exists(self, key: str) -> bool:
        """Check if state exists."""
        pass

    @abstractmethod
    async def list(
        self,
        pattern: Optional[str] = None,
        type: Optional[StateType] = None
    ) -> List[str]:
        """List state keys matching pattern and type."""
        pass
```

2. Implementar gerenciador base com funcionalidades comuns:

```python
class BaseStateManager(StateManager[T]):
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._lock = asyncio.Lock()
        self._store: Dict[str, StateEntry[T]] = {}

    async def exists(self, key: str) -> bool:
        async with self._lock:
            return key in self._store

    async def get(
        self,
        key: str,
        default: Optional[T] = None
    ) -> Optional[T]:
        async with self._lock:
            entry = self._store.get(key)
            if entry is None:
                await self._record_operation("get", False, reason="not_found")
                return default

            await self._record_operation("get", True)
            return entry.value

    async def set(
        self,
        key: str,
        value: T,
        type: StateType = StateType.EPHEMERAL,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        async with self._lock:
            existing = self._store.get(key)
            version = existing.version + 1 if existing else 1

            entry = StateEntry(
                key=key,
                value=value,
                type=type,
                metadata=metadata,
                updated_at=datetime.now(),
                version=version
            )

            self._store[key] = entry
            await self._record_operation("set", True)

    async def delete(self, key: str) -> bool:
        async with self._lock:
            if key not in self._store:
                await self._record_operation("delete", False, reason="not_found")
                return False

            del self._store[key]
            await self._record_operation("delete", True)
            return True

    async def list(
        self,
        pattern: Optional[str] = None,
        type: Optional[StateType] = None
    ) -> List[str]:
        async with self._lock:
            keys = []
            for key, entry in self._store.items():
                if pattern and not key.startswith(pattern):
                    continue
                if type and entry.type != type:
                    continue
                keys.append(key)
            return keys

    async def _record_operation(
        self,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        self._metrics.counter(
            f"state_manager_{operation}",
            1,
            success=str(success).lower(),
            **labels
        )
```

3. Implementar gerenciador persistente:

```python
class PersistentStateManager(BaseStateManager[T]):
    def __init__(self, store: MemoryStore[T]):
        super().__init__()
        self._store = store

    async def get(
        self,
        key: str,
        default: Optional[T] = None
    ) -> Optional[T]:
        entry = await self._store.get(key)
        if entry is None:
            await self._record_operation("get", False, reason="not_found")
            return default

        await self._record_operation("get", True)
        return entry.value

    async def set(
        self,
        key: str,
        value: T,
        type: StateType = StateType.PERSISTENT,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        await self._store.set(
            key,
            value,
            metadata={
                **(metadata or {}),
                "state_type": type.value
            }
        )
        await self._record_operation("set", True)

    async def list(
        self,
        pattern: Optional[str] = None,
        type: Optional[StateType] = None
    ) -> List[str]:
        keys = []
        async for key in self._store.scan(pattern):
            if type:
                entry = await self._store.get(key)
                if entry is None:
                    continue
                if entry.metadata.get("state_type") != type.value:
                    continue
            keys.append(key)
        return keys
```

4. Implementar gerenciador compartilhado:

```python
class SharedStateManager(BaseStateManager[T]):
    def __init__(self, namespace: str):
        super().__init__()
        self._namespace = namespace
        self._subscribers: Dict[str, List[Callable[[str, T], Awaitable[None]]]] = {}

    async def set(
        self,
        key: str,
        value: T,
        type: StateType = StateType.SHARED,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        await super().set(key, value, type, metadata)
        await self._notify_subscribers(key, value)

    def subscribe(
        self,
        key: str,
        callback: Callable[[str, T], Awaitable[None]]
    ) -> None:
        if key not in self._subscribers:
            self._subscribers[key] = []
        self._subscribers[key].append(callback)

    def unsubscribe(
        self,
        key: str,
        callback: Callable[[str, T], Awaitable[None]]
    ) -> None:
        if key in self._subscribers:
            self._subscribers[key].remove(callback)
            if not self._subscribers[key]:
                del self._subscribers[key]

    async def _notify_subscribers(self, key: str, value: T) -> None:
        if key in self._subscribers:
            for callback in self._subscribers[key]:
                try:
                    await callback(key, value)
                except Exception as e:
                    logger.error(
                        f"Error notifying subscriber for {key}: {e}",
                        exc_info=True
                    )
```

5. Implementar fábrica de gerenciadores:

```python
class StateManagerFactory:
    def __init__(self):
        self._managers: Dict[str, StateManager] = {}
        self._store = LocalMemoryStore()

    def create_manager(
        self,
        name: str,
        type: str = "ephemeral"
    ) -> StateManager:
        if name in self._managers:
            return self._managers[name]

        if type == "persistent":
            manager = PersistentStateManager(self._store)
        elif type == "shared":
            manager = SharedStateManager(name)
        else:
            manager = BaseStateManager()

        self._managers[name] = manager
        return manager
```

6. Migrar implementações existentes:
   - Atualizar `core/providers/base.py`
   - Atualizar `core/lifecycle.py`
   - Criar novos gerenciadores conforme necessário

## Validação

```python
async def test_state_system():
    # Setup
    factory = StateManagerFactory()
    manager = factory.create_manager("test")

    # Test basic operations
    await manager.set("key1", "value1")
    value = await manager.get("key1")
    assert value == "value1"

    # Test persistent state
    persistent = factory.create_manager("persistent", "persistent")
    await persistent.set("key2", "value2", StateType.PERSISTENT)
    value = await persistent.get("key2")
    assert value == "value2"

    # Test shared state
    shared = factory.create_manager("shared", "shared")
    results = []

    async def on_change(key: str, value: str) -> None:
        results.append((key, value))

    shared.subscribe("key3", on_change)
    await shared.set("key3", "value3", StateType.SHARED)
    assert len(results) == 1
    assert results[0] == ("key3", "value3")

    # Test listing
    await manager.set("prefix:1", "value1")
    await manager.set("prefix:2", "value2")
    keys = await manager.list("prefix:")
    assert len(keys) == 2
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_state_system():
    # Restore legacy implementations
    shutil.copy("core/providers/base_legacy.py", "core/providers/base.py")
    shutil.copy("core/lifecycle_legacy.py", "core/lifecycle.py")

    # Cleanup new implementations
    os.remove("core/state/manager.py")
    os.remove("core/state/factory.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de estado
   - Interface consistente
   - Gerenciadores unificados

2. **Desempenho**:
   - Latência < 1ms para operações locais
   - Throughput > 10k ops/s
   - Uso eficiente de memória

3. **Confiabilidade**:
   - Zero perda de estado
   - Consistência garantida
   - Recuperação automática

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface StateManager
- [ ] Implementação do BaseStateManager
- [ ] Implementação do PersistentStateManager
- [ ] Implementação do SharedStateManager
- [ ] Implementação do StateManagerFactory
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R056: Padronização do Sistema de Validação de Configuração

## Descrição

Consolidar a validação de configurações em um sistema unificado, removendo duplicações e inconsistências entre diferentes módulos. O sistema atual apresenta validações dispersas e redundantes, dificultando a manutenção e aumentando a chance de erros.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R050: Consolidação do Sistema de Configuração

## Estado Atual

Atualmente, a validação de configurações está dispersa em diferentes módulos:

1. Em `core/config/base.py`:
```python
class Configuration:
    def validate(self) -> None:
        if not self.name:
            raise ConfigurationError("Configuration name is required")
        if not self.version:
            raise ConfigurationError("Configuration version is required")
```

2. Em `core/config/loader.py`:
```python
def validate_config(config: Dict[str, Any]) -> None:
    if "providers" not in config:
        raise ConfigurationError("Missing providers section")
    if not isinstance(config["providers"], dict):
        raise ConfigurationError("Providers must be a dictionary")
```

## Plano de Implementação

1. Criar interface unificada para validação de configuração:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar, Union
from dataclasses import dataclass
from enum import Enum

T = TypeVar("T")

class ValidationSeverity(Enum):
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"

@dataclass
class ValidationResult:
    path: str
    message: str
    severity: ValidationSeverity
    context: Optional[Dict[str, Any]] = None

class ConfigValidator(ABC, Generic[T]):
    @abstractmethod
    def validate(self, config: T) -> List[ValidationResult]:
        """Validate configuration and return list of validation results."""
        pass

    @abstractmethod
    def validate_field(
        self,
        field: str,
        value: Any,
        context: Optional[Dict[str, Any]] = None
    ) -> List[ValidationResult]:
        """Validate specific configuration field."""
        pass
```

2. Implementar validadores base:

```python
class BaseConfigValidator(ConfigValidator[T]):
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        self._rules: Dict[str, List[ValidationRule]] = {}

    def register_rule(
        self,
        field: str,
        rule: ValidationRule
    ) -> None:
        if field not in self._rules:
            self._rules[field] = []
        self._rules[field].append(rule)

    async def validate(self, config: T) -> List[ValidationResult]:
        results = []
        for field, rules in self._rules.items():
            value = getattr(config, field, None)
            field_results = await self.validate_field(field, value)
            results.extend(field_results)
            
        await self._record_validation(results)
        return results

    async def _record_validation(
        self,
        results: List[ValidationResult]
    ) -> None:
        for result in results:
            self._metrics.counter(
                "config_validation",
                1,
                severity=result.severity.value,
                path=result.path
            )
```

3. Implementar regras de validação:

```python
@dataclass
class ValidationRule:
    name: str
    message: str
    severity: ValidationSeverity
    
    async def validate(
        self,
        value: Any,
        context: Optional[Dict[str, Any]] = None
    ) -> Optional[ValidationResult]:
        """Validate value and return result if validation fails."""
        pass

class RequiredFieldRule(ValidationRule):
    async def validate(
        self,
        value: Any,
        context: Optional[Dict[str, Any]] = None
    ) -> Optional[ValidationResult]:
        if value is None:
            return ValidationResult(
                path=context["field"],
                message=self.message,
                severity=self.severity,
                context=context
            )
        return None

class TypeRule(ValidationRule):
    def __init__(
        self,
        expected_type: Union[type, tuple[type, ...]],
        **kwargs: Any
    ):
        super().__init__(**kwargs)
        self.expected_type = expected_type
        
    async def validate(
        self,
        value: Any,
        context: Optional[Dict[str, Any]] = None
    ) -> Optional[ValidationResult]:
        if value is not None and not isinstance(value, self.expected_type):
            return ValidationResult(
                path=context["field"],
                message=self.message,
                severity=self.severity,
                context={
                    **(context or {}),
                    "expected_type": self.expected_type,
                    "actual_type": type(value)
                }
            )
        return None
```

4. Implementar validador de configuração:

```python
class ConfigurationValidator(BaseConfigValidator[Configuration]):
    def __init__(self):
        super().__init__()
        self._setup_rules()
        
    def _setup_rules(self) -> None:
        # Basic configuration rules
        self.register_rule(
            "name",
            RequiredFieldRule(
                name="required_name",
                message="Configuration name is required",
                severity=ValidationSeverity.ERROR
            )
        )
        
        self.register_rule(
            "version",
            RequiredFieldRule(
                name="required_version",
                message="Configuration version is required",
                severity=ValidationSeverity.ERROR
            )
        )
        
        # Provider rules
        self.register_rule(
            "providers",
            TypeRule(
                name="providers_type",
                message="Providers must be a dictionary",
                severity=ValidationSeverity.ERROR,
                expected_type=dict
            )
        )
        
    async def validate_provider(
        self,
        provider: Dict[str, Any]
    ) -> List[ValidationResult]:
        results = []
        
        # Validate provider type
        if "type" not in provider:
            results.append(
                ValidationResult(
                    path="provider.type",
                    message="Provider type is required",
                    severity=ValidationSeverity.ERROR
                )
            )
            
        # Validate provider config
        if "config" in provider:
            if not isinstance(provider["config"], dict):
                results.append(
                    ValidationResult(
                        path="provider.config",
                        message="Provider config must be a dictionary",
                        severity=ValidationSeverity.ERROR
                    )
                )
                
        return results
```

5. Implementar gerenciador de validação:

```python
class ValidationManager:
    def __init__(self):
        self._validators: Dict[str, ConfigValidator] = {}
        self._metrics = MetricsManager.get_instance()
        
    def register_validator(
        self,
        name: str,
        validator: ConfigValidator
    ) -> None:
        self._validators[name] = validator
        
    async def validate(
        self,
        config: Any,
        validator_name: str
    ) -> List[ValidationResult]:
        if validator_name not in self._validators:
            raise ValueError(f"Validator not found: {validator_name}")
            
        validator = self._validators[validator_name]
        results = await validator.validate(config)
        
        await self._record_validation(results)
        return results
        
    async def _record_validation(
        self,
        results: List[ValidationResult]
    ) -> None:
        for result in results:
            self._metrics.counter(
                "validation_result",
                1,
                severity=result.severity.value
            )
```

6. Migrar implementações existentes:
   - Atualizar `core/config/base.py`
   - Atualizar `core/config/loader.py`
   - Criar novos validadores conforme necessário

## Validação

```python
async def test_config_validation():
    # Setup
    manager = ValidationManager()
    validator = ConfigurationValidator()
    manager.register_validator("config", validator)
    
    # Test invalid configuration
    config = Configuration(name=None, version=None)
    results = await manager.validate(config, "config")
    assert len(results) == 2
    assert all(r.severity == ValidationSeverity.ERROR for r in results)
    
    # Test valid configuration
    config = Configuration(
        name="test",
        version="1.0.0",
        providers={
            "memory": {
                "type": "local",
                "config": {"path": "/tmp"}
            }
        }
    )
    results = await manager.validate(config, "config")
    assert len(results) == 0
    
    # Test provider validation
    config = Configuration(
        name="test",
        version="1.0.0",
        providers={
            "memory": {
                "config": {"path": "/tmp"}
            }
        }
    )
    results = await manager.validate(config, "config")
    assert len(results) == 1
    assert results[0].path == "provider.type"
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_validation_system():
    # Restore legacy implementations
    shutil.copy("core/config/base_legacy.py", "core/config/base.py")
    shutil.copy("core/config/loader_legacy.py", "core/config/loader.py")
    
    # Cleanup new implementations
    os.remove("core/validation/validator.py")
    os.remove("core/validation/manager.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de validação
   - Interface consistente
   - Regras centralizadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falsos positivos/negativos
   - Mensagens de erro claras

3. **Observabilidade**:
   - Métricas de validação
   - Rastreamento de erros
   - Logs estruturados

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface ConfigValidator
- [ ] Implementação do BaseConfigValidator
- [ ] Implementação das regras de validação
- [ ] Implementação do ConfigurationValidator
- [ ] Implementação do ValidationManager
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
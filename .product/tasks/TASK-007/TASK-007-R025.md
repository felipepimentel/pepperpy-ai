# Consolida√ß√£o do Sistema de Dependency Injection

**Task ID**: TASK-007
**Requirement**: R025
**Status**: üìã To Do
**Created**: 2024-02-22
**Updated**: 2024-02-22

## Description

Implementar um sistema de inje√ß√£o de depend√™ncias robusto e flex√≠vel que suporte containers, providers din√¢micos, scopes e decorators. O sistema deve facilitar o gerenciamento de depend√™ncias, melhorar a testabilidade e reduzir o acoplamento entre componentes.

## Dependencies

- R019 (Padroniza√ß√£o de Lifecycle Management)
- R020 (Unifica√ß√£o do Sistema de Configura√ß√£o)
- R023 (Aprimoramento do Sistema de Plugins)

## Current State

```python
# Inje√ß√£o de depend√™ncias manual:
- core/client.py: instancia√ß√£o direta
- core/factory.py: cria√ß√£o manual
# Sem container de DI
# Falta de lifecycle management
# Acoplamento forte entre componentes
# Dificuldade em testes unit√°rios
```

## Implementation Plan

1. Criar estrutura base do sistema de DI:
```
di/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ base.py
‚îú‚îÄ‚îÄ types.py
‚îú‚îÄ‚îÄ errors.py
‚îú‚îÄ‚îÄ container/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ manager.py
‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ factory.py
‚îú‚îÄ‚îÄ scopes/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ lifecycle.py
‚îî‚îÄ‚îÄ decorators/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ base.py
    ‚îî‚îÄ‚îÄ inject.py
```

2. Implementar container de DI:
```python
from typing import Dict, Type, TypeVar, Optional, Any
from abc import ABC, abstractmethod

T = TypeVar('T')

class Container:
    def __init__(self):
        self._bindings: Dict[Type, Any] = {}
        self._instances: Dict[Type, Any] = {}
        
    def bind(self, interface: Type[T], implementation: Type[T]):
        self._bindings[interface] = implementation
        
    def resolve(self, interface: Type[T]) -> Optional[T]:
        if interface in self._instances:
            return self._instances[interface]
            
        if interface in self._bindings:
            instance = self._bindings[interface]()
            self._instances[interface] = instance
            return instance
            
        return None
```

3. Implementar providers din√¢micos:
```python
class Provider(ABC):
    @abstractmethod
    def get(self) -> Any:
        pass

class ServiceProvider(Provider):
    def __init__(self, container: Container):
        self.container = container
        
    def get(self) -> Any:
        return self.container.resolve(self.service_type)

class FactoryProvider(Provider):
    def __init__(self, factory: Callable[[], Any]):
        self.factory = factory
        
    def get(self) -> Any:
        return self.factory()
```

4. Implementar sistema de scopes:
```python
from enum import Enum
from contextlib import contextmanager

class Scope(Enum):
    SINGLETON = "singleton"
    TRANSIENT = "transient"
    SCOPED = "scoped"

class ScopeManager:
    def __init__(self):
        self._scopes: Dict[str, Dict[Type, Any]] = {}
        
    @contextmanager
    def scope(self, name: str):
        self._scopes[name] = {}
        try:
            yield
        finally:
            del self._scopes[name]
            
    def get(self, scope: str, type: Type[T]) -> Optional[T]:
        return self._scopes.get(scope, {}).get(type)
```

5. Implementar decorators:
```python
from functools import wraps
from typing import Callable

def inject(*dependencies: Type):
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            container = Container()
            resolved = [container.resolve(dep) for dep in dependencies]
            return func(self, *resolved, *args, **kwargs)
        return wrapper
    return decorator

def singleton(cls: Type[T]) -> Type[T]:
    instance = None
    def get_instance(*args, **kwargs) -> T:
        nonlocal instance
        if instance is None:
            instance = cls(*args, **kwargs)
        return instance
    return get_instance
```

## Validation

```python
def test_di_system():
    # Verificar container
    from pepperpy.di.container import Container
    container = Container()
    container.bind(IService, ServiceImpl)
    service = container.resolve(IService)
    assert isinstance(service, ServiceImpl)
    
    # Verificar providers
    from pepperpy.di.providers import ServiceProvider
    provider = ServiceProvider(container)
    instance = provider.get()
    assert instance is not None
    
    # Verificar scopes
    from pepperpy.di.scopes import ScopeManager
    manager = ScopeManager()
    with manager.scope("request"):
        assert manager.get("request", IService) is None
        
    # Verificar decorators
    from pepperpy.di.decorators import inject, singleton
    
    @inject(IService)
    def test_function(service: IService):
        assert service is not None
        
    @singleton
    class SingletonService:
        pass
        
    assert SingletonService() is SingletonService()
```

## Rollback Plan

1. Backup do estado atual:
   - Mapear depend√™ncias atuais
   - Documentar padr√µes de instancia√ß√£o
   - Backup de configura√ß√µes

2. Procedimento de rollback:
   ```python
   def rollback():
       # Desativar container de DI
       disable_di_container()
       
       # Restaurar instancia√ß√£o direta
       restore_direct_instantiation()
       
       # Remover decorators
       remove_di_decorators()
   ```

3. Valida√ß√£o p√≥s-rollback:
   - Verificar instancia√ß√£o de componentes
   - Validar funcionamento do sistema
   - Confirmar testes unit√°rios

## Success Metrics

1. Funcionalidade:
   - 100% dos componentes usando DI
   - Todos os padr√µes de inje√ß√£o suportados
   - Sistema de scopes funcionando
   - Decorators implementados

2. Performance:
   - Overhead de resolu√ß√£o < 1ms
   - Uso de mem√≥ria controlado
   - Zero memory leaks
   - Startup time n√£o afetado

3. Qualidade:
   - 100% de cobertura de testes
   - Zero acoplamentos diretos
   - Documenta√ß√£o completa
   - Exemplos de uso

## Progress Updates

- [x] 2024-02-22: Requirement criado e documentado
- [ ] Implementa√ß√£o da estrutura base
- [ ] Container de DI
- [ ] Providers din√¢micos
- [ ] Sistema de scopes
- [ ] Decorators
- [ ] Testes e valida√ß√£o
- [ ] Documenta√ß√£o final 
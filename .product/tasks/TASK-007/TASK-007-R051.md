# R051: Padronização de Utilitários Core

## Descrição

Padronizar funções utilitárias para eliminar duplicações e garantir consistência em todo o framework. O sistema atual apresenta funções utilitárias duplicadas em diferentes módulos, com implementações ligeiramente diferentes, dificultando a manutenção e aumentando a probabilidade de bugs.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Unificação do Tratamento de Erros

## Estado Atual

Atualmente, as funções utilitárias estão duplicadas em diferentes módulos:

1. Em `core/utils.py` e `cli/utils.py` (duplicação de validação de path):
```python
# core/utils.py
def validate_path(path: Union[str, Path], must_exist: bool = True) -> Path:
    try:
        path_obj = Path(path).resolve()
        if must_exist and not path_obj.exists():
            raise ConfigurationError(f"Path does not exist: {path}")
        return path_obj
    except Exception as e:
        raise ConfigurationError(f"Invalid path: {path}") from e

# cli/utils.py
def validate_path(path: Union[str, Path], must_exist: bool = True) -> Path:
    try:
        path_obj = Path(path).resolve()
        if must_exist and not path_obj.exists():
            raise ValidationError("path", str(path), "Path does not exist")
        return path_obj
    except Exception as e:
        raise ValidationError("path", str(path), str(e))
```

2. Em `core/utils.py` e `core/config/loader.py` (duplicação de importação dinâmica):
```python
# core/utils.py
def import_optional(module_name: str) -> Optional[Any]:
    try:
        return importlib.import_module(module_name)
    except ImportError:
        return None

# core/config/loader.py
def load_class(module_path: str, class_name: str, base_class: Type[T]) -> Type[T]:
    try:
        module = importlib.import_module(module_path)
        loaded_class = getattr(module, class_name)
        if not issubclass(loaded_class, base_class):
            raise ConfigurationError(
                f"Class {class_name} does not implement {base_class.__name__}"
            )
        return loaded_class
    except (ImportError, AttributeError) as e:
        raise ConfigurationError(
            f"Failed to load class {class_name} from {module_path}: {str(e)}"
        )
```

## Plano de Implementação

1. Criar um módulo unificado para utilitários core:

```python
from typing import Any, Dict, Optional, Type, TypeVar, Union
from pathlib import Path
import importlib
import inspect
import time
import asyncio
from functools import wraps
from contextlib import contextmanager

T = TypeVar("T")

class CoreUtils:
    """Utilitários core centralizados."""
    
    @staticmethod
    def validate_path(
        path: Union[str, Path],
        must_exist: bool = True,
        error_class: Type[Exception] = ValidationError
    ) -> Path:
        """Validar um caminho do sistema de arquivos.
        
        Args:
            path: Caminho a ser validado
            must_exist: Se o caminho deve existir
            error_class: Classe de erro a ser usada
            
        Returns:
            Path validado
            
        Raises:
            error_class: Se a validação falhar
        """
        try:
            path_obj = Path(path).resolve()
            if must_exist and not path_obj.exists():
                raise error_class(
                    "Path does not exist",
                    details={"path": str(path)}
                )
            return path_obj
        except Exception as e:
            raise error_class(
                "Invalid path",
                details={"path": str(path), "error": str(e)}
            )
    
    @staticmethod
    def import_module(
        module_name: str,
        optional: bool = False
    ) -> Optional[Any]:
        """Importar um módulo.
        
        Args:
            module_name: Nome do módulo
            optional: Se o módulo é opcional
            
        Returns:
            Módulo importado ou None se opcional
            
        Raises:
            ImportError: Se não opcional e falhar
        """
        try:
            return importlib.import_module(module_name)
        except ImportError as e:
            if optional:
                return None
            raise ImportError(f"Failed to import {module_name}: {e}")
    
    @staticmethod
    def load_class(
        module_path: str,
        class_name: str,
        base_class: Optional[Type[T]] = None
    ) -> Type[T]:
        """Carregar uma classe dinamicamente.
        
        Args:
            module_path: Caminho do módulo
            class_name: Nome da classe
            base_class: Classe base esperada
            
        Returns:
            Classe carregada
            
        Raises:
            ImportError: Se falhar ao importar
            AttributeError: Se a classe não existir
            TypeError: Se não implementar a classe base
        """
        module = CoreUtils.import_module(module_path)
        loaded_class = getattr(module, class_name)
        
        if base_class and not issubclass(loaded_class, base_class):
            raise TypeError(
                f"Class {class_name} does not implement {base_class.__name__}"
            )
            
        return loaded_class
```

2. Implementar utilitários de tempo e medição:

```python
class TimeUtils:
    """Utilitários de tempo e medição."""
    
    @staticmethod
    @contextmanager
    def timer(name: Optional[str] = None) -> Generator[Callable[[], float], None, None]:
        """Medir tempo de execução.
        
        Args:
            name: Nome opcional da operação
            
        Yields:
            Função para obter tempo decorrido
        """
        start = time.perf_counter()
        yield lambda: time.perf_counter() - start
        
        if name:
            elapsed = time.perf_counter() - start
            logger.debug(f"{name} took {elapsed:.2f} seconds")
    
    @staticmethod
    def retry(
        max_attempts: int = 3,
        delay: float = 1.0,
        backoff: float = 2.0,
        exceptions: tuple[Type[Exception], ...] = (Exception,)
    ) -> Callable:
        """Decorador para retry de operações.
        
        Args:
            max_attempts: Número máximo de tentativas
            delay: Delay inicial entre tentativas
            backoff: Multiplicador de backoff
            exceptions: Exceções a serem capturadas
            
        Returns:
            Decorador configurado
        """
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            async def wrapper(*args: Any, **kwargs: Any) -> Any:
                last_exception = None
                current_delay = delay
                
                for attempt in range(max_attempts):
                    try:
                        if inspect.iscoroutinefunction(func):
                            return await func(*args, **kwargs)
                        return func(*args, **kwargs)
                    except exceptions as e:
                        last_exception = e
                        if attempt < max_attempts - 1:
                            await asyncio.sleep(current_delay)
                            current_delay *= backoff
                            
                if last_exception:
                    raise last_exception
                    
            return wrapper
        return decorator
```

3. Implementar utilitários de validação:

```python
class ValidationUtils:
    """Utilitários de validação."""
    
    @staticmethod
    def validate_type(
        value: Any,
        expected_type: Union[Type[Any], tuple[Type[Any], ...]],
        error_class: Type[Exception] = TypeError
    ) -> None:
        """Validar tipo de um valor.
        
        Args:
            value: Valor a ser validado
            expected_type: Tipo(s) esperado(s)
            error_class: Classe de erro a ser usada
            
        Raises:
            error_class: Se a validação falhar
        """
        if not isinstance(value, expected_type):
            raise error_class(
                f"Expected type {expected_type}, got {type(value)}",
                details={"value": str(value), "expected_type": str(expected_type)}
            )
    
    @staticmethod
    def validate_subclass(
        cls: Type[Any],
        base_class: Type[Any],
        error_class: Type[Exception] = TypeError
    ) -> None:
        """Validar se uma classe herda de outra.
        
        Args:
            cls: Classe a ser validada
            base_class: Classe base esperada
            error_class: Classe de erro a ser usada
            
        Raises:
            error_class: Se a validação falhar
        """
        if not issubclass(cls, base_class):
            raise error_class(
                f"Class {cls.__name__} does not implement {base_class.__name__}",
                details={"class": cls.__name__, "base_class": base_class.__name__}
            )
```

4. Implementar utilitários de ambiente:

```python
class EnvironmentUtils:
    """Utilitários de ambiente."""
    
    @staticmethod
    def is_running_in_test() -> bool:
        """Verificar se está rodando em teste."""
        return "pytest" in sys.modules
    
    @staticmethod
    def is_running_in_notebook() -> bool:
        """Verificar se está rodando em notebook."""
        try:
            shell = sys.modules.get("IPython", None)
            return shell is not None and shell.get_ipython() is not None
        except Exception:
            return False
    
    @staticmethod
    def load_env_config(prefix: str = "PEPPERPY_") -> Dict[str, str]:
        """Carregar configuração do ambiente.
        
        Args:
            prefix: Prefixo das variáveis
            
        Returns:
            Configuração carregada
        """
        return {
            key[len(prefix):].lower(): value
            for key, value in os.environ.items()
            if key.startswith(prefix)
        }
```

5. Migrar implementações existentes:
   - Atualizar `core/utils.py`
   - Remover duplicações em `cli/utils.py`
   - Atualizar referências em outros módulos

## Validação

```python
async def test_core_utils():
    # Test path validation
    path = CoreUtils.validate_path("test.txt", must_exist=False)
    assert isinstance(path, Path)
    
    # Test class loading
    class Base: pass
    class Child(Base): pass
    
    loaded = CoreUtils.load_class("module", "Child", Base)
    assert issubclass(loaded, Base)
    
    # Test retry
    @TimeUtils.retry(max_attempts=3)
    async def flaky_operation():
        raise ValueError("Failed")
        
    try:
        await flaky_operation()
        assert False, "Should raise ValueError"
    except ValueError:
        pass
        
    # Test validation
    ValidationUtils.validate_type("test", str)
    ValidationUtils.validate_subclass(Child, Base)
    
    # Test environment
    assert isinstance(EnvironmentUtils.is_running_in_test(), bool)
    config = EnvironmentUtils.load_env_config()
    assert isinstance(config, dict)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_core_utils():
    # Restore legacy implementations
    shutil.copy("core/utils_legacy.py", "core/utils.py")
    shutil.copy("cli/utils_legacy.py", "cli/utils.py")
    
    # Cleanup new implementations
    os.remove("core/utils")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código utilitário
   - 100% dos módulos usando utilitários core
   - Cobertura completa de funcionalidades

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero bugs relacionados a utilitários
   - Documentação completa

3. **Desempenho**:
   - Overhead < 0.1ms por operação
   - Uso de memória < 5MB
   - Zero impacto em performance

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do CoreUtils
- [ ] Implementação do TimeUtils
- [ ] Implementação do ValidationUtils
- [ ] Implementação do EnvironmentUtils
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
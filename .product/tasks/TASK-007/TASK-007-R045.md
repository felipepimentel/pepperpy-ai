# R045: Unificação do Sistema de Gerenciamento de Recursos

## Descrição

Unificar o sistema de gerenciamento de recursos para garantir consistência no ciclo de vida, limpeza e monitoramento de recursos em todo o framework. O sistema atual apresenta implementações dispersas e inconsistentes de gerenciamento de recursos em diferentes módulos.

## Dependências

- R019: Sistema de Monitoramento de Recursos
- R024: Consolidação do Sistema de Observabilidade
- R026: Sistema de Resource Management

## Estado Atual

Atualmente, o gerenciamento de recursos está disperso em vários módulos com implementações inconsistentes:

1. Em `core/resources.py`:
```python
class Resource(ABC):
    async def initialize(self) -> None:
        if self._initialized:
            return
        try:
            await self._initialize()
            self._initialized = True
            if self.auto_cleanup and self.cleanup_interval:
                self._cleanup_task = asyncio.create_task(self._run_cleanup())
        except Exception as e:
            raise LifecycleError(f"Failed to initialize resource: {e}")
```

2. Em `memory/providers/local.py`:
```python
class LocalProvider(MemoryProvider):
    async def keys(self, pattern: Optional[str] = None, **kwargs: Any) -> List[str]:
        try:
            async with self._lock:
                if pattern:
                    return [key for key in self.entries 
                           if key.startswith(pattern) and 
                           not (self.entries[key].expires_at and 
                                self.entries[key].expires_at <= datetime.now())]
```

3. Em `core/client.py`:
```python
class PepperpyClient(PepperpyClientProtocol, Lifecycle):
    async def remove_agent(self, agent_id: UUID) -> None:
        try:
            if hasattr(agent, "cleanup"):
                await agent.cleanup()
            del self._agents[agent_id]
            self._updated_at = time.time()
```

## Plano de Implementação

1. Criar uma interface unificada para gerenciamento de recursos:

```python
from abc import ABC, abstractmethod
from typing import Any, Optional
from datetime import timedelta

class ResourceManager(ABC):
    @abstractmethod
    async def acquire(self, resource_id: str, **kwargs: Any) -> Any:
        """Acquire a resource."""
        pass
        
    @abstractmethod
    async def release(self, resource_id: str) -> None:
        """Release a resource."""
        pass
        
    @abstractmethod
    async def cleanup(self, pattern: Optional[str] = None) -> None:
        """Cleanup resources matching pattern."""
        pass
        
    @abstractmethod
    async def monitor(self) -> Dict[str, Any]:
        """Get resource usage metrics."""
        pass
```

2. Implementar um gerenciador de recursos padrão:

```python
class DefaultResourceManager(ResourceManager):
    def __init__(self, cleanup_interval: timedelta = timedelta(minutes=5)):
        self._resources: Dict[str, Any] = {}
        self._locks: Dict[str, asyncio.Lock] = {}
        self._metrics: Dict[str, Counter] = {}
        self._cleanup_interval = cleanup_interval
        self._cleanup_task: Optional[asyncio.Task] = None
        
    async def start(self) -> None:
        self._cleanup_task = asyncio.create_task(self._run_cleanup())
        
    async def stop(self) -> None:
        if self._cleanup_task:
            self._cleanup_task.cancel()
```

3. Criar decoradores para gerenciamento automático de recursos:

```python
def managed_resource(resource_type: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            resource_id = f"{resource_type}:{uuid4()}"
            try:
                resource = await self.resource_manager.acquire(resource_id)
                result = await func(self, resource, *args, **kwargs)
                return result
            finally:
                await self.resource_manager.release(resource_id)
        return wrapper
    return decorator
```

4. Implementar monitoramento de recursos:

```python
class ResourceMetrics:
    def __init__(self):
        self.active_resources = Counter("pepperpy_active_resources", 
                                      "Number of active resources")
        self.resource_errors = Counter("pepperpy_resource_errors",
                                     "Number of resource errors")
        self.cleanup_runs = Counter("pepperpy_cleanup_runs",
                                  "Number of cleanup runs")
```

5. Migrar implementações existentes para usar o novo sistema:
   - Atualizar `core/resources.py`
   - Refatorar `memory/providers/local.py`
   - Modificar `core/client.py`

## Validação

```python
async def test_resource_management():
    # Setup
    manager = DefaultResourceManager()
    await manager.start()
    
    # Test resource lifecycle
    resource_id = "test:1"
    resource = await manager.acquire(resource_id)
    assert resource_id in manager._resources
    
    # Test cleanup
    await manager.cleanup()
    assert resource_id not in manager._resources
    
    # Test metrics
    metrics = await manager.monitor()
    assert "active_resources" in metrics
    assert "resource_errors" in metrics
    
    # Cleanup
    await manager.stop()
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_resource_management():
    # Restore legacy implementations
    shutil.copy("core/resources_legacy.py", "core/resources.py")
    shutil.copy("memory/providers/local_legacy.py", "memory/providers/local.py")
    
    # Cleanup new implementations
    os.remove("core/resource_manager.py")
    os.remove("core/resource_metrics.py")
```

## Métricas de Sucesso

1. **Redução de Código**:
   - Redução de 70% no código duplicado de gerenciamento de recursos
   - Eliminação de pelo menos 5 implementações redundantes

2. **Desempenho**:
   - Tempo médio de aquisição de recursos < 50ms
   - Tempo médio de liberação de recursos < 30ms
   - Taxa de erro na gestão de recursos < 0.1%

3. **Manutenibilidade**:
   - Cobertura de testes > 95%
   - Complexidade ciclomática < 10 por função
   - Zero alertas de linting em código novo

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface ResourceManager
- [ ] Implementação do DefaultResourceManager
- [ ] Implementação dos decoradores de recursos
- [ ] Implementação do sistema de métricas
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R050: Consolidação do Sistema de Configuração

## Descrição

Consolidar o sistema de configuração para eliminar duplicações e garantir consistência na gestão de configurações em todo o framework. O sistema atual apresenta classes e métodos duplicados em diferentes módulos, dificultando a manutenção e aumentando a probabilidade de inconsistências.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R047: Consolidação do Sistema de Validação

## Estado Atual

Atualmente, o sistema de configuração está duplicado em diferentes módulos:

1. Em `core/config.py`:
```python
class Configuration:
    def _get_default_config(self) -> Dict[str, Dict[str, Any]]:
        return {
            "llm": {
                "default": {
                    "type": "openai",
                    "config": {"model": "gpt-3.5-turbo", "temperature": 0.7},
                }
            },
            "content": {
                "default": {
                    "type": "rss",
                    "config": {
                        "sources": ["https://news.google.com/rss"],
                        "language": "pt-BR",
                    },
                }
            }
        }
```

2. Em `core/config/base.py`:
```python
class Configuration:
    def get_provider(self, capability: str, name: str = "default") -> Dict[str, Any]:
        try:
            module_path = f"pepperpy.{capability}.providers.{provider_type}"
            module = importlib.import_module(module_path)
            provider_class = getattr(module, f"{provider_type.title()}Provider")
            if not issubclass(provider_class, base_class):
                raise ConfigurationError(
                    f"Provider class {provider_class.__name__} does not implement {base_class.__name__}"
                )
            return provider_class(**provider_config)
        except (ImportError, AttributeError) as e:
            raise ConfigurationError(
                f"Failed to load provider {capability}.{name}: {str(e)}"
            )
```

## Plano de Implementação

1. Criar uma interface unificada para configuração:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Type, TypeVar
from pathlib import Path
import yaml
from pydantic import BaseModel

T = TypeVar("T", bound=BaseModel)

class ConfigurationProvider(ABC):
    @abstractmethod
    def load(self, path: Optional[Path] = None) -> Dict[str, Any]:
        """Load configuration from source."""
        pass
    
    @abstractmethod
    def save(self, config: Dict[str, Any], path: Optional[Path] = None) -> None:
        """Save configuration to source."""
        pass
    
    @abstractmethod
    def get_defaults(self) -> Dict[str, Any]:
        """Get default configuration."""
        pass

class Configuration:
    def __init__(
        self,
        provider: ConfigurationProvider,
        schema: Optional[Type[T]] = None,
        path: Optional[Path] = None
    ):
        self._provider = provider
        self._schema = schema
        self._path = path
        self._config: Optional[Dict[str, Any]] = None
        self._metrics = MetricsManager.get_instance()
        
    async def load(self) -> Dict[str, Any]:
        """Load configuration."""
        try:
            # Load from provider
            config = self._provider.load(self._path)
            
            # Merge with defaults
            defaults = self._provider.get_defaults()
            config = self._merge_configs(defaults, config)
            
            # Validate schema
            if self._schema:
                config = self._schema(**config).dict()
                
            self._config = config
            return config
            
        except Exception as e:
            raise ConfigurationError(
                f"Failed to load configuration: {e}",
                details={"path": str(self._path) if self._path else None}
            )
            
    def _merge_configs(
        self,
        base: Dict[str, Any],
        override: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Merge configurations recursively."""
        result = base.copy()
        for key, value in override.items():
            if (
                key in result and
                isinstance(result[key], dict) and
                isinstance(value, dict)
            ):
                result[key] = self._merge_configs(result[key], value)
            else:
                result[key] = value
        return result
```

2. Implementar provedores de configuração:

```python
class FileConfigurationProvider(ConfigurationProvider):
    def __init__(self, format: str = "yaml"):
        self._format = format
        
    def load(self, path: Optional[Path] = None) -> Dict[str, Any]:
        if not path or not path.exists():
            return {}
            
        try:
            content = path.read_text()
            if self._format == "yaml":
                return yaml.safe_load(content)
            elif self._format == "json":
                return json.loads(content)
            else:
                raise ValueError(f"Unsupported format: {self._format}")
        except Exception as e:
            raise ConfigurationError(f"Failed to load config file: {e}")
            
    def save(self, config: Dict[str, Any], path: Optional[Path] = None) -> None:
        if not path:
            raise ConfigurationError("No path specified for saving")
            
        try:
            content = None
            if self._format == "yaml":
                content = yaml.safe_dump(config)
            elif self._format == "json":
                content = json.dumps(config, indent=2)
                
            path.write_text(content)
        except Exception as e:
            raise ConfigurationError(f"Failed to save config file: {e}")
            
    def get_defaults(self) -> Dict[str, Any]:
        return {
            "llm": {
                "default": {
                    "type": "openai",
                    "config": {"model": "gpt-3.5-turbo", "temperature": 0.7}
                }
            },
            "content": {
                "default": {
                    "type": "rss",
                    "config": {
                        "sources": ["https://news.google.com/rss"],
                        "language": "pt-BR"
                    }
                }
            }
        }
```

3. Implementar esquemas de configuração:

```python
from pydantic import BaseModel, Field
from typing import Dict, List, Optional

class ProviderConfig(BaseModel):
    type: str = Field(..., description="Provider type")
    config: Dict[str, Any] = Field(default_factory=dict, description="Provider config")

class CapabilityConfig(BaseModel):
    default: ProviderConfig = Field(..., description="Default provider")
    providers: Dict[str, ProviderConfig] = Field(
        default_factory=dict,
        description="Additional providers"
    )

class PepperpyConfig(BaseModel):
    llm: CapabilityConfig
    content: CapabilityConfig
    synthesis: Optional[CapabilityConfig] = None
    memory: Optional[CapabilityConfig] = None
```

4. Implementar monitoramento de configuração:

```python
class ConfigurationMetrics:
    def __init__(self):
        self.config_loads = Counter(
            "pepperpy_config_loads",
            "Number of configuration loads"
        )
        self.config_load_errors = Counter(
            "pepperpy_config_load_errors",
            "Number of configuration load errors"
        )
        self.config_saves = Counter(
            "pepperpy_config_saves",
            "Number of configuration saves"
        )
        self.config_validation_errors = Counter(
            "pepperpy_config_validation_errors",
            "Number of configuration validation errors"
        )
```

5. Migrar implementações existentes:
   - Remover `core/config.py`
   - Atualizar `core/config/base.py`
   - Atualizar referências em outros módulos

## Validação

```python
async def test_configuration_system():
    # Setup
    provider = FileConfigurationProvider()
    config = Configuration(
        provider=provider,
        schema=PepperpyConfig,
        path=Path("config.yaml")
    )
    
    # Test loading
    data = await config.load()
    assert "llm" in data
    assert "content" in data
    
    # Test schema validation
    config_model = PepperpyConfig(**data)
    assert config_model.llm.default.type == "openai"
    
    # Test merging
    custom_config = {
        "llm": {
            "default": {
                "config": {"temperature": 0.9}
            }
        }
    }
    merged = config._merge_configs(provider.get_defaults(), custom_config)
    assert merged["llm"]["default"]["config"]["temperature"] == 0.9
    assert merged["llm"]["default"]["config"]["model"] == "gpt-3.5-turbo"
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_configuration_system():
    # Restore legacy implementations
    shutil.copy("core/config_legacy.py", "core/config.py")
    shutil.copy("core/config/base_legacy.py", "core/config/base.py")
    
    # Cleanup new implementations
    os.remove("core/config/provider.py")
    os.remove("core/config/schema.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de configuração
   - 100% dos módulos usando o novo sistema
   - Formato consistente de configuração

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de validação em produção
   - Documentação completa do schema

3. **Desempenho**:
   - Tempo de carregamento < 50ms
   - Uso de memória < 10MB
   - Cache hit rate > 95%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface ConfigurationProvider
- [ ] Implementação do FileConfigurationProvider
- [ ] Implementação dos esquemas de configuração
- [ ] Implementação do sistema de métricas
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
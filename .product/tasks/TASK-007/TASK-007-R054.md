# R054: Padronização do Sistema de Análise de Segurança

## Descrição

Unificar e padronizar o sistema de análise de segurança, consolidando as funcionalidades do módulo security/scanner.py em uma arquitetura mais flexível e reutilizável. O sistema atual tem funcionalidades de análise de segurança limitadas a um único módulo, com pouca flexibilidade para extensão e reutilização em diferentes contextos.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R052: Unificação do Sistema de Análise de Código

## Estado Atual

Atualmente, a análise de segurança está concentrada em um único módulo com implementação rígida:

1. Em `security/scanner.py`:
```python
class CodeVisitor(ast.NodeVisitor):
    def __init__(self, config: ScannerConfig) -> None:
        self.config = config
        self.issues: List[str] = []
        self.warnings: List[str] = []
        self.complexity = 0

    def visit_Call(self, node: ast.Call) -> None:
        if isinstance(node.func, ast.Name):
            if node.func.id in self.config.banned_functions:
                self.issues.append(f"Use of banned function: {node.func.id}")

    def visit_Import(self, node: ast.Import) -> None:
        for name in node.names:
            if name.name in self.config.banned_modules:
                self.issues.append(f"Import of banned module: {name.name}")
```

## Plano de Implementação

1. Criar uma interface unificada para análise de segurança:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Set
from dataclasses import dataclass
from enum import Enum

class SecurityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class SecurityIssue:
    level: SecurityLevel
    code: str
    message: str
    location: Optional[Dict[str, Any]] = None
    context: Optional[Dict[str, Any]] = None
    remediation: Optional[str] = None

class SecurityAnalyzer(ABC):
    @abstractmethod
    def analyze_code(self, code: str) -> List[SecurityIssue]:
        """Analyze code for security issues."""
        pass
    
    @abstractmethod
    def analyze_ast(self, node: ast.AST) -> List[SecurityIssue]:
        """Analyze AST node for security issues."""
        pass
    
    @abstractmethod
    def analyze_file(self, path: str) -> List[SecurityIssue]:
        """Analyze file for security issues."""
        pass
```

2. Implementar analisadores específicos:

```python
class BannedFunctionAnalyzer(SecurityAnalyzer):
    def __init__(self, banned_functions: Set[str]):
        self.banned_functions = banned_functions
        
    def analyze_ast(self, node: ast.AST) -> List[SecurityIssue]:
        visitor = BannedFunctionVisitor(self.banned_functions)
        visitor.visit(node)
        return visitor.issues

class ImportAnalyzer(SecurityAnalyzer):
    def __init__(self, banned_modules: Set[str]):
        self.banned_modules = banned_modules
        
    def analyze_ast(self, node: ast.AST) -> List[SecurityIssue]:
        visitor = ImportVisitor(self.banned_modules)
        visitor.visit(node)
        return visitor.issues

class ShellInjectionAnalyzer(SecurityAnalyzer):
    def analyze_ast(self, node: ast.AST) -> List[SecurityIssue]:
        visitor = ShellInjectionVisitor()
        visitor.visit(node)
        return visitor.issues
```

3. Implementar sistema de regras de segurança:

```python
@dataclass
class SecurityRule:
    code: str
    description: str
    level: SecurityLevel
    analyzer: Type[SecurityAnalyzer]
    config: Optional[Dict[str, Any]] = None

class SecurityRuleEngine:
    def __init__(self):
        self._rules: Dict[str, SecurityRule] = {}
        self._metrics = MetricsManager.get_instance()
        
    def register_rule(self, rule: SecurityRule) -> None:
        self._rules[rule.code] = rule
        
    async def analyze(
        self,
        code: str,
        rules: Optional[List[str]] = None
    ) -> List[SecurityIssue]:
        issues = []
        selected_rules = (
            [self._rules[code] for code in rules]
            if rules
            else self._rules.values()
        )
        
        for rule in selected_rules:
            try:
                analyzer = rule.analyzer(
                    **(rule.config or {})
                )
                rule_issues = analyzer.analyze_code(code)
                issues.extend(rule_issues)
                
                self._metrics.counter(
                    f"security_issues_{rule.code}",
                    len(rule_issues)
                )
            except Exception as e:
                logger.error(
                    f"Rule {rule.code} failed: {e}",
                    extra={"rule": rule.code}
                )
                
        return issues
```

4. Implementar sistema de relatórios:

```python
class SecurityReport:
    def __init__(self):
        self.issues: List[SecurityIssue] = []
        self.metrics: Dict[str, int] = {}
        self.summary: Dict[SecurityLevel, int] = {}
        
    def add_issue(self, issue: SecurityIssue) -> None:
        self.issues.append(issue)
        self.summary[issue.level] = self.summary.get(issue.level, 0) + 1
        
    def to_dict(self) -> Dict[str, Any]:
        return {
            "issues": [asdict(issue) for issue in self.issues],
            "metrics": self.metrics,
            "summary": {level.value: count 
                       for level, count in self.summary.items()}
        }
        
    def to_markdown(self) -> str:
        lines = ["# Security Analysis Report\n"]
        
        # Add summary
        lines.append("## Summary\n")
        for level in SecurityLevel:
            count = self.summary.get(level, 0)
            lines.append(f"- {level.value}: {count}")
            
        # Add issues
        lines.append("\n## Issues\n")
        for issue in self.issues:
            lines.append(f"### {issue.code}: {issue.message}")
            if issue.location:
                lines.append(f"Location: {issue.location}")
            if issue.remediation:
                lines.append(f"Remediation: {issue.remediation}")
                
        return "\n".join(lines)
```

5. Migrar implementações existentes:
   - Atualizar `security/scanner.py`
   - Criar regras de segurança padrão
   - Implementar novos analisadores conforme necessário

## Validação

```python
async def test_security_analysis():
    # Setup
    engine = SecurityRuleEngine()
    
    # Register rules
    engine.register_rule(SecurityRule(
        code="SEC001",
        description="Banned function usage",
        level=SecurityLevel.HIGH,
        analyzer=BannedFunctionAnalyzer,
        config={"banned_functions": {"eval", "exec"}}
    ))
    
    # Test analysis
    code = """
    def unsafe():
        eval("1 + 1")
        import subprocess
        subprocess.run(["ls"])
    """
    
    issues = await engine.analyze(code)
    assert len(issues) > 0
    assert any(i.code == "SEC001" for i in issues)
    
    # Test report
    report = SecurityReport()
    for issue in issues:
        report.add_issue(issue)
        
    assert report.summary[SecurityLevel.HIGH] > 0
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_security_analysis():
    # Restore legacy implementations
    shutil.copy("security/scanner_legacy.py", "security/scanner.py")
    
    # Cleanup new implementations
    os.remove("security/analyzers")
    os.remove("security/rules.py")
    os.remove("security/report.py")
```

## Métricas de Sucesso

1. **Cobertura**:
   - 100% do código analisado
   - Zero falsos positivos
   - Zero falsos negativos

2. **Qualidade**:
   - 100% de cobertura de testes
   - Documentação completa
   - Tempo médio de análise < 100ms

3. **Extensibilidade**:
   - Mínimo de 10 regras implementadas
   - Fácil adição de novas regras
   - Integração com CI/CD

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface SecurityAnalyzer
- [ ] Implementação dos analisadores específicos
- [ ] Implementação do sistema de regras
- [ ] Implementação do sistema de relatórios
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
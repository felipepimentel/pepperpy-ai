# R071: Unificação do Sistema de Validação de Schemas

## Descrição

Unificar e padronizar o sistema de validação de schemas em todo o framework, utilizando Pydantic como base para criar uma abordagem consistente para validação de dados, serialização e desserialização. O sistema atual possui diferentes implementações de validação espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R069: Padronização dos Schemas de Artefatos
- R070: Consolidação do Sistema de Compatibilidade

## Estado Atual

Atualmente, a validação de schemas está distribuída em vários módulos:

1. Em `hub/artifacts/agent_artifact.json`:
```json
{
  "type": "object",
  "properties": {
    "name": {"type": "string"},
    "description": {"type": "string"},
    "version": {"type": "string"},
    "capabilities": {
      "type": "array",
      "items": {"type": "string"}
    }
  },
  "required": ["name", "version", "capabilities"]
}
```

2. Em `memory/stores/redis.py`:
```python
def validate_entry(entry: Dict[str, Any]) -> bool:
    """Validate memory entry."""
    required = ["key", "value", "type"]
    return all(k in entry for k in required)
```

## Plano de Implementação

1. Criar sistema base de validação:

```python
from typing import Any, Dict, List, Optional, Type, TypeVar, Union
from pydantic import BaseModel, Field, validator
from datetime import datetime
from enum import Enum

T = TypeVar("T", bound=BaseModel)

class ValidationError(Exception):
    """Validation error."""
    
    def __init__(self, message: str, details: Dict[str, Any]):
        super().__init__(message)
        self.details = details

class BaseSchema(BaseModel):
    """Base schema for all models."""
    
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    version: str = Field(...)
    
    class Config:
        """Pydantic config."""
        
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
        
    @validator("updated_at")
    def update_timestamp(cls, v: datetime) -> datetime:
        """Update timestamp on save."""
        return datetime.now()
```

2. Implementar sistema de gerenciamento de schemas:

```python
class SchemaManager:
    """Manager for schema validation."""
    
    def __init__(self):
        self._schemas: Dict[str, Type[BaseSchema]] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_schema(
        self,
        name: str,
        schema: Type[BaseSchema]
    ) -> None:
        """Register a schema."""
        self._schemas[name] = schema
        
    async def validate(
        self,
        name: str,
        data: Dict[str, Any]
    ) -> BaseSchema:
        """Validate data against schema."""
        if name not in self._schemas:
            raise ValueError(f"No schema registered for: {name}")
            
        schema = self._schemas[name]
        
        try:
            start = time.perf_counter()
            result = schema(**data)
            duration = time.perf_counter() - start
            
            self._metrics.histogram(
                "validation_duration",
                duration,
                schema=name
            )
            
            self._metrics.counter(
                "validations",
                1,
                schema=name,
                success="true"
            )
            
            return result
            
        except Exception as e:
            self._metrics.counter(
                "validations",
                1,
                schema=name,
                success="false"
            )
            
            self._logger.error(
                "Validation failed",
                extra={
                    "schema": name,
                    "error": str(e)
                }
            )
            
            raise ValidationError(
                f"Failed to validate {name}",
                {"error": str(e)}
            )
```

3. Implementar schemas específicos:

```python
class AgentArtifact(BaseSchema):
    """Schema for agent artifacts."""
    
    name: str = Field(...)
    description: Optional[str] = None
    capabilities: List[str] = Field(default_factory=list)
    
    @validator("capabilities")
    def validate_capabilities(cls, v: List[str]) -> List[str]:
        """Validate capabilities."""
        if not v:
            raise ValueError("At least one capability required")
        return v

class MemoryEntry(BaseSchema):
    """Schema for memory entries."""
    
    key: str = Field(...)
    value: Any = Field(...)
    type: str = Field(...)
    scope: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @validator("key")
    def validate_key(cls, v: str) -> str:
        """Validate key."""
        if not v.strip():
            raise ValueError("Key cannot be empty")
        return v.strip()

class WorkflowArtifact(BaseSchema):
    """Schema for workflow artifacts."""
    
    name: str = Field(...)
    description: Optional[str] = None
    steps: List[Dict[str, Any]] = Field(...)
    inputs: Dict[str, Any] = Field(default_factory=dict)
    outputs: Dict[str, Any] = Field(default_factory=dict)
    
    @validator("steps")
    def validate_steps(cls, v: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Validate workflow steps."""
        if not v:
            raise ValueError("At least one step required")
        return v
```

4. Implementar sistema de monitoramento:

```python
class ValidationMonitor:
    """Monitor for validation operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_validation(
        self,
        schema: str,
        success: bool = True,
        duration: float = 0.0,
        **labels: str
    ) -> None:
        """Record validation operation."""
        self._metrics.counter(
            "validation_operations",
            1,
            schema=schema,
            success=str(success).lower(),
            **labels
        )
        
        if success:
            self._metrics.histogram(
                "validation_duration",
                duration,
                schema=schema,
                **labels
            )
```

5. Migrar implementações existentes:
   - Converter JSON schemas para Pydantic models
   - Atualizar validações em módulos existentes
   - Implementar sistema de descoberta de schemas

## Validação

```python
async def test_validation_system():
    # Setup
    manager = SchemaManager()
    monitor = ValidationMonitor()
    
    # Register schemas
    manager.register_schema("agent", AgentArtifact)
    manager.register_schema("memory", MemoryEntry)
    manager.register_schema("workflow", WorkflowArtifact)
    
    # Test agent validation
    agent_data = {
        "name": "test_agent",
        "capabilities": ["test"],
        "version": "1.0.0"
    }
    
    agent = await manager.validate("agent", agent_data)
    assert agent.name == "test_agent"
    
    # Test memory validation
    memory_data = {
        "key": "test",
        "value": "data",
        "type": "test",
        "version": "1.0.0"
    }
    
    memory = await manager.validate("memory", memory_data)
    assert memory.key == "test"
    
    # Test workflow validation
    workflow_data = {
        "name": "test_workflow",
        "steps": [{"action": "test"}],
        "version": "1.0.0"
    }
    
    workflow = await manager.validate("workflow", workflow_data)
    assert workflow.name == "test_workflow"
    
    # Test monitoring
    await monitor.record_validation("agent", True, 0.001)
    await monitor.record_validation("memory", True, 0.001)
    await monitor.record_validation("workflow", True, 0.001)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_validation_system():
    # Restore legacy implementations
    shutil.copy("hub/artifacts/agent_artifact_legacy.json", "hub/artifacts/agent_artifact.json")
    shutil.copy("hub/artifacts/workflow_artifact_legacy.json", "hub/artifacts/workflow_artifact.json")
    
    # Cleanup new implementations
    os.remove("core/validation/base.py")
    os.remove("core/validation/manager.py")
    os.remove("core/validation/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de validação
   - Interface consistente
   - Schemas unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de validação não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para validações
   - Uso eficiente de recursos
   - Cache de schemas compilados

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de validação
- [ ] Implementação do gerenciamento de schemas
- [ ] Implementação dos schemas específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
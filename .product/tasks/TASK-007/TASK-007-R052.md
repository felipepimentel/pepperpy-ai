# R052: Unificação do Sistema de Análise de Código

## Descrição

Unificar o sistema de análise de código para permitir reutilização em diferentes contextos e garantir consistência nas análises. O sistema atual apresenta funcionalidades de análise de código dispersas e específicas para cada contexto, dificultando a manutenção e limitando a reutilização.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R028: Unificação do Tratamento de Erros

## Estado Atual

Atualmente, a análise de código está dispersa em diferentes módulos:

1. Em `security/scanner.py`:
```python
class CodeVisitor(ast.NodeVisitor):
    def __init__(self, config: ScannerConfig) -> None:
        self.config = config
        self.issues: List[str] = []
        self.warnings: List[str] = []
        self.complexity = 0

    def visit_Call(self, node: ast.Call) -> None:
        if isinstance(node.func, ast.Name):
            if node.func.id in self.config.banned_functions:
                self.issues.append(f"Use of banned function: {node.func.id}")

    def visit_If(self, node: ast.If) -> None:
        self.complexity += 1
        self.generic_visit(node)
```

2. Em outros módulos, análises similares são reimplementadas para diferentes propósitos.

## Plano de Implementação

1. Criar uma interface unificada para análise de código:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Set, Type
from dataclasses import dataclass
from enum import Enum
import ast

class AnalysisLevel(Enum):
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"

@dataclass
class AnalysisResult:
    level: AnalysisLevel
    message: str
    node: Optional[ast.AST] = None
    line: Optional[int] = None
    column: Optional[int] = None
    details: Optional[Dict[str, Any]] = None

class CodeAnalyzer(ABC):
    @abstractmethod
    def analyze(self, code: str) -> List[AnalysisResult]:
        """Analisar código fonte."""
        pass
    
    @abstractmethod
    def analyze_file(self, path: str) -> List[AnalysisResult]:
        """Analisar arquivo."""
        pass
    
    @abstractmethod
    def analyze_module(self, module: str) -> List[AnalysisResult]:
        """Analisar módulo."""
        pass
```

2. Implementar analisadores específicos:

```python
class SecurityAnalyzer(CodeAnalyzer):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.banned_functions = config.get("banned_functions", {
            "eval", "exec", "compile", "__import__"
        })
        self.banned_modules = config.get("banned_modules", {
            "subprocess", "os.system"
        })
        
    def analyze(self, code: str) -> List[AnalysisResult]:
        try:
            tree = ast.parse(code)
            visitor = SecurityVisitor(self.banned_functions, self.banned_modules)
            visitor.visit(tree)
            return visitor.results
        except SyntaxError as e:
            return [AnalysisResult(
                level=AnalysisLevel.ERROR,
                message="Syntax error in code",
                line=e.lineno,
                column=e.offset,
                details={"error": str(e)}
            )]

class ComplexityAnalyzer(CodeAnalyzer):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.max_complexity = config.get("max_complexity", 10)
        
    def analyze(self, code: str) -> List[AnalysisResult]:
        tree = ast.parse(code)
        visitor = ComplexityVisitor(self.max_complexity)
        visitor.visit(tree)
        return visitor.results

class TypeAnalyzer(CodeAnalyzer):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.strict_types = config.get("strict_types", True)
        self.check_returns = config.get("check_returns", True)
        
    def analyze(self, code: str) -> List[AnalysisResult]:
        tree = ast.parse(code)
        visitor = TypeVisitor(self.strict_types, self.check_returns)
        visitor.visit(tree)
        return visitor.results
```

3. Implementar visitantes AST especializados:

```python
class BaseVisitor(ast.NodeVisitor):
    def __init__(self):
        self.results: List[AnalysisResult] = []
        
    def add_result(
        self,
        level: AnalysisLevel,
        message: str,
        node: ast.AST,
        details: Optional[Dict[str, Any]] = None
    ) -> None:
        self.results.append(AnalysisResult(
            level=level,
            message=message,
            node=node,
            line=getattr(node, "lineno", None),
            column=getattr(node, "col_offset", None),
            details=details
        ))

class SecurityVisitor(BaseVisitor):
    def __init__(self, banned_functions: Set[str], banned_modules: Set[str]):
        super().__init__()
        self.banned_functions = banned_functions
        self.banned_modules = banned_modules
        
    def visit_Call(self, node: ast.Call) -> None:
        if isinstance(node.func, ast.Name):
            if node.func.id in self.banned_functions:
                self.add_result(
                    level=AnalysisLevel.ERROR,
                    message=f"Use of banned function: {node.func.id}",
                    node=node
                )
        self.generic_visit(node)
        
    def visit_Import(self, node: ast.Import) -> None:
        for name in node.names:
            if name.name in self.banned_modules:
                self.add_result(
                    level=AnalysisLevel.ERROR,
                    message=f"Import of banned module: {name.name}",
                    node=node
                )
        self.generic_visit(node)

class ComplexityVisitor(BaseVisitor):
    def __init__(self, max_complexity: int):
        super().__init__()
        self.max_complexity = max_complexity
        self.current_complexity = 0
        
    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        old_complexity = self.current_complexity
        self.current_complexity = 1
        
        self.generic_visit(node)
        
        if self.current_complexity > self.max_complexity:
            self.add_result(
                level=AnalysisLevel.WARNING,
                message=f"Function {node.name} has complexity {self.current_complexity}",
                node=node,
                details={"complexity": self.current_complexity}
            )
            
        self.current_complexity = old_complexity
        
    def visit_If(self, node: ast.If) -> None:
        self.current_complexity += 1
        self.generic_visit(node)
```

4. Implementar agregador de análises:

```python
class CodeAnalysisManager:
    def __init__(self):
        self._analyzers: Dict[str, CodeAnalyzer] = {}
        self._metrics = MetricsManager.get_instance()
        
    def register_analyzer(self, name: str, analyzer: CodeAnalyzer) -> None:
        self._analyzers[name] = analyzer
        
    async def analyze_code(
        self,
        code: str,
        analyzers: Optional[List[str]] = None
    ) -> Dict[str, List[AnalysisResult]]:
        results = {}
        selected_analyzers = (
            [self._analyzers[name] for name in analyzers]
            if analyzers
            else self._analyzers.values()
        )
        
        for analyzer in selected_analyzers:
            try:
                results[analyzer.__class__.__name__] = analyzer.analyze(code)
            except Exception as e:
                results[analyzer.__class__.__name__] = [
                    AnalysisResult(
                        level=AnalysisLevel.ERROR,
                        message=f"Analysis failed: {e}",
                        details={"error": str(e)}
                    )
                ]
                
        return results
```

5. Migrar implementações existentes:
   - Atualizar `security/scanner.py`
   - Criar novos analisadores conforme necessário
   - Atualizar referências em outros módulos

## Validação

```python
async def test_code_analysis():
    # Setup
    manager = CodeAnalysisManager()
    manager.register_analyzer("security", SecurityAnalyzer())
    manager.register_analyzer("complexity", ComplexityAnalyzer())
    
    # Test security analysis
    code = """
    def unsafe():
        eval("1 + 1")
        import subprocess
        subprocess.run(["ls"])
    """
    
    results = await manager.analyze_code(code, ["security"])
    security_results = results["SecurityAnalyzer"]
    assert len(security_results) == 2  # eval and subprocess
    assert all(r.level == AnalysisLevel.ERROR for r in security_results)
    
    # Test complexity analysis
    code = """
    def complex(x):
        if x > 0:
            if x < 10:
                if x % 2 == 0:
                    if x % 3 == 0:
                        return True
        return False
    """
    
    results = await manager.analyze_code(code, ["complexity"])
    complexity_results = results["ComplexityAnalyzer"]
    assert len(complexity_results) == 1
    assert complexity_results[0].level == AnalysisLevel.WARNING
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_code_analysis():
    # Restore legacy implementations
    shutil.copy("security/scanner_legacy.py", "security/scanner.py")
    
    # Cleanup new implementations
    os.remove("core/analysis")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de análise
   - 100% dos módulos usando o novo sistema
   - Cobertura completa de análises

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero falsos positivos/negativos
   - Documentação completa

3. **Desempenho**:
   - Tempo médio de análise < 100ms
   - Uso de memória < 50MB
   - Cache hit rate > 90%

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação da interface CodeAnalyzer
- [ ] Implementação dos analisadores específicos
- [ ] Implementação dos visitantes AST
- [ ] Implementação do CodeAnalysisManager
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
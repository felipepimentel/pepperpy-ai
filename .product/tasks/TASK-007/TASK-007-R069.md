# R069: Padronização dos Schemas de Artefatos

## Descrição

Unificar e padronizar os schemas JSON dos artefatos em todo o framework, criando uma base comum e extensões específicas para cada tipo. O sistema atual possui schemas separados para cada tipo de artefato com muita duplicação de campos comuns, dificultando a manutenção e consistência.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R059: Padronização de Protocolos e Interfaces

## Estado Atual

Atualmente, os schemas estão definidos separadamente em vários arquivos:

1. Em `hub/artifacts/agent_artifact.json`:
```json
{
  "required": [
    "name",
    "version",
    "description",
    "author",
    "capabilities",
    "configuration"
  ],
  "properties": {
    "name": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9_-]+$"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "author": {
      "type": "object",
      "required": ["name", "email"]
    }
  }
}
```

2. Em `hub/artifacts/workflow_artifact.json`:
```json
{
  "required": [
    "name",
    "version",
    "description",
    "author",
    "steps",
    "configuration"
  ],
  "properties": {
    "name": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9_-]+$"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "author": {
      "type": "object",
      "required": ["name", "email"]
    }
  }
}
```

## Plano de Implementação

1. Criar schema base comum:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Base Artifact Schema",
  "description": "Base schema for all artifacts in the Pepperpy Hub",
  "type": "object",
  "required": [
    "name",
    "version",
    "description",
    "author",
    "metadata"
  ],
  "properties": {
    "name": {
      "type": "string",
      "description": "Name of the artifact",
      "pattern": "^[a-zA-Z0-9_-]+$",
      "minLength": 3,
      "maxLength": 64
    },
    "version": {
      "type": "string",
      "description": "Version of the artifact (semver)",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "description": {
      "type": "string",
      "description": "Description of the artifact's purpose and functionality"
    },
    "author": {
      "type": "object",
      "required": ["name", "email"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Author's name"
        },
        "email": {
          "type": "string",
          "description": "Author's email",
          "format": "email"
        },
        "organization": {
          "type": "string",
          "description": "Optional organization name"
        }
      }
    },
    "metadata": {
      "type": "object",
      "description": "Additional metadata",
      "additionalProperties": true
    }
  }
}
```

2. Implementar sistema de extensão de schemas:

```python
class SchemaManager:
    """Manager for artifact schemas."""
    
    def __init__(self):
        self._base_schema = self._load_base_schema()
        self._schemas: Dict[str, Dict[str, Any]] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_schema(
        self,
        artifact_type: str,
        schema: Dict[str, Any]
    ) -> None:
        """Register an artifact schema."""
        # Merge with base schema
        merged = self._merge_schemas(self._base_schema, schema)
        self._schemas[artifact_type] = merged
        
    def get_schema(
        self,
        artifact_type: str
    ) -> Dict[str, Any]:
        """Get schema for artifact type."""
        if artifact_type not in self._schemas:
            raise ValueError(f"Schema not found: {artifact_type}")
            
        return self._schemas[artifact_type]
        
    def validate(
        self,
        artifact_type: str,
        data: Dict[str, Any]
    ) -> List[str]:
        """Validate artifact data."""
        schema = self.get_schema(artifact_type)
        validator = jsonschema.Draft7Validator(schema)
        
        return [
            error.message
            for error in validator.iter_errors(data)
        ]
        
    def _merge_schemas(
        self,
        base: Dict[str, Any],
        extension: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Merge base schema with extension."""
        merged = copy.deepcopy(base)
        
        # Merge required fields
        if "required" in extension:
            merged["required"] = list(
                set(merged["required"]) | set(extension["required"])
            )
            
        # Merge properties
        if "properties" in extension:
            merged["properties"].update(extension["properties"])
            
        return merged
```

3. Criar schemas específicos:

```python
AGENT_SCHEMA = {
    "required": ["capabilities", "configuration"],
    "properties": {
        "capabilities": {
            "type": "array",
            "description": "List of agent capabilities",
            "items": {
                "type": "object",
                "required": ["name", "version"],
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Capability name"
                    },
                    "version": {
                        "type": "string",
                        "pattern": "^\\d+\\.\\d+\\.\\d+$"
                    }
                }
            }
        },
        "configuration": {
            "type": "object",
            "description": "Agent configuration"
        }
    }
}

WORKFLOW_SCHEMA = {
    "required": ["steps", "configuration"],
    "properties": {
        "steps": {
            "type": "array",
            "description": "Workflow steps",
            "items": {
                "type": "object",
                "required": ["name", "type", "config"],
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "config": {
                        "type": "object"
                    }
                }
            }
        },
        "configuration": {
            "type": "object",
            "description": "Workflow configuration"
        }
    }
}
```

4. Implementar sistema de monitoramento:

```python
class SchemaMonitor:
    """Monitor for schema operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_validation(
        self,
        artifact_type: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record schema validation."""
        self._metrics.counter(
            "schema_validations",
            1,
            artifact_type=artifact_type,
            success=str(success).lower(),
            **labels
        )
```

5. Migrar schemas existentes:
   - Atualizar `hub/artifacts/agent_artifact.json`
   - Atualizar `hub/artifacts/workflow_artifact.json`
   - Atualizar `hub/artifacts/tool_artifact.json`
   - Atualizar `hub/artifacts/prompt_artifact.json`
   - Atualizar `hub/artifacts/knowledge_artifact.json`
   - Atualizar `hub/artifacts/capability_artifact.json`

## Validação

```python
async def test_schema_system():
    # Setup
    manager = SchemaManager()
    monitor = SchemaMonitor()
    
    # Register schemas
    manager.register_schema("agent", AGENT_SCHEMA)
    manager.register_schema("workflow", WORKFLOW_SCHEMA)
    
    # Test valid agent
    agent_data = {
        "name": "test-agent",
        "version": "1.0.0",
        "description": "Test agent",
        "author": {
            "name": "Test Author",
            "email": "test@example.com"
        },
        "capabilities": [
            {
                "name": "test",
                "version": "1.0.0"
            }
        ],
        "configuration": {},
        "metadata": {}
    }
    
    errors = manager.validate("agent", agent_data)
    assert not errors
    
    # Test invalid workflow
    workflow_data = {
        "name": "test-workflow",
        "version": "invalid",
        "description": "Test workflow"
    }
    
    errors = manager.validate("workflow", workflow_data)
    assert len(errors) > 0
    
    # Test monitoring
    await monitor.record_validation("agent", True)
    await monitor.record_validation("workflow", False)
```

## Plano de Rollback

1. Manter schemas antigos em arquivos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_schema_system():
    # Restore legacy schemas
    for artifact_type in ["agent", "workflow", "tool", "prompt", "knowledge", "capability"]:
        shutil.copy(
            f"hub/artifacts/{artifact_type}_artifact_legacy.json",
            f"hub/artifacts/{artifact_type}_artifact.json"
        )
    
    # Cleanup new implementations
    os.remove("hub/schemas/base.json")
    os.remove("hub/schemas/manager.py")
    os.remove("hub/schemas/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de campos comuns
   - Interface consistente
   - Schemas unificados

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero erros de validação não tratados
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para validação
   - Uso eficiente de recursos
   - Cache de schemas compilados

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do schema base
- [ ] Implementação do sistema de extensão
- [ ] Implementação dos schemas específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração dos schemas existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 
# R065: Consolidação do Sistema de Armazenamento

## Descrição

Unificar e padronizar o sistema de armazenamento em todo o framework, estabelecendo uma interface consistente para persistência e recuperação de dados. O sistema atual possui diferentes implementações de armazenamento espalhadas em vários módulos, dificultando a manutenção e a consistência do código.

## Dependências

- R024: Consolidação do Sistema de Observabilidade
- R026: Consolidação do Sistema de Resource Management

## Estado Atual

Atualmente, o sistema de armazenamento está distribuído em vários módulos:

1. Em `content/storage.py`:
```python
class ContentStorage(ABC):
    """Base class for content storage."""
    
    @abstractmethod
    def save(self, content: Content) -> UUID:
        """Save content to storage."""
        pass
        
    @abstractmethod
    def load(self, content_id: UUID) -> Content:
        """Load content from storage."""
        pass
        
    @abstractmethod
    def delete(self, content_id: UUID) -> None:
        """Delete content from storage."""
        pass
```

2. Em `memory/stores/redis.py`:
```python
class RedisMemoryStore(BaseMemoryStore[T]):
    """Redis memory store implementation."""
    
    async def _retrieve(
        self,
        query: MemoryQuery,
    ) -> AsyncIterator[MemorySearchResult[T]]:
        """Retrieve memories from Redis store."""
        if not self._client:
            raise RedisMemoryError("Redis client not initialized")
            
        try:
            pattern = self._get_key_pattern(query)
            async with self._get_client() as client:
                keys = await self._scan_keys(pattern)
                
                for key in keys:
                    entry = await self._load_entry(key, client)
                    if entry is None:
                        continue
                        
                    if not self._matches_filters(entry, query):
                        continue
                        
                    yield MemorySearchResult(
                        entry=entry,
                        score=1.0,
                        highlights=[],
                        metadata={}
                    )
                    
        except Exception as e:
            raise RedisMemoryError(
                "Failed to retrieve from Redis",
                store_type="redis",
                details={"error": str(e)}
            )
```

## Plano de Implementação

1. Criar sistema base de armazenamento:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Generic, List, Optional, TypeVar, AsyncIterator
from dataclasses import dataclass
from datetime import datetime
from uuid import UUID, uuid4

T = TypeVar("T")
K = TypeVar("K")

@dataclass
class StorageMetadata:
    """Metadata for stored items."""
    id: UUID
    key: str
    content_type: str
    created_at: datetime
    updated_at: datetime
    expires_at: Optional[datetime]
    tags: Dict[str, str]

@dataclass
class StorageItem(Generic[T]):
    """Base class for stored items."""
    data: T
    metadata: StorageMetadata

@dataclass
class StorageQuery:
    """Query parameters for storage."""
    pattern: Optional[str] = None
    content_type: Optional[str] = None
    tags: Optional[Dict[str, str]] = None
    created_after: Optional[datetime] = None
    created_before: Optional[datetime] = None
    expires_after: Optional[datetime] = None
    expires_before: Optional[datetime] = None

@dataclass
class StorageResult(Generic[T]):
    """Result of storage query."""
    item: StorageItem[T]
    score: float
    highlights: List[str]

class StorageProvider(ABC, Generic[T]):
    """Base class for storage providers."""
    
    @abstractmethod
    async def save(
        self,
        key: str,
        data: T,
        content_type: str,
        expires_at: Optional[datetime] = None,
        tags: Optional[Dict[str, str]] = None
    ) -> StorageItem[T]:
        """Save item to storage."""
        pass
        
    @abstractmethod
    async def load(
        self,
        key: str
    ) -> StorageItem[T]:
        """Load item from storage."""
        pass
        
    @abstractmethod
    async def delete(
        self,
        key: str
    ) -> bool:
        """Delete item from storage."""
        pass
        
    @abstractmethod
    async def search(
        self,
        query: StorageQuery
    ) -> AsyncIterator[StorageResult[T]]:
        """Search items in storage."""
        pass
        
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up storage resources."""
        pass
```

2. Implementar sistema de gerenciamento unificado:

```python
class UnifiedStorageManager:
    """Unified storage management system."""
    
    def __init__(self):
        self._providers: Dict[str, StorageProvider] = {}
        self._metrics = MetricsManager.get_instance()
        self._logger = logging.getLogger(__name__)
        
    def register_provider(
        self,
        content_type: str,
        provider: StorageProvider
    ) -> None:
        """Register a storage provider."""
        self._providers[content_type] = provider
        
    async def save(
        self,
        key: str,
        data: Any,
        content_type: str,
        expires_at: Optional[datetime] = None,
        tags: Optional[Dict[str, str]] = None
    ) -> StorageItem:
        """Save item to storage."""
        if content_type not in self._providers:
            raise ValueError(f"Provider not found: {content_type}")
            
        provider = self._providers[content_type]
        
        try:
            item = await provider.save(
                key,
                data,
                content_type,
                expires_at,
                tags
            )
            
            self._metrics.counter(
                "storage_operations",
                1,
                operation="save",
                content_type=content_type,
                success="true"
            )
            
            return item
            
        except Exception as e:
            self._metrics.counter(
                "storage_operations",
                1,
                operation="save",
                content_type=content_type,
                success="false"
            )
            
            self._logger.error(
                "Failed to save item",
                extra={
                    "content_type": content_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def load(
        self,
        key: str,
        content_type: str
    ) -> StorageItem:
        """Load item from storage."""
        if content_type not in self._providers:
            raise ValueError(f"Provider not found: {content_type}")
            
        provider = self._providers[content_type]
        
        try:
            item = await provider.load(key)
            
            self._metrics.counter(
                "storage_operations",
                1,
                operation="load",
                content_type=content_type,
                success="true"
            )
            
            return item
            
        except Exception as e:
            self._metrics.counter(
                "storage_operations",
                1,
                operation="load",
                content_type=content_type,
                success="false"
            )
            
            self._logger.error(
                "Failed to load item",
                extra={
                    "content_type": content_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def delete(
        self,
        key: str,
        content_type: str
    ) -> bool:
        """Delete item from storage."""
        if content_type not in self._providers:
            raise ValueError(f"Provider not found: {content_type}")
            
        provider = self._providers[content_type]
        
        try:
            deleted = await provider.delete(key)
            
            self._metrics.counter(
                "storage_operations",
                1,
                operation="delete",
                content_type=content_type,
                success="true"
            )
            
            return deleted
            
        except Exception as e:
            self._metrics.counter(
                "storage_operations",
                1,
                operation="delete",
                content_type=content_type,
                success="false"
            )
            
            self._logger.error(
                "Failed to delete item",
                extra={
                    "content_type": content_type,
                    "error": str(e)
                }
            )
            
            raise
            
    async def search(
        self,
        query: StorageQuery
    ) -> AsyncIterator[StorageResult]:
        """Search items in storage."""
        if query.content_type and query.content_type not in self._providers:
            raise ValueError(f"Provider not found: {query.content_type}")
            
        providers = (
            [self._providers[query.content_type]]
            if query.content_type
            else self._providers.values()
        )
        
        for provider in providers:
            try:
                async for result in provider.search(query):
                    yield result
                    
            except Exception as e:
                self._logger.error(
                    "Failed to search items",
                    extra={
                        "content_type": query.content_type,
                        "error": str(e)
                    }
                )
                
    async def cleanup(self) -> None:
        """Clean up all storage resources."""
        for provider in self._providers.values():
            try:
                await provider.cleanup()
            except Exception as e:
                self._logger.error(
                    "Failed to clean up provider",
                    extra={"error": str(e)}
                )
```

3. Implementar provedores específicos:

```python
class RedisStorageProvider(StorageProvider[Dict[str, Any]]):
    """Redis storage provider implementation."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self._client = None
        self._metrics = MetricsManager.get_instance()
        
    async def save(
        self,
        key: str,
        data: Dict[str, Any],
        content_type: str,
        expires_at: Optional[datetime] = None,
        tags: Optional[Dict[str, str]] = None
    ) -> StorageItem[Dict[str, Any]]:
        """Save item to Redis."""
        if not self._client:
            await self._connect()
            
        metadata = StorageMetadata(
            id=uuid4(),
            key=key,
            content_type=content_type,
            created_at=datetime.now(),
            updated_at=datetime.now(),
            expires_at=expires_at,
            tags=tags or {}
        )
        
        item = StorageItem(
            data=data,
            metadata=metadata
        )
        
        try:
            async with self._client.pipeline() as pipe:
                # Save data
                await pipe.hset(
                    f"data:{key}",
                    mapping=data
                )
                
                # Save metadata
                await pipe.hset(
                    f"metadata:{key}",
                    mapping=asdict(metadata)
                )
                
                # Set expiration
                if expires_at:
                    await pipe.expireat(
                        f"data:{key}",
                        int(expires_at.timestamp())
                    )
                    await pipe.expireat(
                        f"metadata:{key}",
                        int(expires_at.timestamp())
                    )
                    
                await pipe.execute()
                
            return item
            
        except Exception as e:
            raise StorageError(
                "Failed to save to Redis",
                details={"error": str(e)}
            )
            
    async def load(
        self,
        key: str
    ) -> StorageItem[Dict[str, Any]]:
        """Load item from Redis."""
        if not self._client:
            await self._connect()
            
        try:
            async with self._client.pipeline() as pipe:
                # Load data
                data = await self._client.hgetall(f"data:{key}")
                if not data:
                    raise KeyError(f"Key not found: {key}")
                    
                # Load metadata
                metadata_dict = await self._client.hgetall(f"metadata:{key}")
                if not metadata_dict:
                    raise KeyError(f"Metadata not found: {key}")
                    
                metadata = StorageMetadata(**metadata_dict)
                
                return StorageItem(
                    data=data,
                    metadata=metadata
                )
                
        except Exception as e:
            raise StorageError(
                "Failed to load from Redis",
                details={"error": str(e)}
            )
            
    async def delete(
        self,
        key: str
    ) -> bool:
        """Delete item from Redis."""
        if not self._client:
            await self._connect()
            
        try:
            async with self._client.pipeline() as pipe:
                # Delete data and metadata
                await pipe.delete(f"data:{key}")
                await pipe.delete(f"metadata:{key}")
                
                results = await pipe.execute()
                
                return any(results)
                
        except Exception as e:
            raise StorageError(
                "Failed to delete from Redis",
                details={"error": str(e)}
            )
            
    async def search(
        self,
        query: StorageQuery
    ) -> AsyncIterator[StorageResult[Dict[str, Any]]]:
        """Search items in Redis."""
        if not self._client:
            await self._connect()
            
        try:
            pattern = query.pattern or "*"
            async for key in self._client.scan_iter(f"data:{pattern}"):
                try:
                    item = await self.load(key.removeprefix("data:"))
                    
                    if not self._matches_query(item, query):
                        continue
                        
                    yield StorageResult(
                        item=item,
                        score=1.0,
                        highlights=[]
                    )
                    
                except Exception as e:
                    self._logger.error(
                        "Failed to load item during search",
                        extra={
                            "key": key,
                            "error": str(e)
                        }
                    )
                    
        except Exception as e:
            raise StorageError(
                "Failed to search in Redis",
                details={"error": str(e)}
            )
            
    async def cleanup(self) -> None:
        """Clean up Redis resources."""
        if self._client:
            await self._client.close()
            self._client = None
            
    async def _connect(self) -> None:
        """Connect to Redis."""
        try:
            self._client = await aioredis.create_redis_pool(**self.config)
        except Exception as e:
            raise StorageError(
                "Failed to connect to Redis",
                details={"error": str(e)}
            )
            
    def _matches_query(
        self,
        item: StorageItem,
        query: StorageQuery
    ) -> bool:
        """Check if item matches query."""
        if query.content_type and item.metadata.content_type != query.content_type:
            return False
            
        if query.tags:
            for key, value in query.tags.items():
                if item.metadata.tags.get(key) != value:
                    return False
                    
        if query.created_after and item.metadata.created_at < query.created_after:
            return False
            
        if query.created_before and item.metadata.created_at > query.created_before:
            return False
            
        if query.expires_after and (
            not item.metadata.expires_at
            or item.metadata.expires_at < query.expires_after
        ):
            return False
            
        if query.expires_before and (
            not item.metadata.expires_at
            or item.metadata.expires_at > query.expires_before
        ):
            return False
            
        return True
```

4. Implementar sistema de monitoramento:

```python
class StorageMonitor:
    """Monitor for storage operations."""
    
    def __init__(self):
        self._metrics = MetricsManager.get_instance()
        
    async def record_operation(
        self,
        content_type: str,
        operation: str,
        success: bool = True,
        **labels: str
    ) -> None:
        """Record storage operation."""
        self._metrics.counter(
            "storage_operations",
            1,
            content_type=content_type,
            operation=operation,
            success=str(success).lower(),
            **labels
        )
        
    async def record_size(
        self,
        content_type: str,
        size: int,
        **labels: str
    ) -> None:
        """Record storage size."""
        self._metrics.gauge(
            "storage_size",
            size,
            content_type=content_type,
            **labels
        )
```

5. Migrar implementações existentes:
   - Atualizar `content/storage.py`
   - Atualizar `memory/stores/redis.py`
   - Criar novos provedores conforme necessário

## Validação

```python
async def test_storage_system():
    # Setup
    manager = UnifiedStorageManager()
    monitor = StorageMonitor()
    
    # Register providers
    redis_provider = RedisStorageProvider({
        "host": "localhost",
        "port": 6379
    })
    manager.register_provider("test", redis_provider)
    
    # Test save
    item = await manager.save(
        "test_key",
        {"value": "test"},
        "test",
        tags={"purpose": "test"}
    )
    
    assert item.metadata.key == "test_key"
    assert item.data["value"] == "test"
    assert item.metadata.tags["purpose"] == "test"
    
    # Test load
    loaded = await manager.load("test_key", "test")
    assert loaded.data["value"] == "test"
    
    # Test search
    query = StorageQuery(
        content_type="test",
        tags={"purpose": "test"}
    )
    
    results = []
    async for result in manager.search(query):
        results.append(result)
        
    assert len(results) == 1
    assert results[0].item.data["value"] == "test"
    
    # Test delete
    deleted = await manager.delete("test_key", "test")
    assert deleted
    
    # Test monitoring
    await monitor.record_operation("test", "save", True)
    await monitor.record_size("test", 1000)
```

## Plano de Rollback

1. Manter implementações antigas em módulos separados com sufixo `_legacy`
2. Implementar função de migração reversa:
```python
async def rollback_storage_system():
    # Restore legacy implementations
    shutil.copy("content/storage_legacy.py", "content/storage.py")
    shutil.copy("memory/stores/redis_legacy.py", "memory/stores/redis.py")
    
    # Cleanup new implementations
    os.remove("core/storage/base.py")
    os.remove("core/storage/manager.py")
    os.remove("core/storage/monitor.py")
```

## Métricas de Sucesso

1. **Padronização**:
   - Zero duplicação de código de armazenamento
   - Interface consistente
   - Implementações unificadas

2. **Qualidade**:
   - 100% de cobertura de testes
   - Zero vazamentos de recursos
   - Documentação completa

3. **Performance**:
   - Latência < 50ms para operações de escrita
   - Latência < 20ms para operações de leitura
   - Uso eficiente de recursos

## Atualizações de Progresso

- [x] Criação do requisito (2024-02-22)
- [ ] Implementação do sistema base de armazenamento
- [ ] Implementação do gerenciamento unificado
- [ ] Implementação dos provedores específicos
- [ ] Implementação do sistema de monitoramento
- [ ] Migração das implementações existentes
- [ ] Testes de integração
- [ ] Documentação atualizada
- [ ] Revisão de código
- [ ] Deploy em produção 